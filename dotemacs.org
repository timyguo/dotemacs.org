#+TITLE: dotemacs
#+AUTHOR: Tony Day
#+EMAIL: tonyday567 at gmail dot com
#+COLUMNS: %25ITEM %30tangle
#+PROPERTIES: tangle yes


* upfront
:PROPERTIES:
:tangle:   no
:END:
** design

General design:
- is restrained by the necessary existence of init.el.
- file structure is as flat as possible, subject to submodule needs
- is opinionated as to what should be added (mostly according to
  questionable author tastes)
- is mostly about hooking jwiegley dots up, especially use-package
  and bind, and then doing things to them that are dangerous.

** flow
The main sections are (in order)
- bootstrap. stuff that absolutely has to go at the front and load before
  everything else. order matters.
- guff. code that is not associated with packages but where ordering
  is unimportant.
- packages. package requires and configurations that can be put most anywhere and can be
  unordered (or in alphabetical order for the neatos).
- files. file loads that are files just for convenience (and can be loaded
  in alphabetical order).
- endboot. stuff that has to go at the end.

* init.el
:PROPERTIES:
:tangle:   init.el
:END:

The init.el file is the only file in the startup of emacs
that *needs* to be a .el file.  If you update it here and don't
tangle it the old copy will remain in place only to be overwritten
automatically next restart.

Not much we can do about that.

It does exactly 3 things.
1. finds out where it is and sets the current directory as the
   user-emacs-directory (~/.emacs.d in 99% of cases these days). This
   means that it can start anywhere if pointed to with:
  
   #+begin_src sh :tangle no
     /Applications/Emacs.app/Contents/MacOS/Emacs -q -l not-the-home/init.el     
   #+end_src
  
  or

  #+begin_src sh :tangle no
    emacs -q -l not-the-home/init.el     
  #+end_src
  
  The other way to test outside of your regular ~/.emacs.d is to set
  $HOME=~/fakehome and place init.el in ~/fakehome/.emacs.d.  
2. loads the org directory (if it exists).  This is needed in case
  there is a more recent org-mode installed in which case usage of
  babel before loading the path will result in a mixed install.  Not
  fun debugging that.    
3. loads the /real/ init code, which i have called dotemacs and which
   is contained in this file.

** debug initial values
:PROPERTIES:
:tangle:   no
:END:
   set debugs as separate blocks and turn on and off in org using tangle
     #+begin_src emacs-lisp
     (defun debug-message (&optional debug-name debug-value)
             (message (concat 
                "#+begin_debug\n"
                (format "%s\n" buffer-file-name)
                (if debug-name
                  (format "%s\n" debug-name))
                (if debug-value
                    (format "%s\n" debug-value))
                "#+end_debug\n")))
     #+end_src

  #+begin_src emacs-lisp
     (debug-message "load-path init.el entry" load-path)
     (debug-message "user-emacs-directory init.el entry" user-emacs-directory)
  #+end_src
 
** init.el

  
#+Begin_src emacs-lisp :tangle init.el :var tangled-in=(buffer-file-name)
  ;; see dotemacs.org for documentation
  (setq user-emacs-directory
        (file-name-directory (or load-file-name user-emacs-directory "~/.emacs.d/")))
  (defvar org-dir
  "site-lisp/org-mode/lisp"
  "location of the directory containing org-mode")
  (add-to-list 'load-path (expand-file-name org-dir user-emacs-directory))
  (defvar dotemacs-org-file
  "dotemacs.org"
  "Name of the org file containing the main startup code")
  (if (boundp 'tangled-in)
     (setq dotemacs-org-file tangled-in))
  (org-babel-load-file (expand-file-name dotemacs-org-file user-emacs-directory))
#+end_src

* bootstrap
:PROPERTIES:
:tangle:   yes
:END:
** initialization
:PROPERTIES:
:TANGLE:   yes
:END:

#+begin_src emacs-lisp
;;;_. Initialization

(setq message-log-max 16384)

(defconst emacs-start-time (current-time))

(unless noninteractive
  (message "Loading %s..." load-file-name))

#+end_src

** org table defuns

Helper code to enable the use of org-tables in the stratup process.
Remember right here we are in a load environment and relying on
standard emacs packages to do stuff.

#+begin_src emacs-lisp
(require 'cl)
(defun org-table-list-and-toggle (table)
"turns an org-table into a list"                                       
(if (eq (cadr table) 'hline) 
    (setq table (cddr table)))
(loop for el in table
      when (not (equal "" (cadr el))) 
      collect
      (car el)))

  (defun org-table-remove-header (table)
    "turns an org-table into a list"                                       
    (if (eq (cadr table) 'hline) 
        (setq table (cddr table))))
#+end_src
 
** load-path
  :PROPERTIES:
  :tangle: 
  :END:
*** library tools
  #+begin_src emacs-lisp
    (load "org-macs")
    (setq debug-on-error t)
  (locate-library "font-latex")
  (locate-file "yasnippet.el" load-path)
  (locate-library "auctex-autoloads")
  #+end_src


*** path load defuns
#+begin_src emacs-lisp
(defun add-to-load-path (path &optional dir)
  "add dir to load path. "  
  (setq load-path
        (cons (expand-file-name path (or dir user-emacs-directory)) 
load-path)))

(defun add-to-load-path-include-subdirs (path)
  "add level 1 subdirectories of path to te load-path."
  (add-to-load-path path)
  (dolist (entry (nreverse (directory-files-and-attributes
                            (expand-file-name path user-emacs-directory))))
    (if (and (cadr entry)
             (not (equal "." (car entry)))
             (not (equal ".." (car entry)))) 
        (add-to-load-path (car entry)
                          (expand-file-name path user-emacs-directory)))))
#+end_src

*** TODO group load path table

- [ ] removing repo hooks
- [ ] work out why helm isn't working


These directory groups (directory and sub-directories) are added to the path.

#+name: group-load-path-table
| directory               | toggle |
|-------------------------+--------|
| overides                | t      |
| elpa                    | t      |
| site-lisp               | t      |
| site-lisp/cedet         | t      |
| site-lisp/jwiegley-lisp | t      |
| site-lisp/ac            | t      |

And here's where we start taking advantage of using org on startup.
If you would like to add more group loads, just add to the above
table. You can temporarily turn anything off by deleting the toggle
row.

#+begin_src emacs-lisp :var table=group-load-path-table
(defvar group-load-directories
      (list "lisp" "site-lisp")
      "directories that should have their subdirectories added 
to the load-path. Can be absolute or relative to user-emacs-directory")

(setq group-load-directories (org-table-list-and-toggle table))
(mapc #'add-to-load-path-include-subdirs
          (nreverse group-load-directories))
#+end_src

#+results:
| site-lisp/ac | site-lisp/jwiegley-lisp | site-lisp/cedet | site-lisp | elpa/auctex-11.86 | elpa | overides |

*** load path table

Any other directories needed on the path go here:

#+name: load-path-table
| directory                                  | toggle |
|--------------------------------------------+--------|
| ~/.emacs.d                                 | t      |
| ~/.emacs.d/elpa/ess-20121027.2218/lisp     | t      |
| ~/.emacs.d/site-lisp/org-mode/contrib/lisp | t      |

#+begin_src emacs-lisp :var table=load-path-table
(defvar path-directories
      (list "~/.emacs.d")
      "Directories that should be added to load-path.")

(setq path-directories (org-table-list-and-toggle table))
    (mapc #'add-to-load-path
          (nreverse path-directories))
    (setq load-path (delete-dups load-path))
(require 'autoloads nil t)
(require 'cus-load nil t)
#+end_src

#+results:
: cus-load

*** load-path check
    :PROPERTIES:
    :tangle:   no
    :END:

checking on the result ...

The nice thing here is the startup process can store results in
variable, or you can just C-c C-c the block in org-mode after the event.

#+begin_src emacs-lisp
(setq load-path-check 
(loop for f in load-path
               collect
               (list f)))
#+end_src

#+begin_src emacs-lisp
  (list-load-path-shadows "helm")
#+end_src



** elpa
   :PROPERTIES:
   :tangle:   yes
   :END:

*** elpa archive repositories
    :PROPERTIES:
    :tangle: 
    :END:

#+begin_src emacs-lisp
    (setq package-enable-at-startup nil)
    (setq package-archives
          '(("melpa" . "http://melpa.milkbox.net/packages/")
            ("gnu"         . "http://elpa.gnu.org/packages/")
            ("marmalade"   . "http://marmalade-repo.org/packages/")))
    ;;(package-initialize)
 #+end_src

*** dependency checks
:PROPERTIES:
:tangle:   no
:END:

#+TBLNAME: table-elpa-check
| package              | check? | notes                      |
|----------------------+--------+----------------------------|
| auctex               | t      |                            |
| clojure-mode         |        |                            |
| elisp-slime-nav      | t      | add to sklisp              |
| find-file-in-project | t      | delay                      |
| idle-highlight-...   |        | didnt install properly     |
| ido-ubiquitous       | t      | package add elsewhere      |
| js-comint            |        |                            |
| js2-mode             |        |                            |
| json                 |        |                            |
| magit                | t      |                            |
| magithub             | t      | learn                      |
| org                  |        | direct from repo           |
| org-magit            |        |                            |
| org2blog             |        |                            |
| paredit              | t      |                            |
| slime                | t      | check                      |
| smex                 | t      |                            |
| xml-rpc              | t      | dep for org2blog           |
| yaml-mode            | t      | check                      |
| yasnippet            | t      |                            |
| zenburn-theme        | t      | check how themes are added |

#+begin_src emacs-lisp :var table=table-elpa-check
  (defvar package-list-to-check
        (list "")
        "packages that should be checked and loaded if not found")
  (setq package-list-to-check (org-table-list-and-toggle table))
      (unless package-archive-contents
        (package-refresh-contents))
      (dolist (package package-list-to-check)
         (eval (car (read-from-string (format "(unless (package-installed-p '%s)
                                               (package-install '%s))" package package)))))
#+end_src

** theme
  #+begin_src emacs-lisp
    (setq custome-theme-directory "Users/tonyday/.emacs.d/themes/")
    (setq custom-theme-load-path (quote 
                                  (custom-theme-directory 
                                   t 
                                   "/Users/tonyday/.emacs.d/elpa/zenburn-theme-1.5" 
                                   "/Users/tonyday/.emacs.d/themes/")))
    (load-theme 'zenburn t)
    (load-theme 'zenburn-overrides t)
    (load-theme 'system-type-darwin t)
  #+end_src

  #+results:
  : t

** use-package and bind
   :PROPERTIES:
   :tangle: 
   :END:
#+begin_src emacs-lisp
(require 'use-package)
(eval-when-compile
  (setq use-package-verbose (null byte-compile-current-file)))
#+end_src

#+begin_src emacs-lisp
  (require 'bind-key)    
  (defun bind-keys-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(bind-key %S '%s)" row))))))
#+end_src

** read system environment
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , Read system environment

(let ((plist (expand-file-name "~/.MacOSX/environment.plist")))
  (when (file-readable-p plist)
    (let ((dict (cdr (assq 'dict (cdar (xml-parse-file plist))))))
      (while dict
        (if (and (listp (car dict))
                 (eq 'key (caar dict)))
            (setenv (car (cddr (car dict)))
                    (car (cddr (car (cddr dict))))))
        (setq dict (cdr dict))))

    ;; Configure exec-path based on the new PATH
    (setq exec-path nil)
    (mapc (apply-partially #'add-to-list 'exec-path)
          (nreverse (split-string (getenv "PATH") ":")))))

#+end_src

** check emacs version
#+begin_src emacs-lisp
      (defvar running-alternate-emacs nil)
#+end_src
   
* guff
:PROPERTIES:
:tangle:   yes
:END:
** process settings table

#+name: process-settings-table
| variable                       | value |
|--------------------------------+-------|


#+name: process-settings-function-table
| function                   | args   |
|----------------------------+--------|


#+begin_src emacs-lisp
  (defun set-variables-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(setq %s %s)" row))))))

  (defun set-functions-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(%s %s)" row))))))

#+end_src

  #+begin_src emacs-lisp :var table=process-settings-table
  (set-variables-from-table (org-table-remove-header table))  
  #+end_src

  #+begin_src emacs-lisp :var table=process-settings-function-table
  (set-functions-from-table (org-table-remove-header table))
  #+end_src

** orphans
:PROPERTIES:
:tangle: 
:END:

Miscellaneous settings and snippets that I haven't org-tabled or categorised.

*** yes-or-no
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** elc deletion
#+begin_src emacs-lisp
  (defun dwa/delete-corresponding-elc-file ()
  "When the current buffer is an elisp source file, delete
any corresponding compiled .elc file"
  (when (and (buffer-file-name) 
             (string-match "\\`\\(.*\\)[.]el\\(?:[.]gz\\)?\\'" (buffer-file-name)))
    (let ((elc (concat (match-string 1 (buffer-file-name)) ".elc")))
      (when (file-exists-p elc)
        (delete-file elc)))))

;; Be sure not to leave around any outdated .elc files
(add-hook 'before-save-hook 'dwa/delete-corresponding-elc-file)
#+end_src

** extra bindings
   :PROPERTIES:
   :tangle: 
   :END:

#+name: tob
| key       | binding                             |
|-----------+-------------------------------------|
| C-+       | text-scale-increase                 |
| C--       | text-scale-decrease                 |
| C-c C-v k | org-table-recalculate-buffer-tables |

- unit test one row
  #+begin_src emacs-lisp :var table=tob[2,] :tangle no
(setq row '("C-c C-v k" "org-table-recalculate-buffer-tables"))
(eval (car (read-from-string 
                     (apply 'format "(bind-key %S '%s)" row))))
#+end_src

  #+RESULTS:
  : org-table-recalculate-buffer-tables

#+begin_src emacs-lisp :var table=tob
  (bind-keys-from-table (org-table-remove-header table))  
#+end_src

** utility macros and functions
#+begin_src emacs-lisp
;;;_ , Utility macros and functions

(defmacro hook-into-modes (func modes)
  `(dolist (mode-hook ,modes)
     (add-hook mode-hook ,func)))

(defun system-idle-time ()
  (with-temp-buffer
    (call-process "ioreg" nil (current-buffer) nil
                  "-c" "IOHIDSystem" "-d" "4" "-S")
    (goto-char (point-min))
    (and (re-search-forward "\"HIDIdleTime\" = \\([0-9]+\\)" nil t)
         (/ (float (string-to-number (match-string 1)))
            1000000000.0))))

(defun quickping (host)
  (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))

(defun cleanup-term-log ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (require 'ansi-color)
  (ansi-color-apply-on-region (point-min) (point-max))
  (goto-char (point-min))
  (while (re-search-forward "\\(.\\|
$\\|P.+\\\\\n\\)" nil t)
    (overlay-put (make-overlay (match-beginning 0) (match-end 0))
                 'invisible t))
  (set-buffer-modified-p nil))

(add-hook 'find-file-hooks
          (function
           (lambda ()
             (if (string-match "/\\.iTerm/.*\\.log\\'"
                               (buffer-file-name))
                 (cleanup-term-log)))))

#+end_src
** enable disabled commands
#+begin_src emacs-lisp
;;;_ , Enable disabled commands

(put 'downcase-region  'disabled nil)   ; Let downcasing work
(put 'erase-buffer     'disabled nil)
(put 'eval-expression  'disabled nil)   ; Let ESC-ESC work
(put 'narrow-to-page   'disabled nil)   ; Let narrowing work
(put 'narrow-to-region 'disabled nil)   ; Let narrowing work
(put 'set-goal-column  'disabled nil)
(put 'upcase-region    'disabled nil)   ; Let upcasing work

#+end_src
** keybindings
:PROPERTIES:
:tangle: 
:END:
#+begin_src emacs-lisp
;;;_. Keybindings

;; Main keymaps for personal bindings are:
;;
;;   C-x <letter>  primary map (has many defaults too)
;;   C-c <letter>  secondary map (not just for mode-specific)
;;   C-. <letter>  tertiary map
;;
;;   M-g <letter>  goto map
;;   M-s <letter>  search map
;;   M-o <letter>  markup map (even if only temporarily)
;;
;;   C-<capital letter>
;;   M-<capital letter>
;;
;;   A-<anything>
;;   M-A-<anything>
;;
;; Single-letter bindings still available:
;;   C- ,'";:?<>|!#$%^&*`~ <tab>
;;   M- ?#

#+end_src
*** global-map
#+begin_src emacs-lisp
;;;_ , global-map

#+end_src
**** C-?
:PROPERTIES:
:tangle: 
:END:
#+begin_src emacs-lisp
;;;_  . C-?

(defvar ctl-period-map)
(define-prefix-command 'ctl-period-map)
(bind-key "C-." 'ctl-period-map)

(bind-key* "<C-return>" 'other-window)

(defun collapse-or-expand ()
  (interactive)
  (if (> (length (window-list)) 1)
      (delete-other-windows)
    (bury-buffer)))

(bind-key "C-z" 'collapse-or-expand)
(bind-key "C-w" 'backward-kill-word)

#+end_src
**** M-?
#+begin_src emacs-lisp
  ;;;_  . M-?
  
  (defadvice async-shell-command (before uniqify-running-shell-command activate)
    (let ((buf (get-buffer "*Async Shell Command*")))
      (if buf
          (let ((proc (get-buffer-process buf)))
            (if (and proc (eq 'run (process-status proc)))
                (with-current-buffer buf
                  (rename-uniquely)))))))
  
  (bind-key "M-!" 'async-shell-command)
  (bind-key "M-/" 'dabbrev-expand)
  (bind-key "M-'" 'insert-pair)
  (bind-key "M-\"" 'insert-pair)
  
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark))))
  
  (bind-key "M-[" 'align-code)
  (bind-key "M-`" 'other-frame)
  
  (bind-key "M-j" 'delete-indentation-forward)
  (bind-key "M-J" 'delete-indentation)
  
  (bind-key "M-W" 'mark-word)
  
  (defun mark-line (&optional arg)
    (interactive "p")
    (beginning-of-line)
    (let ((here (point)))
      (dotimes (i arg)
        (end-of-line))
      (set-mark (point))
      (goto-char here)))
  
  (bind-key "M-L" 'mark-line)
  
  (defun delete-leading-whitespace ()
    "delete leading whitespace from current buffer"
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (search-forward-regexp "[^ 
  ]")
      (delete-region (point-min)  (- (point) 1))))
  
  (bind-key "H-L" 'delete-leading-whitespace)
  
  
  (defun mark-sentence (&optional arg)
    (interactive "P")
    (backward-sentence)
    (mark-end-of-sentence arg))
  
  (bind-key "M-S" 'mark-sentence)
  (bind-key "M-X" 'mark-sexp)
  (bind-key "M-H" 'mark-paragraph)
  (bind-key "M-D" 'mark-defun)
  
  (bind-key "M-g c" 'goto-char)
  (bind-key "M-g l" 'goto-line)
  
  (defun delete-indentation-forward ()
    (interactive)
    (delete-indentation t))
  
  (bind-key "M-s n" 'find-name-dired)
  (bind-key "M-s o" 'occur)
  
#+end_src

**** M-C-?
#+begin_src emacs-lisp
;;;_  . M-C-?

(bind-key "<C-M-backspace>" 'backward-kill-sexp)

(defun isearch-backward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-backward))

(bind-key "C-M-r" 'isearch-backward-other-window)

(defun isearch-forward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-forward))

(bind-key "C-M-s" 'isearch-forward-other-window)

;; Some further isearch bindings
(bind-key "C-c" 'isearch-toggle-case-fold isearch-mode-map)
(bind-key "C-t" 'isearch-toggle-regexp isearch-mode-map)
(bind-key "C-^" 'isearch-edit-string isearch-mode-map)
(bind-key "C-i" 'isearch-complete isearch-mode-map)

#+end_src

**** A-?
#+begin_src emacs-lisp
;;;_  . A-?

(define-key key-translation-map (kbd "A-TAB") (kbd "C-TAB"))

#+end_src
*** ctl-x-map
#+begin_src emacs-lisp
;;;_ , ctl-x-map

#+end_src
**** C-x ?
#+begin_src emacs-lisp
;;;_  . C-x ?

(bind-key "C-x B" 'ido-switch-buffer-other-window)
(bind-key "C-x d" 'delete-whitespace-rectangle)
(bind-key "C-x F" 'set-fill-column)
(bind-key "C-x t" 'toggle-truncate-lines)

#+end_src


***** transpose windows
#+begin_src emacs-lisp
    (defun transpose-windows (arg)
      "Transpose the buffers shown in two windows."
      (interactive "p")
      (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
        (while (/= arg 0)
          (let ((this-win (window-buffer))
                (next-win (window-buffer (funcall selector))))
            (set-window-buffer (selected-window) next-win)
            (set-window-buffer (funcall selector) this-win)
            (select-window (funcall selector)))
          (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
    (bind-key "C-x 4 t" 'transpose-windows)
#+end_src

***** transparency

#+begin_src emacs-lisp
  (defun set-transparency-clear ()
    (set-frame-parameter nil 'alpha 100))
  
  (defun set-transparency (&optional alpha-level)
    (interactive "p")
    (let ((alpha-level
           (if (or (not alpha-level)
                   (< alpha-level 2))
               (read-number "Opacity percentage: " 85)
             alpha-level
             )))
      (set-frame-parameter nil 'alpha alpha-level))
    (message (format "Alpha level is %d" (frame-parameter nil 'alpha))))
    
  (defun emacs-toggle-transparency ()
    (interactive)
    (if (< (frame-parameter nil 'alpha) 100)
        (set-transparency-clear)
      (set-transparency)))
  
  (bind-key "C-x 5 t" 'emacs-toggle-transparency)
  
#+end_src

***** Frequently-accessed files
Registers allow you to jump to a file or other location quickly. To
jump to a register, use =C-x r j= followed by the letter of the
register.

#+begin_src emacs-lisp :results silent
  (dolist
      (r `((?d (file . "~/.emacs.d/dotemacs.org"))
           (?s (file . "~/.emacs.d/settings.el"))
           (?b (file . "~/stuff/org/bugz.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src

**** C-x C-?
#+begin_src emacs-lisp
;;;_  . C-x C-?

(defun duplicate-line ()
  "Duplicate the line containing point."
  (interactive)
  (save-excursion
    (let (line-text)
      (goto-char (line-beginning-position))
      (let ((beg (point)))
        (goto-char (line-end-position))
        (setq line-text (buffer-substring beg (point))))
      (if (eobp)
          (insert ?\n)
        (forward-line))
      (open-line 1)
      (insert line-text))))

(bind-key "C-x C-d" 'duplicate-line)
(bind-key "C-x C-e" 'pp-eval-last-sexp)
(bind-key "C-x C-k" 'kill-region)

(bind-key "C-x C-n" 'next-line)


(defun find-alternate-file-with-sudo (filename)
  (interactive
   (list (read-file-name "Find alternate file: " nil
                         nil nil (concat "/sudo::" (buffer-file-name)))))
  (find-alternate-file filename))

(bind-key "C-x C-v" 'find-alternate-file-with-sudo)

#+end_src
**** C-x M-?
#+begin_src emacs-lisp
;;;_  . C-x M-?

(bind-key "C-x M-n" 'set-goal-column)

(defun refill-paragraph (arg)
  (interactive "*P")
  (let ((fun (if (memq major-mode '(c-mode c++-mode))
                 'c-fill-paragraph
               (or fill-paragraph-function
                   'fill-paragraph)))
        (width (if (numberp arg) arg))
        prefix beg end)
    (forward-paragraph 1)
    (setq end (copy-marker (- (point) 2)))
    (forward-line -1)
    (let ((b (point)))
      (skip-chars-forward "^A-Za-z0-9`'\"(")
      (setq prefix (buffer-substring-no-properties b (point))))
    (backward-paragraph 1)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (delete-horizontal-space)
    (while (< (point) end)
      (delete-indentation 1)
      (end-of-line))
    (let ((fill-column (or width fill-column))
          (fill-prefix prefix))
      (if prefix
          (setq fill-column
                (- fill-column (* 2 (length prefix)))))
      (funcall fun nil)
      (goto-char beg)
      (insert prefix)
      (funcall fun nil))
    (goto-char (+ end 2))))

(bind-key "C-x M-q" 'refill-paragraph)

#+end_src
*** mode-specific-map
#+begin_src emacs-lisp
;;;_ , mode-specific-map

#+end_src
**** C-c ?
#+begin_src emacs-lisp
;;;_  . C-c ?

(bind-key "C-c <tab>" 'ff-find-other-file)
(bind-key* "C-c SPC" 'just-one-space)

;; inspired by Erik Naggum's `recursive-edit-with-single-window'
(defmacro recursive-edit-preserving-window-config (body)
  "*Return a command that enters a recursive edit after executing BODY.
 Upon exiting the recursive edit (with\\[exit-recursive-edit] (exit)
 or \\[abort-recursive-edit] (abort)), restore window configuration
 in current frame."
  `(lambda ()
     "See the documentation for `recursive-edit-preserving-window-config'."
     (interactive)
     (save-window-excursion
       ,body
       (recursive-edit))))

(bind-key "C-c 0"
  (recursive-edit-preserving-window-config (delete-window)))
(bind-key "C-c 1"
  (recursive-edit-preserving-window-config
   (if (one-window-p 'ignore-minibuffer)
       (error "Current window is the only window in its frame")
     (delete-other-windows))))

(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))

(bind-key "C-c d" 'delete-current-line)

(bind-key "C-c e E" 'elint-current-buffer)

(defun do-eval-buffer ()
  (interactive)
  (call-interactively 'eval-buffer)
  (message "Buffer has been evaluated"))

(bind-key "C-c e b" 'do-eval-buffer)
(bind-key "C-c e c" 'cancel-debug-on-entry)
(bind-key "C-c e d" 'debug-on-entry)
(bind-key "C-c e e" 'toggle-debug-on-error)
(bind-key "C-c e f" 'emacs-lisp-byte-compile-and-load)
(bind-key "C-c e j" 'emacs-lisp-mode)
(bind-key "C-c e l" 'find-library)
(bind-key "C-c e r" 'eval-region)
(bind-key "C-c e s" 'scratch)
(bind-key "C-c e v" 'edit-variable)

(defun find-which (name)
  (interactive "sCommand name: ")
  (find-file-other-window
   (substring (shell-command-to-string (format "which %s" name)) 0 -1)))

(bind-key "C-c e w" 'find-which)
(bind-key "C-c e z" 'byte-recompile-directory)

(bind-key "C-c f" 'flush-lines)
(bind-key "C-c g" 'goto-line)

(bind-key "C-c k" 'keep-lines)

(eval-when-compile
  (defvar emacs-min-top)
  (defvar emacs-min-left)
  (defvar emacs-min-height)
  (defvar emacs-min-width))

(unless noninteractive
  (if running-alternate-emacs
      (progn
        (defvar emacs-min-top (if (= 1050 (x-display-pixel-height)) 574 722))
        (defvar emacs-min-left 5)
        (defvar emacs-min-height 25)
        (defvar emacs-min-width 80))

    (defvar emacs-min-top 22) ;;22)
    (defvar emacs-min-left 5) ;;(- (x-display-pixel-width) 918))
    (defvar emacs-min-height 53) ;;(if (= 1050 (x-display-pixel-height)) 55 64))
    (defvar emacs-min-width 80)))

(defun emacs-min ()
  (interactive)
  (set-frame-parameter (selected-frame) 'fullscreen nil)
  (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'top emacs-min-top)
  (set-frame-parameter (selected-frame) 'left emacs-min-left)
  (set-frame-parameter (selected-frame) 'height emacs-min-height)
  (set-frame-parameter (selected-frame) 'width emacs-min-width)

  (when running-alternate-emacs
    (set-background-color "grey85")
    (set-face-background 'fringe "gray80")))

(if window-system
    (add-hook 'after-init-hook 'emacs-min))

(defun emacs-max ()
  (interactive)
  (if t
      (progn
        (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
    (set-frame-parameter (selected-frame) 'top 26)
    (set-frame-parameter (selected-frame) 'left 2)
    (set-frame-parameter (selected-frame) 'width
                         (floor (/ (float (x-display-pixel-width)) 9.15)))
    (if (= 1050 (x-display-pixel-height))
        (set-frame-parameter (selected-frame) 'height
                             (if (>= emacs-major-version 24)
                                 66
                               55))
      (set-frame-parameter (selected-frame) 'height
                           (if (>= emacs-major-version 24)
                               75
                             64)))))

(defun emacs-toggle-size ()
  (interactive)
  (if (> (cdr (assq 'width (frame-parameters))) 100)
      (emacs-min)
    (emacs-max)))

(bind-key "C-c m" 'emacs-toggle-size)

(defun insert-date ()
  (interactive)
  (insert (format-time-string "%Y-%m-%d")))

(defcustom user-initials nil
  "*Initials of this user."
  :set
  #'(lambda (symbol value)
      (if (fboundp 'font-lock-add-keywords)
          (mapc
           #'(lambda (mode)
               (font-lock-add-keywords
                mode (list (list (concat "\\<\\(" value " [^:\n]+\\):")
                                 1 font-lock-warning-face t))))
           '(c-mode c++-mode emacs-lisp-mode lisp-mode
                    python-mode perl-mode java-mode groovy-mode
                    haskell-mode literate-haskell-mode)))
      (set symbol value))
  :type 'string
  :group 'mail)

(defun insert-user-timestamp ()
  "Insert a quick timestamp using the value of `user-initials'."
  (interactive)
  (insert (format "%s (%s): " user-initials
                  (format-time-string "%Y-%m-%d" (current-time)))))

(bind-key "C-c n" 'insert-user-timestamp)
(bind-key "C-c o" 'customize-option)
(bind-key "C-c O" 'customize-group)

(bind-key "C-c q" 'fill-region)
(bind-key "C-c r" 'replace-regexp)
(bind-key "C-c s" 'replace-string)
(bind-key "C-c u" 'rename-uniquely)

(autoload 'auth-source-search "auth-source")

(defun tinify-url (url)
  (interactive "sURL to shorten: ")
  (let* ((api-login "tonyday567")
         (api-key
          (funcall
           (plist-get
            (car (auth-source-search :host "api.j.mp" :login api-login
                                     :port 80))
            :secret))))
    (cl-flet ((message (&rest ignore)))
      (with-current-buffer
          (let ((query
                 (format "format=txt&longUrl=%s&login=%s&apiKey=%s"
                         (url-hexify-string url) api-login api-key)))
            (url-retrieve-synchronously
             (concat "http://api.j.mp/v3/shorten?" query)))
        (goto-char (point-min))
        (re-search-forward "^$")
        (prog1
            (kill-new (buffer-substring (1+ (point)) (1- (point-max))))
          (kill-buffer (current-buffer)))))))

(bind-key "C-c U" 'tinify-url)

(defun view-clipboard ()
  (interactive)
  (delete-other-windows)
  (switch-to-buffer "*Clipboard*")
  (let ((inhibit-read-only t))
    (erase-buffer)
    (clipboard-yank)
    (goto-char (point-min))
    (html-mode)
    (view-mode)))

(bind-key "C-c V" 'view-clipboard)
(bind-key "C-c z" 'clean-buffer-list)

(bind-key "C-c [" 'align-regexp)
(bind-key "C-c =" 'count-matches)
(bind-key "C-c ;" 'comment-or-uncomment-region)

(defvar ctl-c-t-map)
(define-prefix-command 'ctl-c-t-map)
(bind-key "C-c t" 'ctl-c-t-map)

#+end_src

**** C-c C-?
#+begin_src emacs-lisp
;;;_  . C-c C-?

(defun delete-to-end-of-buffer ()
  (interactive)
  (kill-region (point) (point-max)))

(bind-key "C-c C-z" 'delete-to-end-of-buffer)

#+end_src
**** C-c M-?
#+begin_src emacs-lisp
;;;_  . C-c M-?

(defun unfill-paragraph (arg)
  (interactive "*p")
  (let (beg end)
    (forward-paragraph arg)
    (setq end (copy-marker (- (point) 2)))
    (backward-paragraph arg)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (when (> (count-lines beg end) 1)
      (while (< (point) end)
        (goto-char (line-end-position))
        (let ((sent-end (memq (char-before) '(?. ?\; ?! ??))))
          (delete-indentation 1)
          (if sent-end
              (insert ? )))
        (end-of-line))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "[^.;!?:]\\([ \t][ \t]+\\)" end t)
          (replace-match " " nil nil nil 1))))))

(bind-key "C-c M-q" 'unfill-paragraph)

(defun unfill-region (beg end)
  (interactive "r")
  (setq end (copy-marker end))
  (save-excursion
    (goto-char beg)
    (while (< (point) end)
      (unfill-paragraph 1)
      (forward-paragraph))))

#+end_src
*** ctl-period-map
#+begin_src emacs-lisp
;;;_ , ctl-period-map

#+end_src
**** C-. ?
#+begin_src emacs-lisp
;;;_  . C-. ?

(bind-key "C-. m" 'kmacro-keymap)

  (defun check-html5 ()
    (interactive)
    (save-buffer)
    (shell-command (concat "html5check.py " (shell-quote-argument (buffer-file-name)))))

(bind-key "C-. h" 'check-html5)


#+end_src

#+results:
: check-html5

**** C-. C-i
#+begin_src emacs-lisp
;;;_  . C-. C-i

(bind-key "C-. C-i" 'indent-rigidly)

#+end_src
**** C-. C-c
#+begin_src emacs-lisp
(bind-key "C-. C-c" 'org-indent-indent-buffer)
#+end_src

**** C-. C-.
#+begin_src emacs-lisp
(defvar ctl-period-ctl-period-map)
(define-prefix-command 'ctl-period-ctl-period-map)
(bind-key "C-. C-." 'ctl-period-ctl-period-map)

(bind-key "C-. C-. d" 'describe-personal-keybindings)
(bind-key "C-. C-. n" 'next-buffer)
(bind-key "C-. C-. p" 'previous-buffer)
(bind-key "C-. C-. k" 'keyfreq-show)
(bind-key "C-. C-. b" 'bury-buffer)
(bind-key "C-. C-. r" 'recentf-open-files)
(defun my-face-at-point ()
(interactive)
(setq t1 (face-at-point))
(print t1)
)
(bind-key "C-. C-. f" 'my-face-at-point)

#+end_src

*** help-map
#+begin_src emacs-lisp
;;;_ , help-map

(defvar lisp-find-map)
(define-prefix-command 'lisp-find-map)

(bind-key "C-h e" 'lisp-find-map)

#+end_src

**** C-h e ?
#+begin_src emacs-lisp
;;;_  . C-h e ?

(bind-key "C-h e c" 'finder-commentary)
(bind-key "C-h e e" 'view-echo-area-messages)
(bind-key "C-h e f" 'find-function)
(bind-key "C-h e F" 'find-face-definition)

(defun my-describe-symbol  (symbol &optional mode)
  (interactive
   (info-lookup-interactive-arguments 'symbol current-prefix-arg))
  (let (info-buf find-buf desc-buf cust-buf)
    (save-window-excursion
      (ignore-errors
        (info-lookup-symbol symbol mode)
        (setq info-buf (get-buffer "*info*")))
      (let ((sym (intern-soft symbol)))
        (when sym
          (if (functionp sym)
              (progn
                (find-function sym)
                (setq find-buf (current-buffer))
                (describe-function sym)
                (setq desc-buf (get-buffer "*Help*")))
            (find-variable sym)
            (setq find-buf (current-buffer))
            (describe-variable sym)
            (setq desc-buf (get-buffer "*Help*"))
            ;;(customize-variable sym)
            ;;(setq cust-buf (current-buffer))
            ))))

    (delete-other-windows)

    (cl-flet ((switch-in-other-buffer
            (buf)
            (when buf
              (split-window-vertically)
              (switch-to-buffer-other-window buf))))
      (switch-to-buffer find-buf)
      (switch-in-other-buffer desc-buf)
      (switch-in-other-buffer info-buf)
      ;;(switch-in-other-buffer cust-buf)
      (balance-windows))))

(bind-key "C-h e d" 'my-describe-symbol)
(bind-key "C-h e i" 'info-apropos)
(bind-key "C-h e k" 'find-function-on-key)
(bind-key "C-h e l" 'find-library)

(defvar lisp-modes  '(emacs-lisp-mode
                      inferior-emacs-lisp-mode
                      ielm-mode
                      lisp-mode
                      inferior-lisp-mode
                      lisp-interaction-mode
                      slime-repl-mode))

(defvar lisp-mode-hooks
  (mapcar (function
           (lambda (mode)
             (intern
              (concat (symbol-name mode) "-hook"))))
          lisp-modes))

(defun scratch ()
  (interactive)
  (let ((current-mode major-mode))
    (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
    (goto-char (point-min))
    (when (looking-at ";")
      (forward-line 4)
      (delete-region (point-min) (point)))
    (goto-char (point-max))
    (if (memq current-mode lisp-modes)
        (funcall current-mode))))

(bind-key "C-h e s" 'scratch)
(bind-key "C-h e v" 'find-variable)
(bind-key "C-h e V" 'apropos-value)

#+end_src


*** hyper key
I set this in customization

(setq ns-function-modifier 'hyper)

**** H-?
#+begin_src emacs-lisp
(defun my-indent-region ()
  (interactive)
  (save-excursion
    (save-restriction
      (if (> (point) (mark))
          (exchange-point-and-mark))
      (while (< (point) (mark))
        (indent-for-tab-command)
        (forward-line 1)))))

(bind-key "H-i" 'my-indent-region)

#+end_src


* packages
:PROPERTIES:
:tangle:   no
:END:

*** abbrev
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , abbrev

(use-package abbrev
  :commands abbrev-mode
  :diminish abbrev-mode
  :init
  (hook-into-modes #'abbrev-mode '(text-mode-hook))

  :config
  (progn
   (if (file-exists-p abbrev-file-name)
       (quietly-read-abbrev-file))

   (add-hook 'expand-load-hook
             (lambda ()
               (add-hook 'expand-expand-hook 'indent-according-to-mode)
               (add-hook 'expand-jump-hook 'indent-according-to-mode)))))

#+end_src
*** ace-jump-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ace-jump-mode

(use-package ace-jump-mode
  :bind ("C-. C-s" . ace-jump-mode))

#+end_src
*** allout
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , allout

(use-package allout
  :diminish allout-mode
  :commands allout-mode
  :config
  (progn
    (defvar allout-unprefixed-keybindings nil)

    (defun my-allout-mode-hook ()
      (dolist (mapping '((?b . allout-hide-bodies)
                         (?c . allout-hide-current-entry)
                         (?l . allout-hide-current-leaves)
                         (?i . allout-show-current-branches)
                         (?e . allout-show-entry)
                         (?o . allout-show-to-offshoot)))
        (bind-key (concat (format-kbd-macro allout-command-prefix)
                          " " (char-to-string (car mapping)))
                  (cdr mapping)
                  allout-mode-map))

      (if (memq major-mode lisp-modes)
          (unbind-key "C-k" allout-mode-map)))

    (add-hook 'allout-mode-hook 'my-allout-mode-hook)))

#+end_src
*** ascii
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ascii

(use-package ascii
  :commands (ascii-on ascii-toggle)
  :init
  (progn
    (defun ascii-toggle ()
      (interactive)
      (if ascii-display
          (ascii-off)
        (ascii-on)))

    (bind-key "C-c e A" 'ascii-toggle)))

#+end_src
*** archive-region
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , archive-region

(use-package archive-region
  :commands kill-region-or-archive-region
  :bind ("C-w" . kill-region-or-archive-region))

#+end_src
*** artbollocks
:PROPERTIES:
:tangle:   yes
:END:
    #+begin_src emacs-lisp
      (use-package artbollocks-mode
        :init
        (progn
          (setq artbollocks-weasel-words-regex
                (concat "\\b" (regexp-opt
                               '("one of the"
                                 "should"
                                 "just"
                                 "sort of"
                                 "a lot"
                                 "probably"
                                 "maybe"
                                 "perhaps"
                                 "I think"
                                 "really"
                                 "pretty"
                                 "maybe"
                                 "nice"
                                 "action"
                                 "utilize"
                                 "leverage") t) "\\b"))
          ;; Don't show the art critic words, or at least until I figure
          ;; out my own jargon
          (setq artbollocks-jargon nil)))
#+end_src

    #+results:
    : t

*** auctex
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  ;;;_ , auctex
  
  (use-package tex-site
    :load-path "/Users/tonyday/.emacs.d/site-lisp/auctex/"
    :defines (latex-help-cmd-alist
              latex-help-file)
    ;; jww (2012-06-15): Do I want to use AucTeX for texinfo-mode?
    :mode ("\\.tex\\'" . latex-mode)
    :config
    (progn
      (defun latex-help-get-cmd-alist () ;corrected version:
        "Scoop up the commands in the index of the latex info manual.
     The values are saved in `latex-help-cmd-alist' for speed."
        ;; mm, does it contain any cached entries
        (if (not (assoc "\\begin" latex-help-cmd-alist))
            (save-window-excursion
              (setq latex-help-cmd-alist nil)
              (Info-goto-node (concat latex-help-file "Command Index"))
              (goto-char (point-max))
              (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
                (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                      (value (buffer-substring (match-beginning 2)
                                               (match-end 2))))
                  (add-to-list 'latex-help-cmd-alist (cons key value))))))
        latex-help-cmd-alist)
  
      (use-package latex-mode
        :config
        (info-lookup-add-help :mode 'latex-mode
                              :regexp ".*"
                              :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                              :doc-spec '(("(latex2e)Concept Index" )
                                          ("(latex2e)Command Index"))))
  
  
    (use-package org-latex)
  (add-to-list 
   'org-export-latex-classes
   '("scarce-org-article"
     "\\documentclass[12pt]{article}
      % miscellaneous and unknown uses
      \\usepackage{amssymb}
      \\usepackage{graphicx}
      \\usepackage{hyperref} 
      \\usepackage[parfill]{parskip}
      \\usepackage{paralist}
  
      % font specifications
      \\usepackage[T1]{fontenc}
      \\usepackage{fontspec,xunicode}
      \\defaultfontfeatures{Mapping=tex-text} 
      \\setromanfont[Mapping=tex-text]{Droid Sans} 
      \\setsansfont[Scale=MatchLowercase,Mapping=tex-text]{Droid Serif} 
      \\setmonofont[Scale=MatchLowercase]{Droid Sans Mono}
  
      % geometry
      \\usepackage{geometry}
      \\geometry{a4paper, textwidth=6.5in, textheight=10in,
      marginparsep=7pt, marginparwidth=.6in}
      \\pagestyle{empty}
      \\title{}
  
      % color
      \\usepackage{color}
      %\\definecolor{greytext}{rgb}{0.6,0.6,0.6}
      %\\definecolor{greyline}{rgb}{0.8,0.8,0.8}
      \\definecolor{greytext}{gray}{0.3}
      \\definecolor{greyline}{gray}{0.8}
      
      \\renewcommand{\\labelitemi}{
      \\color{greytext}\\scalebox{1}{$-$}}

      % custom maketitle
      \\makeatletter
      \\renewcommand{\\@maketitle}{
      \\null
      \\vskip 0em%
      \\begin{flushleft}%
      {\\fontfamily{\\sfdefault}\\selectfont 
      {\\LARGE \\@title \\par}%
      \\vskip 1em
      {\\@date \\par}
      }
      \\end{flushleft}%
      \\par} 
      \\makeatother

      % style
      \\usepackage{enumitem}
      \\setitemize[0]{leftmargin=*}
      % \\usepackage[none]{hyphenat}%%%%
      % \\usepackage[document]{ragged2e}

      \\usepackage{transparent}
      
      % a fancy header
      \\usepackage{fancyhdr}
      %\\renewcommand{\\headheight}{0.6in}
      \\setlength{\\headheight}{1.6cm}
      \\setlength{\\headwidth}{\\textwidth}
      \\renewcommand{\\headrulewidth}{2pt}
      \\renewcommand{\\headrule}{\\hbox to\\headwidth{%
      \\color{greyline}\\leaders\\hrule height \\headrulewidth\\hfill}}

      \\fancypagestyle{plain}{
      \\fancyhead[R]{}% empty left
      \\fancyhead[L]{ % right
      \\includegraphics[height=1cm]{logo-grey.pdf}
      }
      \\fancyfoot[C]{}
      %\\fancyhf{}
      }

      % end spec lines.  The rest is org generated
  
      [NO-DEFAULT-PACKAGES]
      [NO-PACKAGES]"
     (" \\section{%s}" . "\\section*{%s}")
     (" \\subsection{%s}" . "\\subsection*{%s}")
     (" \\subsubsection{%s}" . "\\subsubsection*{%s}")
     (" \\paragraph{%s}" . "\\paragraph*{%s}")
     (" \\subparagraph{%s}" . "\\subparagraph*{%s}")))
(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)))
  
#+end_src

#+results:
: t

**** NEXT tex development
:LOGBOOK:
CLOCK: [2013-02-24 Sun 21:13]--[2013-02-25 Mon 16:57] => 19:44
:END:
:PROPERTIES:
:tangle:   no
:END:
Some random old-school instructions

- best config
  - auctex-autoloads???
  - tex-site???
  - fix bug
  - reload helm


#+begin_src emacs-lisp
  (load "auctex.el" nil t t)
  (load "preview-latex.el" nil t t)
#+end_src

This gives you latex-mode
#+begin_src emacs-lisp
 (use-package latex)
  (use-package preview)
(use-package auctex-autoloads)
(use-package url)
#+end_src



*** auto-complete
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
    ;;;_ , auto-complete
    
    (use-package auto-complete-config
      :commands auto-complete-mode
      :diminish auto-complete-mode
      :config
      (progn
        (ac-set-trigger-key "TAB")
        (setq ac-use-menu-map t)
    
        (unbind-key "C-s" ac-completing-map))
      :load-path ("repos/jwiegley/site-lisp/ac/auto-complete/"
                  "repos/jwiegley/site-lisp/ac/"))
    
#+end_src
*** autorevert
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
(use-package autorevert
:init (global-auto-revert-mode t))
#+end_src

*** autopair
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , autopair

(use-package autopair
  :disabled t
  :commands autopair-mode
  :diminish autopair-mode
  :init
  (hook-into-modes #'autopair-mode '(c-mode-common-hook
                                     text-mode-hook
                                     ruby-mode-hook
                                     python-mode-hook
                                     sh-mode-hook)))

#+end_src
*** autorevert
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , autorevert

(use-package autorevert
  :commands auto-revert-mode
  :diminish auto-revert-mode
  :init
  (add-hook 'find-file-hook
            #'(lambda ()
                (auto-revert-mode 1))))

#+end_src
*** backup-each-save
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , backup-each-save

(use-package backup-each-save
  :defer t
  :init
  (progn
    (autoload 'backup-each-save "backup-each-save")
    (add-hook 'after-save-hook 'backup-each-save)

    (defun my-make-backup-file-name (file)
      (make-backup-file-name-1 (file-truename file)))

    (defun show-backups ()
      (interactive)
      (require 'find-dired)
      (let* ((file (make-backup-file-name (buffer-file-name)))
             (dir (file-name-directory file))
             (args (concat "-iname '" (file-name-nondirectory file)
                           ".~*~'"))
             (dired-buffers dired-buffers)
             (find-ls-option '("-print0 | xargs -0 ls -lta" . "-lta")))
        ;; Check that it's really a directory.
        (or (file-directory-p dir)
            (error "Backup directory does not exist: %s" dir))
        (with-current-buffer (get-buffer-create "*Backups*")
          (let ((find (get-buffer-process (current-buffer))))
            (when find
              (if (or (not (eq (process-status find) 'run))
                      (yes-or-no-p "A `find' process is running; kill it? "))
                  (condition-case nil
                      (progn
                        (interrupt-process find)
                        (sit-for 1)
                        (delete-process find))
                    (error nil))
                (error "Cannot have two processes in `%s' at once"
                       (buffer-name)))))

          (widen)
          (kill-all-local-variables)
          (setq buffer-read-only nil)
          (erase-buffer)
          (setq default-directory dir
                args (concat find-program " . "
                             (if (string= args "")
                                 ""
                               (concat
                                (shell-quote-argument "(")
                                " " args " "
                                (shell-quote-argument ")")
                                " "))
                             (if (string-match "\\`\\(.*\\) {} \\(\\\\;\\|+\\)\\'"
                                               (car find-ls-option))
                                 (format "%s %s %s"
                                         (match-string 1 (car find-ls-option))
                                         (shell-quote-argument "{}")
                                         find-exec-terminator)
                               (car find-ls-option))))
          ;; Start the find process.
          (message "Looking for backup files...")
          (shell-command (concat args "&") (current-buffer))
          ;; The next statement will bomb in classic dired (no optional arg
          ;; allowed)
          (dired-mode dir (cdr find-ls-option))
          (let ((map (make-sparse-keymap)))
            (set-keymap-parent map (current-local-map))
            (define-key map "\C-c\C-k" 'kill-find)
            (use-local-map map))
          (make-local-variable 'dired-sort-inhibit)
          (setq dired-sort-inhibit t)
          (set (make-local-variable 'revert-buffer-function)
               `(lambda (ignore-auto noconfirm)
                  (find-dired ,dir ,find-args)))
          ;; Set subdir-alist so that Tree Dired will work:
          (if (fboundp 'dired-simple-subdir-alist)
              ;; will work even with nested dired format (dired-nstd.el,v 1.15
              ;; and later)
              (dired-simple-subdir-alist)
            ;; else we have an ancient tree dired (or classic dired, where
            ;; this does no harm)
            (set (make-local-variable 'dired-subdir-alist)
                 (list (cons default-directory (point-min-marker)))))
          (set (make-local-variable 'dired-subdir-switches) find-ls-subdir-switches)
          (setq buffer-read-only nil)
          ;; Subdir headlerline must come first because the first marker in
          ;; subdir-alist points there.
          (insert "  " dir ":\n")
          ;; Make second line a ``find'' line in analogy to the ``total'' or
          ;; ``wildcard'' line.
          (insert "  " args "\n")
          (setq buffer-read-only t)
          (let ((proc (get-buffer-process (current-buffer))))
            (set-process-filter proc (function find-dired-filter))
            (set-process-sentinel proc (function find-dired-sentinel))
            ;; Initialize the process marker; it is used by the filter.
            (move-marker (process-mark proc) 1 (current-buffer)))
          (setq mode-line-process '(":%s")))))

    (bind-key "C-x ~" 'show-backups))

  :config
  (progn
    (defun backup-each-save-filter (filename)
      (not (string-match
            (concat "\\(^/tmp\\|\\.emacs\\.d/data\\(-alt\\)?/"
                    "\\|\\.newsrc\\(\\.eld\\)?\\)")
            filename)))

    (setq backup-each-save-filter-function 'backup-each-save-filter)

    (defun my-dont-backup-files-p (filename)
      (unless (string-match filename "/\\(archive/sent/\\|recentf$\\)")
        (normal-backup-enable-predicate filename)))

    (setq backup-enable-predicate 'my-dont-backup-files-p)))

#+end_src
*** bbdb
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
;;;_ , bbdb

(use-package bbdb-com
  :commands bbdb-create
  :bind ("M-B" . bbdb)
  :disabled t
  :config (progn
(use-package vcard
  :load-path "~/.emacs.d/site-lisp/gnus/contrib")
(use-package bbdb-vcard-import
  :commands bbdb-vcard-import )
(use-package bbdb-vcard-export
  :commands bbdb-vcard-export-update-all)))

#+end_src

*** bm
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , bm

(use-package bm
  :pre-init
  (progn
    (defvar ctl-period-breadcrumb-map)
    (define-prefix-command 'ctl-period-breadcrumb-map)
    (bind-key "C-. c" 'ctl-period-breadcrumb-map))

  :bind (("C-. c b" . bm-last-in-previous-buffer)
         ("C-. c f" . bm-first-in-next-buffer)
         ("C-. c g" . bm-previous)
         ("C-. c l" . bm-show-all)
         ("C-. c c" . bm-toggle)
         ("C-. c m" . bm-toggle)
         ("C-. c n" . bm-next)
         ("C-. c p" . bm-previous)))

#+end_src
*** bookmark
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , bookmark

(use-package bookmark
  :disabled t
  :defer t
  :config
  (progn
    (use-package bookmark+)

    (defun my-bookmark-set ()
      (interactive)
      (cl-flet ((bmkp-completing-read-lax
              (prompt &optional default alist pred hist)
              (completing-read prompt alist pred nil nil hist default)))
        (call-interactively #'bookmark-set)))

    (bind-key "C-x r m" 'my-bookmark-set)))

#+end_src
*** browse-kill-ring+
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , browse-kill-ring+

  (use-package browse-kill-ring+
    :init 
    (progn 
      (browse-kill-ring-default-keybindings)
      (setq browse-kill-ring-quit-action 'save-and-restore)))      

#+end_src

*** cc-mode dev
:PROPERTIES:
:tangle:   yes
:END:

Based on dwa version which is mostly ott.
- [ ] modify to use-package etc


#+begin_src emacs-lisp
  (use-package cedet-devel-load
    :defer t
    :load-path "~/site-lisp/cedet/contrib" 
    :config (progn
              (use-package semantic/bovine/el)
              (use-package semantic/canned-configs)
              (semantic-load-enable-gaudy-code-helpers)
              ;; Activate semantic
              (semantic-mode 1)
  
              (setq semantic-clang-binary "/usr/local/bin/clang")
              (use-package semantic/bovine/c)
              (use-package semantic/bovine/gcc)
              (use-package semantic/bovine/clang)
              (use-package semantic/ia)
              (use-package semantic/decorate/include)
              (use-package semantic/lex-spp)
              (use-package eassist)
              (use-package auto-complete)
  
  
              ;; semantic 
(defun my-cedet-hook ()
(bind-key "C-c ?" 'semantic-ia-complete-symbol (current-local-map))                                                               
(bind-key "C-c >" 'semantic-complete-analyze-inline (current-local-map))             
(bind-key "C-c =" 'semantic-decoration-include-visit (current-local-map))                                                           
(bind-key "C-c j" 'semantic-ia-fast-jump (current-local-map))                        
(bind-key "C-c q" 'semantic-ia-show-doc (current-local-map))                          
(bind-key "C-c s" 'semantic-ia-show-summary (current-local-map))                      
(bind-key "C-c p" 'semantic-analyze-proto-impl-toggle (current-local-map))            
                (add-to-list 'ac-sources 'ac-source-semantic))
                


  ;; (add-hook 'semantic-init-hooks 'alexott/cedet-hook)
  (add-hook 'c-mode-common-hook 'my-cedet-hook)
  (add-hook 'lisp-mode-hook 'my-cedet-hook)
  (add-hook 'scheme-mode-hook 'my-cedet-hook)
  (add-hook 'emacs-lisp-mode-hook 'my-cedet-hook)
  
  (defun my-c-mode-cedet-hook ()
   ;; (local-set-key "." 'semantic-complete-self-insert)
   ;; (local-set-key ">" 'semantic-complete-self-insert)
(bind-key "C-c t" 'eassist-switch-h-cpp (current-local-map))                                                               
(bind-key "C-x t" 'eassist-switch-h-cpp (current-local-map))                                                               
(bind-key "C-c e" 'eassist-list-methods (current-local-map))                                                               
(bind-key "C-c C-r" 'semantic-symref (current-local-map))                                                               
  
  ;;  (add-to-list 'ac-sources 'ac-source-etags)
    (add-to-list 'ac-sources 'ac-source-gtags)
    )
  (add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
  
  (use-package cedet-global)
  (when (cedet-gnu-global-version-check t)
    (semanticdb-enable-gnu-global-databases 'c-mode)
    (semanticdb-enable-gnu-global-databases 'c++-mode))
  
  (semanticdb-enable-cscope-databases :noerror)
  
  (ignore-errors 
    (when (cedet-ectag-version-check t)
      (semantic-load-enable-primary-ectags-support)))
  
  ;; SRecode
  (global-srecode-minor-mode 1)
  
  ;; EDE
  (global-ede-mode 1)
  (ede-enable-generic-projects)
    
  (defun recur-list-files (dir re)
    "Returns list of files in directory matching to given regex"
    (when (file-accessible-directory-p dir)
      (let ((files (directory-files dir t))
            matched)
        (dolist (file files matched)
          (let ((fname (file-name-nondirectory file)))
            (cond
             ((or (string= fname ".")
                  (string= fname "..")) nil)
             ((and (file-regular-p file)
                   (string-match re fname))
              (setq matched (cons file matched)))
             ((file-directory-p file)
              (let ((tfiles (recur-list-files file re)))
                (when tfiles (setq matched (append matched tfiles)))))))))))
  
  (defun c++-setup-boost (boost-root)
    (when (file-accessible-directory-p boost-root)
      (let ((cfiles (recur-list-files boost-root "\\(config\\|user\\)\\.hpp")))
        (dolist (file cfiles)
          (add-to-list 'semantic-lex-c-preprocessor-symbol-file file)))))
  
  
  
  ;; my functions for EDE
  (defun alexott/ede-get-local-var (fname var)
    "fetch given variable var from :local-variables of project of file fname"
    (let* ((current-dir (file-name-directory fname))
           (prj (ede-current-project current-dir)))
      (when prj
        (let* ((ov (oref prj local-variables))
              (lst (assoc var ov)))
          (when lst
            (cdr lst))))))
  
  ;; setup compile package
  (use-package compile)
  (setq compilation-disable-input nil)
  (setq compilation-scroll-output t)
  (setq mode-compile-always-save-buffer-p t)
  
  (defun alexott/compile ()
    "Saves all unsaved buffers, and runs 'compile'."
    (interactive)
    (save-some-buffers t)
    (let* ((r (alexott/ede-get-local-var
               (or (buffer-file-name (current-buffer)) default-directory)
               'compile-command))
           (cmd (if (functionp r) (funcall r) r)))
      (set (make-local-variable 'compile-command) (or cmd compile-command))
      (compile compile-command)))
  
  (defun alexott/gen-std-compile-string ()
    "Generates compile string for compiling CMake project in debug mode"
    (let* ((current-dir (file-name-directory
                         (or (buffer-file-name (current-buffer)) default-directory)))
           (prj (ede-current-project current-dir))
           (root-dir (ede-project-root-directory prj)))
      (concat "cd " root-dir "; make -j2")))
  
  (defun alexott/gen-cmake-debug-compile-string ()
    "Generates compile string for compiling CMake project in debug mode"
    (let* ((current-dir (file-name-directory
                         (or (buffer-file-name (current-buffer)) default-directory)))
           (prj (ede-current-project current-dir))
           (root-dir (ede-project-root-directory prj))
           (subdir "")
           )
      (when (string-match root-dir current-dir)
        (setf subdir (substring current-dir (match-end 0))))
      (concat "cd " root-dir "Debug/" "; make -j3")))
  
  (defun alexott/gen-cmake-debug/release-compile-string ()
    "Generates compile string for compiling CMake project in debug & release modes"
    (let* ((current-dir (file-name-directory
                         (or (buffer-file-name (current-buffer)) default-directory)))
           (prj (ede-current-project current-dir))
           (root-dir (ede-project-root-directory prj))
           (subdir "")
           )
      (when (string-match root-dir current-dir)
        (setf subdir (substring current-dir (match-end 0))))
      (concat "cd " root-dir "Debug/ && make -j3 && cd " root-dir "Release/ && make -j3" )))
  
  ;; Projects
  (when (file-exists-p "~/projects/opoker/CMakeLists.txt")
  (setq opoker-project
  (ede-cpp-root-project "opoker"
                  :name "opoker rescue"
                  :file "~/projects/opoker/CMakeLists.txt"
                  :include-path '("/include"
                                  "../../gtest-1.5.0/include/gtest"
                                 )
                  :system-include-path '("/usr/include/c++/4.2.1"))))
(when (file-exists-p "~/projects/opoker/CMakeLists.txt")
  (setq iqtest-project
  (ede-cpp-root-project "iqtest"
                  :name "iqfeed initial test"
                  :file "~/projects/iqfeed/CMakeLists.txt"
                  :include-path '("/include"
                                 )
                  :system-include-path '("/usr/include/c++/4.2.1"))))
))
  
  
  
#+end_src

#+results:
: t

*** cc-mode
:PROPERTIES:
:tangle:   no
:END:

Based on dwa version which is mostly ott.

#+begin_src emacs-lisp
  (load-file "~/.emacs.d/site-lisp/cedet/cedet-devel-load.el")

  (require 'find-func)
(let ((cedet-lisp (file-name-directory (find-library-name "cedet"))))
  (add-to-list 'load-path (expand-file-name "../../contrib" cedet-lisp))
;  (add-to-list 'load-path (expand-file-name "srecode" cedet-lisp))
;  (add-to-list 'load-path (expand-file-name "semantic" cedet-lisp))
)

;;(add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
(add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
;(add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
(add-to-list 'semantic-default-submodes 'global-cedet-m3-minor-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
;;(add-to-list 'semantic-default-submodes 'global-semantic-show-unmatched-syntax-mode)
;;(add-to-list 'semantic-default-submodes 'global-semantic-highlight-edits-mode)
;;(add-to-list 'semantic-default-submodes 'global-semantic-show-parser-state-mode)
;;(add-to-list 'semantic-default-submodes ')

(require 'semantic/bovine/el)
(require 'semantic/canned-configs)
(semantic-load-enable-gaudy-code-helpers)
;; dwa
; (semantic-load-enable-excessive-code-helpers)

;; Activate semantic
(semantic-mode 1)

(setq semantic-clang-binary "/usr/local/bin/clang")
(require 'semantic/bovine/c)
(require 'semantic/bovine/gcc)
(require 'semantic/bovine/clang)
(require 'semantic/ia)
(require 'semantic/decorate/include)
(require 'semantic/lex-spp)
(require 'eassist)
(require 'auto-complete)


;; customisation of modes
(defun alexott/cedet-hook ()
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol)
  ;;
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-c=" 'semantic-decoration-include-visit)

  (local-set-key "\C-cj" 'semantic-ia-fast-jump)
  (local-set-key "\C-cq" 'semantic-ia-show-doc)
  (local-set-key "\C-cs" 'semantic-ia-show-summary)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle)
  (local-set-key (kbd "C-c <left>") 'semantic-tag-folding-fold-block)
  (local-set-key (kbd "C-c <right>") 'semantic-tag-folding-show-block)

  (add-to-list 'ac-sources 'ac-source-semantic)
  )
;; (add-hook 'semantic-init-hooks 'alexott/cedet-hook)
(add-hook 'c-mode-common-hook 'alexott/cedet-hook)
(add-hook 'lisp-mode-hook 'alexott/cedet-hook)
(add-hook 'scheme-mode-hook 'alexott/cedet-hook)
(add-hook 'emacs-lisp-mode-hook 'alexott/cedet-hook)
(add-hook 'erlang-mode-hook 'alexott/cedet-hook)

(defun alexott/c-mode-cedet-hook ()
 ;; (local-set-key "." 'semantic-complete-self-insert)
 ;; (local-set-key ">" 'semantic-complete-self-insert)
  (local-set-key "\C-ct" 'eassist-switch-h-cpp)
  (local-set-key "\C-xt" 'eassist-switch-h-cpp)
  (local-set-key "\C-ce" 'eassist-list-methods)
  (local-set-key "\C-c\C-r" 'semantic-symref)

;;  (add-to-list 'ac-sources 'ac-source-etags)
  (add-to-list 'ac-sources 'ac-source-gtags)
  )
(add-hook 'c-mode-common-hook 'alexott/c-mode-cedet-hook)

(require 'cedet-global)
(when (cedet-gnu-global-version-check t)
  (semanticdb-enable-gnu-global-databases 'c-mode)
  (semanticdb-enable-gnu-global-databases 'c++-mode))

(semanticdb-enable-cscope-databases :noerror)

(ignore-errors 
  (when (cedet-ectag-version-check t)
    (semantic-load-enable-primary-ectags-support)))

;; SRecode
(global-srecode-minor-mode 1)

;; EDE
(global-ede-mode 1)
(ede-enable-generic-projects)

;;; Correct the handling of generic cmake projects in  upstream EDE
;;;
;;; CMAKE
;; (defclass ede-generic-cmake-project (ede-generic-project)
;;   ((buildfile :initform "CMakeLists.txt")
;;    )
;;   "Generic Project for cmake.")

;; (defmethod ede-generic-setup-configuration ((proj ede-generic-cmake-project) config)
;;   "Setup a configuration for CMake."
;;   (oset config build-command "cmake")
;;   (oset config debug-command "gdb ")
;;   )

;; (ede-generic-new-autoloader "generic-cmake" "CMake"
;;                             "CMakeLists.txt" 'ede-generic-cmake-project)
;;;


(defun recur-list-files (dir re)
  "Returns list of files in directory matching to given regex"
  (when (file-accessible-directory-p dir)
    (let ((files (directory-files dir t))
          matched)
      (dolist (file files matched)
        (let ((fname (file-name-nondirectory file)))
          (cond
           ((or (string= fname ".")
                (string= fname "..")) nil)
           ((and (file-regular-p file)
                 (string-match re fname))
            (setq matched (cons file matched)))
           ((file-directory-p file)
            (let ((tfiles (recur-list-files file re)))
              (when tfiles (setq matched (append matched tfiles)))))))))))

(defun c++-setup-boost (boost-root)
  (when (file-accessible-directory-p boost-root)
    (let ((cfiles (recur-list-files boost-root "\\(config\\|user\\)\\.hpp")))
      (dolist (file cfiles)
        (add-to-list 'semantic-lex-c-preprocessor-symbol-file file)))))



;; my functions for EDE
(defun alexott/ede-get-local-var (fname var)
  "fetch given variable var from :local-variables of project of file fname"
  (let* ((current-dir (file-name-directory fname))
         (prj (ede-current-project current-dir)))
    (when prj
      (let* ((ov (oref prj local-variables))
            (lst (assoc var ov)))
        (when lst
          (cdr lst))))))

;; setup compile package
(require 'compile)
(setq compilation-disable-input nil)
(setq compilation-scroll-output t)
(setq mode-compile-always-save-buffer-p t)

(defun alexott/compile ()
  "Saves all unsaved buffers, and runs 'compile'."
  (interactive)
  (save-some-buffers t)
  (let* ((r (alexott/ede-get-local-var
             (or (buffer-file-name (current-buffer)) default-directory)
             'compile-command))
         (cmd (if (functionp r) (funcall r) r)))
    (set (make-local-variable 'compile-command) (or cmd compile-command))
    (compile compile-command)))

;;(global-set-key [f9] 'alexott/compile)

;;
(defun alexott/gen-std-compile-string ()
  "Generates compile string for compiling CMake project in debug mode"
  (let* ((current-dir (file-name-directory
                       (or (buffer-file-name (current-buffer)) default-directory)))
         (prj (ede-current-project current-dir))
         (root-dir (ede-project-root-directory prj)))
    (concat "cd " root-dir "; make -j2")))

;;
(defun alexott/gen-cmake-debug-compile-string ()
  "Generates compile string for compiling CMake project in debug mode"
  (let* ((current-dir (file-name-directory
                       (or (buffer-file-name (current-buffer)) default-directory)))
         (prj (ede-current-project current-dir))
         (root-dir (ede-project-root-directory prj))
         (subdir "")
         )
    (when (string-match root-dir current-dir)
      (setf subdir (substring current-dir (match-end 0))))
    (concat "cd " root-dir "Debug/" "; make -j3")))

(defun alexott/gen-cmake-debug/release-compile-string ()
  "Generates compile string for compiling CMake project in debug & release modes"
  (let* ((current-dir (file-name-directory
                       (or (buffer-file-name (current-buffer)) default-directory)))
         (prj (ede-current-project current-dir))
         (root-dir (ede-project-root-directory prj))
         (subdir "")
         )
    (when (string-match root-dir current-dir)
      (setf subdir (substring current-dir (match-end 0))))
    (concat "cd " root-dir "Debug/ && make -j3 && cd " root-dir "Release/ && make -j3" )))

;; Projects
(when (file-exists-p "~/projects/opoker/CMakeLists.txt")
(setq opoker-project
(ede-cpp-root-project "opoker"
                :name "opoker rescue"
                :file "~/projects/opoker/CMakeLists.txt"
                :include-path '("/include"
                                "../../gtest-1.5.0/include/gtest"
                               )
                :system-include-path '("/usr/include/c++/4.2.1")
                ;;:spp-table '(("isUnix" . "")
                ;;             ("BOOST_TEST_DYN_LINK" . ""))
)))




(when (file-exists-p "~/src/LLVM/llvm/CMakeLists.txt")
  (setq llvm-project
	(ede-cpp-root-project "llvm"
			      :file "~/src/LLVM/llvm/CMakeLists.txt"
                              :include-path 
                              '(
                                "/include"
                                "/tools/clang/include"
                               )
			      :local-variables '((compile-command . 'alexott/gen-cmake-debug-compile-string)
						)
			      )))


(when (file-exists-p "~/src/corp/cree/CMakeLists.txt")
  (setq cree-project
	(ede-cpp-root-project "cree"
			      :file "~/src/corp/cree/CMakeLists.txt"
                              :include-path 
                              '("/src"
                                "/include"
                                "/lib"
                                "/lib_src"
                                "/ext/llvm/include"
                                "/ext/llvm/tools/clang/include"
                                "."
                               )
                              :spp-table '(("LLVM_DELETED_FUNCTION".""))
			      :local-variables '((compile-command . "cd ~/Products/cree && PATH=\"$HOME/Products/LLVM/cree/bin:$PATH\" cmake ~/src/corp/cree -G Ninja && ninja")
						)
			      ))
)

(when (file-exists-p "~/src/llvm/abi/CMakeLists.txt")
  (setq abi-project
	(ede-cpp-root-project "abi"
			      :file "~/src/llvm/abi/CMakeLists.txt"
                              :include-path 
                              '("/include"
                                "/tools/clang/include"
                                "."
                               )
                              :spp-table '(("LLVM_DELETED_FUNCTION".""))
			      :local-variables '((compile-command . "cd ~/Products/abi && cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ~/src/LLVM/abi -G Ninja && ninja")
						)
			      ))
)


;; cpp-tests project definition
(when (file-exists-p "~/projects/lang-exp/cpp/CMakeLists.txt")
  (setq cpp-tests-project
	(ede-cpp-root-project "cpp-tests"
			      :file "~/projects/lang-exp/cpp/CMakeLists.txt"
			      :system-include-path '("/home/ott/exp/include"
						     boost-base-directory)
			      :local-variables (list
						(cons 'compile-command 'alexott/gen-cmake-debug-compile-string)
						)
			      )))

(when (file-exists-p "~/projects/squid-gsb/README")
  (setq squid-gsb-project
	(ede-cpp-root-project "squid-gsb"
			      :file "~/projects/squid-gsb/README"
			      :system-include-path '("/home/ott/exp/include"
						     boost-base-directory)
			      :local-variables (list
						(cons 'compile-command 'alexott/gen-cmake-debug-compile-string)
						)
			      )))

;; (when (file-exists-p "~/work/emacs-head/README")
;;   (setq emacs-project
;; 	(ede-emacs-project "emacs-head"
;; 			   :file "~/work/emacs-head/README")))


;; (setq arabica-project
;;       (ede-cpp-root-project "arabica"
;;                             :file "~/projects/arabica-devel/README"
;;                             :system-include-path '("/home/ott/exp/include"
;;                                                    boost-base-directory)
;;                             :local-variables (list
;;                                               (cons 'compile-command 'alexott/gen-std-compile-string)
;;                                               )
;;                             ))

#+end_src

#+results:

*** TODO cedet dev
:LOGBOOK:
CLOCK: [2012-12-21 Fri 14:10]--[2012-12-22 Sat 14:07] => 23:57
:END:
:PROPERTIES:
:tangle:   no
:END:

- [ ] cedet
  [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][A Gentle introduction to CEDET]]
    - [ ] ede
        - [ ] understand what a project is and how to open it
    - [ ] semantic

      [[file:~/.emacs.d/repos/dwamacs/settings/semantic-settings.el::]]

- [ ] clang is a front end for llvm
    - [ ] [[file:~/.emacs.d/dotemacs.org::*llvm-mode][llvm-mode]]

- [-] [[file:~/.emacs.d/dotemacs.org::*cmake-mode][cmake-mode]]
    - [ ] get mode turning on automatically
    - [X] separate build and src
      [[http://stackoverflow.com/questions/2123669/configuring-emacs-for-cmake][configuring emacs for cmake - Stack Overflow]]
    - [X] cpputils-cmake
      [[https://github.com/redguardtoo/cpputils-cmake][redguardtoo/cpputils-cmake · GitHub]]

  #+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook (lambda ()
  (cppcm-reload-all)
  ; fixed rinari's bug.
  (remove-hook 'find-file-hook 'rinari-launch)
  ))
;; OPTIONAL, avoid typing full path when starting gdb
(global-set-key (kbd "H-g")
 '(lambda ()(interactive) (gud-gdb (concat "gdb --fullname " (cppcm-get-exe-path-current-buffer))))
)
  #+end_src


- [ ] [[file:~/.emacs.d/dotemacs.org::*compile][compile]]

- [ ] [[file:~/.emacs.d/dotemacs.org::*gtags][gtags]]

- [ ] gud

  [[file:~/.emacs.d/repos/jwiegley/override/gud.el::%3B%3B%3B%20gud.el%20---%20Grand%20Unified%20Debugger%20mode%20for%20running%20GDB%20and%20other%20debuggers][file:~/.emacs.d/repos/jwiegley/override/gud.el::;;; gud.el --- Grand Unified Debugger mode for running GDB and other debuggers]]

- [ ] hs-minor-mode
      (diminish 'hs-minor-mode)

- [ ] add a TAGS menu item
  #+begin_src emacs-lisp
  (defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
  (add-hook 'semantic-init-hooks 'my-semantic-hook)
  #+end_src

**** jwiegley cc-mode
:PROPERTIES:
:tangle:   no
:END:

- [ ] compare with dwa

#+begin_src emacs-lisp
  (use-package cc-mode
    :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
           ("\\.m\\'"                   . c-mode)
           ("\\.mm\\'"                  . c++-mode))
    :init
    (progn
      (defun llvm-info ()
        (interactive)
        (w3m-find-file "/usr/local/opt/clang/docs/llvm/html/doxygen/classllvm_1_1IRBuilder.html"))
      
      (defun my-paste-as-check ()
        (interactive)
        (save-excursion
          (insert "/*\n")
          (let ((beg (point)) end)
            (yank)
            (setq end (point-marker))
            (goto-char beg)
            (while (< (point) end)
              (forward-char 2)
              (insert "CHECK: ")
              (forward-line 1)))
          (insert "*/\n")))
      
      (defun my-c-indent-or-complete ()
        (interactive)
        (let ((class (syntax-class (syntax-after (1- (point))))))
          (if (or (bolp) (and (/= 2 class)
                              (/= 3 class)))
              (call-interactively 'indent-according-to-mode)
            (call-interactively 'auto-complete))))
      
      (defvar printf-index 0)
      
      (defun insert-counting-printf (arg)
        (interactive "P")
        (if arg
            (setq printf-index 0))
        (if t
            (insert (format "std::cerr << \"step %d..\" << std::endl;\n"
                            (setq printf-index (1+ printf-index))))
          (insert (format "printf(\"step %d..\\n\");\n"
                          (setq printf-index (1+ printf-index)))))
        (forward-line -1)
        (indent-according-to-mode)
        (forward-line))
      
      (defun my-c-save-buffer ()
        (interactive)
        (if (buffer-modified-p)
            (call-interactively 'save-buffer))
        (if flymake-mode
            (flymake-start-syntax-check)))
      
      (defun my-c-mode-common-hook ()
        (abbrev-mode 1)
        (gtags-mode 1)
        (hs-minor-mode 1)
        (hide-ifdef-mode 1)
        (whitespace-mode 1)
        (which-function-mode 1)
        (auto-complete-mode 1)
        (yas/minor-mode 1)
        
        (diminish 'gtags-mode)
        (diminish 'hs-minor-mode)
        (diminish 'hide-ifdef-mode)
        
        (add-to-list 'load-path "~/.emacs.d/site-lisp/ghc-mod/elisp")
        (require 'ghc-flymake)            ; jww (2012-09-19): hack!
        (bind-key "M-?" 'ghc-flymake-display-errors c-mode-base-map)
        (bind-key "M-p" 'flymake-goto-prev-error c-mode-base-map)
        (bind-key "M-n" 'flymake-goto-next-error c-mode-base-map)
        (bind-key "C-x C-s" 'my-c-save-buffer c-mode-base-map)
        
        (bind-key "C-c p" 'insert-counting-printf c-mode-base-map)
        
        (auto-complete-mode 1)
        (setq ac-sources (list (if (and (fboundp 'semantic-active-p)
                                        (funcall #'semantic-active-p))
                                   'ac-source-semantic
                                 'ac-source-gtags)))
        (bind-key "<A-tab>" 'ac-complete c-mode-base-map)
        
        ;;(doxymacs-mode 1)
        ;;(doxymacs-font-lock)
        
        (bind-key "<return>" 'newline-and-indent c-mode-base-map)
        
        (set (make-local-variable 'yas/fallback-behavior)
             '(apply my-c-indent-or-complete . nil))
        (bind-key "<tab>" 'yas/expand-from-trigger-key c-mode-base-map)
        
        (unbind-key "M-j" c-mode-base-map)
        (bind-key "C-c C-i" 'c-includes-current-file c-mode-base-map)
        (bind-key "C-c C-y" 'my-paste-as-check c-mode-base-map)
        
        (set (make-local-variable 'parens-require-spaces) nil)
        (setq indicate-empty-lines t)
        (setq fill-column 72)
        
        (bind-key "M-q" 'c-fill-paragraph c-mode-base-map)
        
        (let ((bufname (buffer-file-name)))
          (when bufname
            (cond
             ((string-match "/ledger/" bufname)
              (c-set-style "ledger"))
             ((string-match "/ansi/" bufname)
              (c-set-style "ti")
              (substitute-key-definition 'fill-paragraph 'ti-refill-comment
                                         c-mode-base-map global-map)
              (bind-key "M-q" 'ti-refill-comment c-mode-base-map))
             ((string-match "/edg/" bufname)
              (c-set-style "edg"))
             (t
              (c-set-style "clang")))))
        
        (font-lock-add-keywords 'c++-mode '(("\\<\\(assert\\|DEBUG\\)("
                                             1 font-lock-warning-face t))))
      
      (add-hook 'c-mode-common-hook 'my-c-mode-common-hook))
    
    :config
    (progn
      (setq c-syntactic-indentation nil)
      
      (bind-key "#" 'self-insert-command c-mode-base-map)
      (bind-key "{" 'self-insert-command c-mode-base-map)
      (bind-key "}" 'self-insert-command c-mode-base-map)
      (bind-key "/" 'self-insert-command c-mode-base-map)
      (bind-key "*" 'self-insert-command c-mode-base-map)
      (bind-key ";" 'self-insert-command c-mode-base-map)
      (bind-key "," 'self-insert-command c-mode-base-map)
      (bind-key ":" 'self-insert-command c-mode-base-map)
      (bind-key "(" 'self-insert-command c-mode-base-map)
      (bind-key ")" 'self-insert-command c-mode-base-map)
      (bind-key "<" 'self-insert-command c++-mode-map)
      (bind-key ">" 'self-insert-command c++-mode-map)
      
      (use-package cedet
        :disabled t
        :init
        (progn
          ;; Add further minor-modes to be enabled by semantic-mode.  See
          ;; doc-string of `semantic-default-submodes' for other things you can
          ;; use here.
          (dolist (submode '(global-semantic-idle-summary-mode
                             global-semantic-mru-bookmark-mode
                             global-semantic-idle-local-symbol-highlight-mode
                             global-semantic-show-unmatched-syntax-mode))
            (add-to-list 'semantic-default-submodes submode t))
          
          ;; Enable Semantic
          (semantic-mode 1)
          
          (when nil              ; jww (2012-06-20): this kills buffers
            ;; if you want to enable support for gnu global
            (use-package semanticdb-global)
            
            (semanticdb-enable-gnu-global-databases 'c-mode)
            (semanticdb-enable-gnu-global-databases 'c++-mode))))
      
      (add-to-list 'c-style-alist
                   '("ti"
                     (indent-tabs-mode . nil)
                     (c-basic-offset . 3)
                     (c-comment-only-line-offset . (0 . 0))
                     (c-hanging-braces-alist
                      . ((substatement-open before after)
                         (arglist-cont-nonempty)))
                     (c-offsets-alist
                      . ((statement-block-intro . +)
                         (knr-argdecl-intro . 5)
                         (substatement-open . 0)
                         (substatement-label . 0)
                         (label . 0)
                         (case-label . +)
                         (statement-case-open . 0)
                         (statement-cont . +)
                         (arglist-intro . c-lineup-arglist-intro-after-paren)
                         (arglist-close . c-lineup-arglist)
                         (inline-open . 0)
                         (brace-list-open . 0)
                         (topmost-intro-cont
                          . (first c-lineup-topmost-intro-cont
                                   c-lineup-gnu-DEFUN-intro-cont))))
                     (c-special-indent-hook . c-gnu-impose-minimum)
                     (c-block-comment-prefix . "")))
      
      (add-to-list 'c-style-alist
                   '("edg"
                     (indent-tabs-mode . nil)
                     (c-basic-offset . 2)
                     (c-comment-only-line-offset . (0 . 0))
                     (c-hanging-braces-alist
                      . ((substatement-open before after)
                         (arglist-cont-nonempty)))
                     (c-offsets-alist
                      . ((statement-block-intro . +)
                         (knr-argdecl-intro . 5)
                         (substatement-open . 0)
                         (substatement-label . 0)
                         (label . 0)
                         (case-label . +)
                         (statement-case-open . 0)
                         (statement-cont . +)
                         (arglist-intro . +)
                         (arglist-close . +)
                         (inline-open . 0)
                         (brace-list-open . 0)
                         (topmost-intro-cont
                          . (first c-lineup-topmost-intro-cont
                                   c-lineup-gnu-DEFUN-intro-cont))))
                     (c-special-indent-hook . c-gnu-impose-minimum)
                     (c-block-comment-prefix . "")))
      
      (add-to-list 'c-style-alist
                   '("ledger"
                     (indent-tabs-mode . nil)
                     (c-basic-offset . 2)
                     (c-comment-only-line-offset . (0 . 0))
                     (c-hanging-braces-alist
                      . ((substatement-open before after)
                         (arglist-cont-nonempty)))
                     (c-offsets-alist
                      . ((statement-block-intro . +)
                         (knr-argdecl-intro . 5)
                         (substatement-open . 0)
                         (substatement-label . 0)
                         (label . 0)
                         (case-label . 0)
                         (statement-case-open . 0)
                         (statement-cont . +)
                         (arglist-intro . +)
                         (arglist-close . +)
                         (inline-open . 0)
                         (brace-list-open . 0)
                         (topmost-intro-cont
                          . (first c-lineup-topmost-intro-cont
                                   c-lineup-gnu-DEFUN-intro-cont))))
                     (c-special-indent-hook . c-gnu-impose-minimum)
                     (c-block-comment-prefix . "")))
      
      (add-to-list 'c-style-alist
                   '("clang"
                     (indent-tabs-mode . nil)
                     (c-basic-offset . 2)
                     (c-comment-only-line-offset . (0 . 0))
                     (c-hanging-braces-alist
                      . ((substatement-open before after)
                         (arglist-cont-nonempty)))
                     (c-offsets-alist
                      . ((statement-block-intro . +)
                         (knr-argdecl-intro . 5)
                         (substatement-open . 0)
                         (substatement-label . 0)
                         (label . 0)
                         (case-label . 0)
                         (statement-case-open . 0)
                         (statement-cont . +)
                         (arglist-intro . +)
                         (arglist-close . +)
                         (inline-open . 0)
                         (brace-list-open . 0)
                         (topmost-intro-cont
                          . (first c-lineup-topmost-intro-cont
                                   c-lineup-gnu-DEFUN-intro-cont))))
                     (c-special-indent-hook . c-gnu-impose-minimum)
                     (c-block-comment-prefix . "")))
            
      (defun ti-refill-comment ()
        (interactive)
        (let ((here (point)))
          (goto-char (line-beginning-position))
          (let ((begin (point)) end
                (marker ?-) (marker-re "\\(-----\\|\\*\\*\\*\\*\\*\\)")
                (leader-width 0))
            (unless (looking-at "[ \t]*/\\*[-* ]")
              (search-backward "/*")
              (goto-char (line-beginning-position)))
            (unless (looking-at "[ \t]*/\\*[-* ]")
              (error "Not in a comment"))
            (while (and (looking-at "\\([ \t]*\\)/\\* ")
                        (setq leader-width (length (match-string 1)))
                        (not (looking-at (concat "[ \t]*/\\*" marker-re))))
              (forward-line -1)
              (setq begin (point)))
            (when (looking-at (concat "[^\n]+?" marker-re "\\*/[ \t]*$"))
              (setq marker (if (string= (match-string 1) "-----") ?- ?*))
              (forward-line))
            (while (and (looking-at "[^\n]+?\\*/[ \t]*$")
                        (not (looking-at (concat "[^\n]+?" marker-re
                                                 "\\*/[ \t]*$"))))
              (forward-line))
            (when (looking-at (concat "[^\n]+?" marker-re "\\*/[ \t]*$"))
              (forward-line))
            (setq end (point))
            (let ((comment (buffer-substring-no-properties begin end)))
              (with-temp-buffer
                (insert comment)
                (goto-char (point-min))
                (flush-lines (concat "^[ \t]*/\\*" marker-re "[-*]+\\*/[ \t]*$"))
                (goto-char (point-min))
                (while (re-search-forward "^[ \t]*/\\* ?" nil t)
                  (goto-char (match-beginning 0))
                  (delete-region (match-beginning 0) (match-end 0)))
                (goto-char (point-min))
                (while (re-search-forward "[ \t]*\\*/[ \t]*$" nil t)
                  (goto-char (match-beginning 0))
                  (delete-region (match-beginning 0) (match-end 0)))
                (goto-char (point-min)) (delete-trailing-whitespace)
                (goto-char (point-min)) (flush-lines "^$")
                (set-fill-column (- 80    ; width of the text
                                    6     ; width of "/*  */"
                                    leader-width))
                (goto-char (point-min)) (fill-paragraph nil)
                (goto-char (point-min))
                (while (not (eobp))
                  (insert (make-string leader-width ? ) "/* ")
                  (goto-char (line-end-position))
                  (insert (make-string (- 80 3 (current-column)) ? ) " */")
                  (forward-line))
                (goto-char (point-min))
                (insert (make-string leader-width ? )
                        "/*" (make-string (- 80 4 leader-width) marker) "*/\n")
                (goto-char (point-max))
                (insert (make-string leader-width ? )
                        "/*" (make-string (- 80 4 leader-width) marker) "*/\n")
                (setq comment (buffer-string)))
              (goto-char begin)
              (delete-region begin end)
              (insert comment)))
          (goto-char here)))))
  
#+end_src


*** cmake-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , cmake-mode

(use-package cmake-mode
  :mode (("CMakeLists\\.txt\\'" . cmake-mode)
         ("\\.cmake\\'"         . cmake-mode)))

#+end_src

*** cmake-project
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
(use-package cmake-project
:init (progn
  (defun maybe-cmake-project-hook ()
  (if (file-exists-p "CMakeLists.txt") (cmake-project-mode)))
(add-hook 'c-mode-hook 'maybe-cmake-project-hook)
(add-hook 'c++-mode-hook 'maybe-cmake-project-hook)))
#+end_src

*** compile
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , compile

(use-package compile
  :defer t
  :config
  (add-hook 'compilation-finish-functions
            (lambda (buf why)
              (display-buffer buf))))

#+end_src
*** color-moccur
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , color-moccur

(let ((ad-redefinition-action 'accept))
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind ("M-s O" . moccur)
    :init
    (progn
      (bind-key "M-o" 'isearch-moccur isearch-mode-map)
      (bind-key "M-O" 'isearch-moccur-all isearch-mode-map))

    :config
    (use-package moccur-edit)))

#+end_src

*** cpputils-cmake
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  (use-package cpputils-cmake)

#+end_src
*** crosshairs
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , crosshairs

(use-package crosshairs
  :bind ("M-o c" . crosshairs-mode))

#+end_src
*** css-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
  ;;;_ , css-mode
  
  (use-package css-mode
    :mode (("\\.css\\'" . css-mode)
           ("\\.less\\'" . css-mode)))
  
#+end_src

#+results:
: t

*** csv-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
(use-package csv-mode)  
#+end_src

*** ibuffer
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ibuffer

(use-package ibuffer
  :defer t
  :init
  (add-hook 'ibuffer-mode-hook
            #'(lambda ()
                (ibuffer-switch-to-saved-filter-groups "default")))
    :bind ("C-x C-b" . ibuffer))

#+end_src

*** iflipb
#+begin_src emacs-lisp
;;;_ , iflipb

(use-package iflipb
  :disabled t
  :commands (iflipb-next-buffer iflipb-previous-buffer)
  :bind (("S-<tab>" . my-iflipb-next-buffer)
         ("A-S-<tab>" . my-iflipb-previous-buffer))
  :init
  (progn
    (defvar my-iflipb-auto-off-timeout-sec 2)
    (defvar my-iflipb-auto-off-timer-canceler-internal nil)
    (defvar my-iflipb-ing-internal nil)

    (defun my-iflipb-auto-off ()
      (message nil)
      (setq my-iflipb-auto-off-timer-canceler-internal nil
            my-iflipb-ing-internal nil))

    (defun my-iflipb-next-buffer (arg)
      (interactive "P")
      (iflipb-next-buffer arg)
      (if my-iflipb-auto-off-timer-canceler-internal
          (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
      (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
      (setq my-iflipb-ing-internal t))

    (defun my-iflipb-previous-buffer ()
      (interactive)
      (iflipb-previous-buffer)
      (if my-iflipb-auto-off-timer-canceler-internal
          (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
      (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
      (setq my-iflipb-ing-internal t)))

  :config
  (progn
    (setq iflipb-always-ignore-buffers
          "\\`\\( \\|diary\\|ipa\\|\\.newsrc-dribble\\'\\)"
          iflipb-wrap-around t)

    (defun iflipb-first-iflipb-buffer-switch-command ()
      "Determines whether this is the first invocation of
iflipb-next-buffer or iflipb-previous-buffer this round."
      (not (and (or (eq last-command 'my-iflipb-next-buffer)
                    (eq last-command 'my-iflipb-previous-buffer))
                my-iflipb-ing-internal)))))

#+end_src
*** debbugs
#+begin_src emacs-lisp
;;;_ , debbugs

(use-package debbugs-gnu
  :commands (debbugs-gnu debbugs-gnu-search))

#+end_src
*** dedicated
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , dedicated

(use-package dedicated
  :bind ("C-. d" . dedicated-mode))

#+end_src
*** not delsel
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src


*** delsel
:PROPERTIES:
:tangle:   no
:END:

#+begin_src emacs-lisp
  (use-package delsel
    :init (delete-selection-mode t))
#+end_src

*** diff-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , diff-mode

(use-package diff-mode
  :commands diff-mode
  :config
  (use-package diff-mode-))

#+end_src

*** dired
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
  ;;;_ , dired
  
  (use-package dired
     :defer t
     :config
    (progn
      (setq insert-directory-program "gls") 
      ;;(use-package ls-lisp)
      (defun dired-package-initialize ()
        (unless (featurep 'runner)
         (use-package dired-x)
         ;; (use-package dired-async)
         (use-package dired-sort-map)
         (use-package runner))
 
         ;;(setq dired-use-ls-dired t)
         ;;(setq ls-lisp-use-insert-directory-program nil)
         ;;(setq insert-directory-program "gls")

         (bind-key "l" 'dired-up-directory dired-mode-map)
  
         (defun my-dired-switch-window ()
            (interactive)
            (if (eq major-mode 'sr-mode)
                (call-interactively #'sr-change-window)
              (call-interactively #'other-window)))
  
          (bind-key "<tab>" 'my-dired-switch-window dired-mode-map)
  
          (bind-key "M-!" 'async-shell-command dired-mode-map)
          (unbind-key "M-G" dired-mode-map)
          (unbind-key "M-s f" dired-mode-map)
  
          (defadvice dired-omit-startup (after diminish-dired-omit activate)
            "Make sure to remove \"Omit\" from the modeline."
            (diminish 'dired-omit-mode) dired-mode-map)
  
          (defadvice dired-next-line (around dired-next-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (eobp)) (not ad-return-value))
              (forward-line)
              (setq ad-return-value(dired-move-to-filename)))
            (when (eobp)
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename))))
  
          (defadvice dired-previous-line (around dired-previous-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (bobp)) (not ad-return-value))
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename)))
            (when (bobp)
              (call-interactively 'dired-next-line)))
  
          (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))
  
          ;; Omit files that Git would ignore
          (defun dired-omit-regexp ()
            (let ((file (expand-file-name ".git"))
                  parent-dir)
              (while (and (not (file-exists-p file))
                          (progn
                            (setq parent-dir
                                  (file-name-directory
                                   (directory-file-name
                                    (file-name-directory file))))
                            ;; Give up if we are already at the root dir.
                            (not (string= (file-name-directory file)
                                          parent-dir))))
                ;; Move up to the parent dir and try again.
                (setq file (expand-file-name ".git" parent-dir)))
              ;; If we found a change log in a parent, use that.
              (if (file-exists-p file)
                  (let ((regexp (funcall dired-omit-regexp-orig))
                        (omitted-files
                         (shell-command-to-string "git clean -d -x -n")))
                    (if (= 0 (length omitted-files))
                        regexp
                      (concat
                       regexp
                       (if (> (length regexp) 0)
                           "\\|" "")
                       "\\("
                       (mapconcat
                        #'(lambda (str)
                            (concat
                             "^"
                             (regexp-quote
                              (substring str 13
                                         (if (= ?/ (aref str (1- (length str))))
                                             (1- (length str))
                                           nil)))
                             "$"))
                        (split-string omitted-files "\n" t)
                        "\\|")
                       "\\)")))
                (funcall dired-omit-regexp-orig))))))
  
      (eval-after-load "dired-aux"
        '(defun dired-do-async-shell-command (command &optional arg file-list)
           "Run a shell command COMMAND on the marked files asynchronously.
  
  Like `dired-do-shell-command' but if COMMAND doesn't end in ampersand,
  adds `* &' surrounded by whitespace and executes the command asynchronously.
  The output appears in the buffer `*Async Shell Command*'."
           (interactive
            (let ((files (dired-get-marked-files t current-prefix-arg)))
              (list
               ;; Want to give feedback whether this file or marked files are
               ;; used:
               (dired-read-shell-command "& on %s: " current-prefix-arg files)
               current-prefix-arg
               files)))
           (unless (string-match "[ \t][*?][ \t]" command)
             (setq command (concat command " *")))
           (unless (string-match "&[ \t]*\\'" command)
             (setq command (concat command " &")))
           (dired-do-shell-command command arg file-list)))
  
      (add-hook 'dired-mode-hook 'dired-package-initialize)
  
      (defun dired-double-jump (first-dir second-dir)
        (interactive
         (list (ido-read-directory-name "First directory: "
                                        (expand-file-name "~")
                                        nil nil "dl/")
               (ido-read-directory-name "Second directory: "
                                        (expand-file-name "~")
                                        nil nil "Archives/")))
        (dired first-dir)
        (dired-other-window second-dir))
  
      (bind-key "C-c J" 'dired-double-jump))
  
#+end_src

*** docx
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
 (add-to-list 'auto-mode-alist '("\\.docx\\'" . docx2txt))

(defun docx2txt ()
  "Run docx2txt on the entire buffer."
  (shell-command-on-region (point-min) (point-max) "docx2txt.pl" t t))
#+end_src

*** doxymacs
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , doxymacs

(use-package doxymacs
  :disabled t
  :load-path "site-lisp/doxymacs/lisp/")

#+end_src
*** dvc
#+begin_src emacs-lisp
;;;_ , dvc

(use-package dvc-autoloads
  :load-path "site-lisp/dvc/lisp/")

#+end_src
*** ediff
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ediff

(use-package ediff
  :pre-init
  (progn
    (defvar ctl-period-equals-map)
    (define-prefix-command 'ctl-period-equals-map)
    (bind-key "C-. =" 'ctl-period-equals-map)

    (bind-key "C-. = c" 'compare-windows)) ; not an ediff command, but it fits
  :bind (("C-. = b" . ediff-buffers)
         ("C-. = B" . ediff-buffers3)
         ("C-. = =" . ediff-files)
         ("C-. = f" . ediff-files)
         ("C-. = F" . ediff-files3)
         ("C-. = r" . ediff-revision)
         ("C-. = p" . ediff-patch-file)
         ("C-. = P" . ediff-patch-buffer)
         ("C-. = l" . ediff-regions-linewise)
         ("C-. = w" . ediff-regions-wordwise))
  :config
  (use-package ediff-keep))

#+end_src

*** edit-server
#+begin_src emacs-lisp
;;;_ , edit-server

(use-package edit-server
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive))
  :init
  (progn
    (add-hook 'after-init-hook 'server-start t)
    (add-hook 'after-init-hook 'edit-server-start t)))

#+end_src
*** emms
#+begin_src emacs-lisp
;;;_ , emms

(use-package emms-setup
  :load-path "site-lisp/emms/lisp"
  :defines emms-info-functions
  :commands (emms-all emms-devel)
  :init
  (progn
    (defvar emms-initialized nil)

    (defun my-emms ()
      (interactive)
      (unless emms-initialized
        (emms-devel)
        (emms-default-players)
        (require 'emms-info-libtag)
        (setq emms-info-functions '(emms-info-libtag))
        (setq emms-initialized t))
      (call-interactively #'emms-smart-browse))

    (bind-key "C-. M" 'my-emms))

  :config
  (progn
    (bind-key "S-<f7>" 'emms-previous)
    (bind-key "S-<f8>" 'emms-pause)
    (bind-key "S-<f9>" 'emms-next)
    (bind-key "S-<f10>" 'emms-stop)

    (defun emms-player-mplayer-volume-up ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume 1\n"))

    (defun emms-player-mplayer-volume-down ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume -1\n"))

    (bind-key "C-. C--" 'emms-player-mplayer-volume-down)
    (bind-key "C-. C-=" 'emms-player-mplayer-volume-up)))

#+end_src

*** erc
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
;;;_ , erc

(use-package erc
  ;; :commands erc
  :commands (irc im)
  :disabled t
  :init
  (progn
    (defun irc ()
      (interactive)
      (erc-tls :server "irc.freenode.net"
               :port 6697
               :nick "tonyday567"
               :password (funcall
                          (plist-get
                           (car (auth-source-search :host "irc.freenode.net"
                                                    :user "tonyday567"
                                                    :port 6667))
                           :secret))))


    (defun im ()
      (interactive)
      (erc :server "localhost"
           :port 6667
           :nick "tonyday567")
      (use-package secret)
      (erc-message "PRIVMSG" (format "%s identify %s"
                             "&bitlbee"
                             bitlbee-password))))

  :config
  (progn
    (erc-track-minor-mode 1)
    (erc-track-mode 1)

    (use-package erc-alert)
    (use-package erc-highlight-nicknames)
    (use-package erc-patch)
    
    (use-package erc-yank
      :init
      (bind-key "C-y" 'erc-yank erc-mode-map))

    (use-package wtf
      :commands wtf-is
      :init
      (defun erc-cmd-WTF (term &rest ignore)
        "Look up definition for TERM."
        (let ((def (wtf-is term)))
          (if def
              (let ((msg (concat "{Term} " (upcase term) " is " def)))
                (with-temp-buffer
                  (insert msg)
                  (kill-ring-save (point-min) (point-max)))
                (message msg))
            (message (concat "No definition found for " (upcase term)))))))

    (use-package bitlbee
      :init (bitlbee-start))

    (defun switch-to-bitlbee ()
      (interactive)
      (switch-to-buffer-other-window "&bitlbee")
      (call-interactively 'erc-channel-names)
      (goto-char (point-max)))

    (bind-key "C-. C-. b" 'switch-to-bitlbee)

    (defun erc-cmd-SHOW (&rest form)
      "Eval FORM and send the result and the original form as:
FORM => (eval FORM)."
      (let* ((form-string (mapconcat 'identity form " "))
             (result
              (condition-case err
                  (eval (read-from-whole-string form-string))
                (error
                 (format "Error: %s" err)))))
        (erc-send-message (format "%s => %S" form-string result))))

    (defun erc-cmd-INFO (&rest ignore)
      "Send current info node."
      (unless (get-buffer "*info*")
        (error "No *info* buffer"))
      (let (output)
        (with-current-buffer "*info*"
          (let* ((file (file-name-nondirectory Info-current-file))
                 (node Info-current-node))
            (setq output (format "(info \"(%s)%s\") <-- hit C-x C-e to evaluate"
                                 file node))))
        (erc-send-message output)))

    (eval-when-compile
      (defvar erc-fools))

    (defun erc-cmd-FOOL (term &rest ignore)
      (add-to-list 'erc-fools term))

    (defun erc-cmd-UNFOOL (term &rest ignore)
      (setq erc-fools (delete term erc-fools)))

    (defun erc-cmd-OPME ()
      "Request chanserv to op me."
      (erc-message "PRIVMSG"
                   (format "chanserv op %s %s"
                           (erc-default-target)
                           (erc-current-nick)) nil))

    (defun erc-cmd-DEOPME ()
      "Deop myself from current channel."
      (erc-cmd-DEOP (format "%s" (erc-current-nick))))))
    

#+end_src

*** erlang
#+begin_src emacs-lisp
  (use-package erlang-start)
(setq erlang-root-dir "/usr/local/Cellar/erlang/R15B02/share")
#+end_src

*** eshell
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , eshell

(use-package eshell
  :defer t
  :init
  (progn
    (defun eshell-initialize ()
      (defun eshell-spawn-external-command (beg end)
        "Parse and expand any history references in current input."
        (save-excursion
          (goto-char end)
          (when (looking-back "&!" beg)
            (delete-region (match-beginning 0) (match-end 0))
            (goto-char beg)
            (insert "spawn "))))

      (add-hook 'eshell-expand-input-functions 'eshell-spawn-external-command)

      (defun ss (server)
        (interactive "sServer: ")
        (call-process "spawn" nil nil nil "ss" server))

      (eval-after-load "em-unix"
        '(progn
           (unintern 'eshell/su)
           (unintern 'eshell/sudo))))

    (add-hook 'eshell-first-time-mode-hook 'eshell-initialize)))

(use-package esh-toggle
  :requires eshell
  :bind ("C-x C-z" . eshell-toggle))

#+end_src
*** ess
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package ess-site
  :bind ("C-. C-. r" . R))
;;(use-package ess-tracebug)
#+end_src


#+end_src


*** eval-expr
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , eval-expr

(use-package eval-expr
  :bind ("M-:" . eval-expr)
  :config
  (progn
    (setq eval-expr-print-function 'pp
          eval-expr-print-level 20
          eval-expr-print-length 100)

    (defun eval-expr-minibuffer-setup ()
      (set-syntax-table emacs-lisp-mode-syntax-table)
      (paredit-mode))))

#+end_src
*** expand-region
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

*** fetchmail-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , fetchmail-mode

(use-package fetchmail-mode
  :commands fetchmail-mode)

#+end_src
*** ffap
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package ffap
:init (progn
(setq ffap-machine-p-known 'accept) ; no pinging
(setq ffap-url-regexp nil) ; disable URL features in ffap
(setq ffap-ftp-regexp nil) ; disable FTP features in ffap
)
  :bind ("C-c v" . ffap))
#+end_src

*** ffip
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package find-file-in-project
  :bind ("C-x f" . find-file-in-project))
#+end_src

*** flymake-html-validator
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  (use-package flymake-html-validator
    :init
    (progn
      ;;(add-hook 'html-mode-hook 'flymake-mode)
            
      (defvar flymake-minor-map-mode)
      (define-prefix-command 'flymake-minor-mode-map)
      (bind-key "H-f" 'flymake-minor-mode)
      (bind-key "M-p" 'flymake-goto-prev-error)
      (bind-key "M-n" 'flymake-goto-next-error)
            
      (defun flymake-err-at (pos)
        (let ((overlays (overlays-at pos)))
          (remove nil
                  (mapcar (lambda (overlay)
                            (and (overlay-get overlay 'flymake-overlay)
                                 (overlay-get overlay 'help-echo)))
                          overlays))))
            
      (defun flymake-err-echo ()
        (message "%s" (mapconcat 'identity (flymake-err-at (point)) "\n")))
            
      (defadvice flymake-goto-next-error (after display-message activate compile)
        (flymake-err-echo))
            
      (defadvice flymake-goto-prev-error (after display-message activate compile)
        (flymake-err-echo))
            
      (define-minor-mode flymake-minor-mode
        "Simple minor mode which adds some key bindings for moving to the next and previous errors.
  
  Key bindings:
  
  \\{my-flymake-minor-mode-map}"
        nil
        nil
        flymake-minor-mode-map)
            
      ;; Enable this keybinding (my-flymake-minor-mode) by default
      ;; Added by Hartmut 2011-07-05
      ;; (add-hook 'html-mode-hook 'flymake-minor-mode)
            
      ;;(setq validator-script
      ;;"~/.emacs.d/site-lisp/flymake-html-validator")
      ))
#+end_src

#+results:
: t

*** flyspell
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , flyspell

(use-package ispell
  :bind (("C-c i c" . ispell-comments-and-strings)
         ("C-c i d" . ispell-change-dictionary)
         ("C-c i k" . ispell-kill-ispell)
         ("C-c i m" . ispell-message)
         ("C-c i r" . ispell-region)))

(use-package flyspell
  :bind (("C-c i b" . flyspell-buffer)
         ("C-c i f" . flyspell-mode))
  :config
  (define-key flyspell-mode-map [(control ?.)] nil))

#+end_src
*** fold-dwim
#+begin_src emacs-lisp
;;;_ , fold-dwim

(use-package fold-dwim
  :bind (("<f13>" . fold-dwim-toggle)
         ("<f14>" . fold-dwim-hide-all)
         ("<f15>" . fold-dwim-show-all)))

#+end_src
*** gist
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , gist

(use-package gist
  :bind ("C-c G" . gist-region-or-buffer))

#+end_src
*** gnus wrapped
:PROPERTIES:
:tangle:   yes
:END:

I can't get gnus to defer, so I've wrapped the use-package call in a function.

#+begin_src emacs-lisp
  (defun my-gnus-load ()
    (interactive)
    (use-package gnus
      :config
      (progn
(setq gnus-agent-go-online t)         
(use-package bbdb)
         (use-package bbdb-gnus)
         (use-package bbdb-message)
     
         (use-package gnus-harvest
           init: (gnus-harvest-install 'message-x))
         (use-package starttls)
         (gnus-registry-initialize)
         (autoload 'gnus-dired-mode "gnus-dired" nil t)
         (add-hook 'dired-mode-hook 'gnus-dired-mode)
     
         (defun my-process-running-p (name)
           (catch 'proc-running
             (dolist (proc (process-list))
               (if (and (string-match name (process-name proc))
                        (eq 'run (process-status proc)))
                   (throw 'process-running-child-p proc)))))
     
         (defun start-offlineimap-regular()
           (interactive)
           (shell-command "offlineimap&" "*offlineimap*" nil))
     
         (defun start-offlineimap ()
           (interactive)
           (shell-command
            "launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.offline-imap.plist")
           (message "Offlineimap started"))
     
         (defun shutdown-offlineimap ()
           (interactive)
           (message "Stopping offlineimap...")
           (set-process-sentinel
            (start-process-shell-command
             "*offlineimap*" "*offlineimap*"
             "launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.offline-imap.plist")
            (lambda (process event)
              (when (string= event "finished\n")
                (message "Stopping offlineimap...done")))))
     
     
         (defun gnus-query (query)
           (interactive "sMail Query: ")
           (let ((nnir-imap-default-search-key "imap"))
             (gnus-group-make-nnir-group
              nil
              `((query    . ,query)
                (criteria . "")
                (server   . "nnimap:Mail") ))))
         
         (bind-key "s-M-f" 'gnus-query)
     
         (defun gnus-goto-article (message-id)
           (with-temp-buffer
             (erase-buffer)
             ;; Insert dummy article
             (insert (format "From nobody Tue Sep 13 22:05:34 2011\n\n"))
             (gnus-group-read-ephemeral-group
              message-id
              `(nndoc ,message-id
                      (nndoc-address ,(current-buffer))
                      (nndoc-article-type mbox))
              :activate
              (cons (current-buffer) gnus-current-window-configuration)
              (not :request-only)
              '(-1)                          ; :select-articles
              (not :parameters)
              0                              ; :number
              )
             (gnus-summary-refer-article message-id)
                                             ;           (and (bound-and-true-p gnus-registry-enabled)
                                             ;            (gnus-try-warping-via-registry))
             ))
     
         (defun gnus-current-message-id ()
           (with-current-buffer gnus-original-article-buffer
             (nnheader-narrow-to-headers)
             (message-fetch-field "message-id")))
     
         (defun gnus-open-article-in-apple-mail ()
           (interactive)
           (let ((message-id (gnus-current-message-id)))
             (start-process (concat "open message:" message-id) nil
                            "open" (concat "message://<"
                                           (substring message-id 1 -1) ">"))))
     
         (defun gmail-report-spam ()
           "Report the current or marked mails as spam.
     This moves them into the Spam folder."
           (interactive)
           (gnus-summary-move-article nil "[Gmail].Spam"))
     
     
         (use-package gnus-sum
           :init
           (progn
             (bind-key "$" 'gmail-report-spam gnus-summary-mode-map)
             (bind-key "<C-backspace>" 'gnus-summary-mark-as-expirable gnus-summary-mode-map)
             (bind-key  "<S-backspace>" 'gnus-summary-expire-thread gnus-summary-mode-map)
             (bind-key "O O" 'gnus-open-article-in-apple-mail gnus-summary-mode-map)
             (bind-key "C-c C-o" 'gnus-article-browse-urls gnus-summary-mode-map)))
     
         (defadvice message-goto-from (after insert-boostpro-address activate)
           (if (looking-back ": ")
               (insert "Tony Day <tonyday567@gmail.com>"))
           (goto-char (line-end-position))
           (re-search-backward ": ")
           (goto-char (match-end 0)))
     
         (setq my-smtpmailer-alist
               '((".*"
                  ("tonyday567@gmail.com" . "smtp.gmail.com")
                  ("tony.day@scarcecapital.com" . "smtp.gmail.com"))
                 ))
     
         (defun my-set-smtp-server ()
           (when (message-field-value "to")
             (let* ((to-field (cadr (mail-extract-address-components
                                     (message-field-value "to"))))
                    (from (let ((field (message-field-value "from")))
                            (and field (cadr (mail-extract-address-components field)))))
                    (result
                     (car (assoc-default (or from to-field)
                                         my-smtpmailer-alist
                                         'string-match
                                         (cons user-mail-address
                                               (if (boundp 'smtpmail-default-smtp-server)
                                                   smtpmail-default-smtp-server
                                                 ""))))))
               (if from
                   (setq smtpmail-mail-address from
                         mail-envelope-from from
                         smtpmail-smtp-server (cdr result)
                         smtpmail-smtp-service 587)
                 ;; set mailer address and port
                 (setq smtpmail-mail-address (car result)
                       mail-envelope-from (car result)
                       smtpmail-smtp-server (cdr result)
                       smtpmail-smtp-service 587)
                 (message-remove-header "From")
                 (message-add-header
                  (format "From: %s <%s>" user-full-name (car result)))))))
         
         (add-hook 'message-send-hook 'my-set-smtp-server)
         
     ;;;_ + Determine layout of the summary windows
         
         (progn
           (gnus-add-configuration
            '(article
              (horizontal 1.0
                          (vertical 1.0
                                    (group 10)
                                    (summary 1.0 point))
                          (vertical .5 (article 1.0)))))
           
           
           (gnus-add-configuration
            '(summary
              (horizontal 1.0
                          (vertical 1.0
                                    (group 10)
                                    (summary 1.0 point))
                          (vertical .5 (article 1.0)))))
           
           (gnus-add-configuration
            '(message
              (horizontal 1.0
                          (vertical 1.0
                                    (group 10)
                                    (summary 1.0))
                          (vertical .5
                                    (message 1.0 point)))))
           
           (gnus-add-configuration
            '(reply
              (horizontal 1.0
                          (vertical 1.0
                                    (group 10)
                                    (summary 1.0))
                          (vertical .5
                                    (message 1.0 point)
                                    (article .25)))))
           
           (gnus-add-configuration
            '(reply-yank
              (horizontal 1.0
                          (vertical 1.0
                                    (group 10)
                                    (summary 1.0))
                          (vertical .5
                                    (message 1.0 point)))))
           )
         
     ;;;_ + Cleanup all Gnus buffers on exit
         
         (defun exit-gnus-on-exit ()
           (if (and (fboundp 'gnus-group-exit)
                    (gnus-alive-p))
               (with-current-buffer (get-buffer "*Group*")
                 (gnus-group-exit))))
         
         (add-hook 'kill-emacs-hook 'exit-gnus-on-exit)
     
     ;;;_ + Scoring
     
         (eval-when-compile
           (defvar arg))
         
         (defun gnus-score-groups ()
           (interactive)
           (save-excursion
             (dolist (info (cdr gnus-newsrc-alist))
               ;; Only consider this group if it's at or below the current level
               (when (<= (gnus-info-level info)
                         (if (numberp arg)
                             arg
                           (or (gnus-group-default-level nil t)
                               (gnus-group-default-list-level)
                               gnus-level-subscribed)))
                 (let* ((group (gnus-info-group info))
                        (unread (gnus-group-unread group)))
                   (when (and (not (string-match "^\\(\\(nnimap\\+\\)?Mail:\\)?" group))
                              (numberp unread) (> unread 0))
                     (ignore-errors
                       (gnus-summary-read-group group nil t))
                     (when (and gnus-summary-buffer
                                (buffer-live-p gnus-summary-buffer)
                                (eq (current-buffer)
                                    (get-buffer gnus-summary-buffer)))
                       (gnus-summary-exit))))))))
         
     ;;;_ + Summary line formats
         
         (defun gnus-user-format-function-Z (header)
           (let ((to (cdr (assq 'To (mail-header-extra header))))
                 (newsgroups (cdr (assq 'Newsgroups (mail-header-extra header))))
                 (mail-parse-charset gnus-newsgroup-charset)
                 (mail-parse-ignored-charsets
                  (with-current-buffer gnus-summary-buffer
                    gnus-newsgroup-ignored-charsets)))
             (cond
              ((and to gnus-ignored-from-addresses
                    (string-match gnus-ignored-from-addresses
                                  (mail-header-from header)))
               (concat "-> "
                       (or (car (funcall gnus-extract-address-components
                                         (funcall
                                          gnus-decode-encoded-word-function to)))
                           (funcall gnus-decode-encoded-word-function to))))
              ((and newsgroups gnus-ignored-from-addresses
                    (string-match gnus-ignored-from-addresses
                                  (mail-header-from header)))
               (concat "=> " newsgroups))
              (t
               (let* ((from (mail-header-from header))
                      (data (condition-case nil
                                (mail-extract-address-components from)
                              (error nil)))
                      (name (car data))
                      (net (car (cdr data))))
                 (or name net))))))
         
         (defsubst dot-gnus-tos (time)
           "Convert TIME to a floating point number."
           (+ (* (car time) 65536.0)
              (cadr time)
              (/ (or (car (cdr (cdr time))) 0) 1000000.0)))
         
         (defun gnus-user-format-function-S (header)
           "Return how much time it's been since something was sent."
           (condition-case err
               (let ((date (mail-header-date header)))
                 (if (> (length date) 0)
                     (let* ((then (dot-gnus-tos
                                   (apply 'encode-time (parse-time-string date))))
                            (now (dot-gnus-tos (current-time)))
                            (diff (- now then)))
                       (cond ((>= diff (* 86400.0 7.0 52.0))
                              (if (>= diff (* 86400.0 7.0 52.0 10.0))
                                  (format "%3dY" (floor (/ diff (* 86400.0 7.0 52.0))))
                                (format "%3.1fY" (/ diff (* 86400.0 7.0 52.0)))))
                             ((>= diff (* 86400.0 30.0))
                              (if (>= diff (* 86400.0 30.0 10.0))
                                  (format "%3dM" (floor (/ diff (* 86400.0 30.0))))
                                (format "%3.1fM" (/ diff (* 86400.0 30.0)))))
                             ((>= diff (* 86400.0 7.0))
                              (if (>= diff (* 86400.0 7.0 10.0))
                                  (format "%3dw" (floor (/ diff (* 86400.0 7.0))))
                                (format "%3.1fw" (/ diff (* 86400.0 7.0)))))
                             ((>= diff 86400.0)
                              (if (>= diff (* 86400.0 10.0))
                                  (format "%3dd" (floor (/ diff 86400.0)))
                                (format "%3.1fd" (/ diff 86400.0))))
                             ((>= diff 3600.0)
                              (if (>= diff (* 3600.0 10.0))
                                  (format "%3dh" (floor (/ diff 3600.0)))
                                (format "%3.1fh" (/ diff 3600.0))))
                             ((>= diff 60.0)
                              (if (>= diff (* 60.0 10.0))
                                  (format "%3dm" (floor (/ diff 60.0)))
                                (format "%3.1fm" (/ diff 60.0))))
                             (t
                              (format "%3ds" (floor diff)))))))
             (error "    ")))
         
         (eval-when-compile
           (defvar thread)
           (defvar gnus-tmp-level))
         
         (defun gnus-user-format-function-t-johnw (header)
           (let ((tcount (gnus-summary-number-of-articles-in-thread
                          (and (boundp 'thread) (car thread)) gnus-tmp-level)))
             (if (> tcount 1)
                 (number-to-string tcount)
               " ")))
         
     ;;;_ + gnus-article-browse-urls
         
         (defun gnus-article-browse-urls ()
           "Visit a URL from the `gnus-article-buffer' by prompting via a
         poping up a buffer showing the list of URLs found with the
         `gnus-button-url-regexp'."
           (interactive)
           (gnus-configure-windows 'article)
           (gnus-summary-select-article nil nil 'pseudo)
           (let ((temp-buffer (generate-new-buffer " *Article URLS*"))
                 (urls (gnus-article-get-current-urls))
                 (this-window (selected-window))
                 (browse-window (get-buffer-window gnus-article-buffer))
                 (count 0))
             (save-excursion
               (save-window-excursion
                 (set-buffer temp-buffer)
                 (mapc (lambda (string)
                         (insert (format "\t%d: %s\n" count string))
                         (setq count (1+ count))) urls)
                 (not-modified)
                 (pop-to-buffer temp-buffer)
                 (setq count
                       (string-to-number
                        (char-to-string (if (fboundp
                                             'read-char-exclusive)
                                            (read-char-exclusive)
                                          (read-char)))))
                 (kill-buffer temp-buffer))
               (if browse-window
                   (progn (select-window browse-window)
                          (browse-url (nth count urls)))))
             (select-window this-window)))
         
         (defun gnus-article-get-current-urls ()
           "Return a list of the urls found in the current `gnus-article-buffer'"
           (let (url-list)
             (with-current-buffer gnus-article-buffer
               (setq url-list (gnus-article-get-urls-region (point-min) (point-max))))
             url-list))
         
         (defun gnus-article-get-urls-region (min max)
           "Return a list of urls found in the region between MIN and MAX"
           (let (url-list)
             (save-excursion
               (save-restriction
                 (narrow-to-region min max)
                 (goto-char (point-min))
                 (while (re-search-forward gnus-button-url-regexp nil t)
                   (let ((match-string (match-string-no-properties 0)))
                     (if (and (not (equal (substring match-string 0 4) "file"))
                              (not (member match-string url-list)))
                         (setq url-list (cons match-string url-list)))))))
             url-list))
         
         
     ;;;_* keybindings
         
     ;;;_ + gnus-group-score
         
         (eval-after-load "gnus-group"
           '(progn
              (bind-key "s" 'gnus-score-groups gnus-group-score-map)
              (bind-key "v o" 'start-offlineimap gnus-group-mode-map)))
         
         (eval-after-load "w3m"
           '(bind-key "\C-m" 'w3m-view-url-with-external-browser w3m-minor-mode-map))
         
     ;;;_ + dave's stuff
         
         (defun dwa/gnus-summary-ignore-thread ()
           (interactive)
           (gnus-summary-top-thread)
           (let ((message-id (gnus-summary-header "message-id")))
             (dolist (hdr-type '(("references" . s) ("message-id" . e)))
               (gnus-summary-score-entry
                (car hdr-type)                       ; Header
                (gnus-summary-header "message-id")   ; Match
                (cdr hdr-type)                       ; Type
                (- (gnus-score-delta-default nil))   ; Score
                nil                                  ; Temp
                nil                                  ; Prompt
                nil                                  ; not silent
                nil)))                               ; non-standard overview.
           (gnus-summary-kill-thread))
         (bind-key "i" 'dwa/gnus-summary-ignore-thread gnus-summary-mode-map)
         
         ;;
         ;; Support proportional fonts in the summary and group buffers by inserting a forced alignment
         ;;
         ;; See http://news.gmane.org/find-root.php?message_id=%3cyoij63rj41q5.fsf%40remote5.student.chalmers.se%3e
         (defvar my-align-gnus-summary (propertize " " 'display '(space :align-to 5)))
         (defvar my-align-gnus-subject (propertize " " 'display '(space :align-to 30)))
         
         (defvar my-align-gnus-group (propertize " " 'display '(space :align-to 8)))
         
         
         ;; Display word docs inline with antiword installed.  See
         ;; http://www.emacswiki.org/emacs/MimeTypesWithGnus
         (when nil
           (require 'mm-view)
           (add-to-list 'mm-inline-media-tests
                        '("application/msword" mm-inline-text identity))
           (add-to-list 'mm-automatic-external-display "application/msword")
           (add-to-list 'mm-attachment-override-types "application/msword")
           (add-to-list 'mm-automatic-display "application/msword"))
         
         (defun dwa/gnus-summary-first-unread-or-first-subject ()
           "Place the point on the subject line of the first unseen article.
     If all article have been seen, on the subject line of the last article."
           (interactive)
           (prog1
               (unless
                   (when (gnus-summary-first-subject t nil t)
                     (gnus-summary-show-thread)
                     (gnus-summary-first-subject t nil t))
                 (goto-char (point-min)))))
         (setq gnus-auto-select-subject 'dwa/gnus-summary-first-unread-or-first-subject)
         
                                             ;(require 'gnus-spec)
                                             ;(eval-when-compile (gnus-compile))
         
         (require 'gravatar nil 'noerror)
         (require 'gnus-gravatar nil 'noerror)
         (spam-initialize)
         (bind-key "$" 'gnus-summary-mark-as-spam gnus-summary-mode-map)
         (bind-key "v o" 'start-offlineimap gnus-summary-mode-map)
         
         
         (defvar my-gnus-group-faces
           '(
             gnus-group-news-1
             gnus-group-news-1-empty
             gnus-group-news-2
             gnus-group-news-2-empty
             gnus-group-news-3
             gnus-group-news-3-empty
             gnus-group-news-4
             gnus-group-news-4-empty
             gnus-group-news-5
             gnus-group-news-5-empty
             gnus-group-news-6
             gnus-group-news-6-empty
             gnus-group-news-low
             gnus-group-news-low-empty
             gnus-group-mail-1
             gnus-group-mail-1-empty
             gnus-group-mail-2
             gnus-group-mail-2-empty
             gnus-group-mail-3
             gnus-group-mail-3-empty
             gnus-group-mail-low
             gnus-group-mail-low-empty))
         
         (defvar my-gnus-summary-faces
           '(
             gnus-summary-selected
             gnus-summary-cancelled
             gnus-summary-high-ticked
             gnus-summary-low-ticked
             gnus-summary-normal-ticked
             gnus-summary-high-ancient
             gnus-summary-low-ancient
             gnus-summary-normal-ancient
             gnus-summary-high-undownloaded
             gnus-summary-low-undownloaded
             gnus-summary-normal-undownloaded
             gnus-summary-high-unread
             gnus-summary-low-unread
             gnus-summary-normal-unread
             gnus-summary-high-read
             gnus-summary-low-read
             gnus-summary-normal-read
             gnus-summary-expirable-face))
         
                                             ;(defvar my-gnus-group-face-attributes '(:family "DejaVu Sans" :weight normal :width condensed))
         (defvar my-gnus-summary-face-attributes '(:family "DejaVu Sans" :weight normal :width condensed))
         
                                             ;(dolist (facename my-gnus-group-faces)
                                             ;  (apply 'set-face-attribute facename nil my-gnus-group-face-attributes))
         (dolist (facename my-gnus-summary-faces)
           (when (facep facename)
             (apply 'set-face-attribute facename nil my-gnus-summary-face-attributes)))
         
         (defface gnus-summary-expirable-face
           '((((class color) (background dark))
              (:foreground "grey50" :italic t :strike-through t))
             (((class color) (background light))
              (:foreground "grey55" :italic t :strike-through t)))
           "Face used to highlight articles marked as expirable."
           :group 'gnus-summary-visual)
         
         ;; prettier summary buffers
         (when window-system
           (setq gnus-sum-thread-tree-indent "  ")                            ;; "  "
           (setq gnus-sum-thread-tree-root "\u229e ")                         ;; "⊞ "
           (setq gnus-sum-thread-tree-false-root "\u22a1 ")                   ;; "⊡ "
           (setq gnus-sum-thread-tree-single-indent   " -  ")              ;; " -  "
           (setq gnus-sum-thread-tree-vertical        " \u2502")              ;; " │"
           (setq gnus-sum-thread-tree-leaf-with-other " \u251c\u2500 ")  ;; " ├─ "
           (setq gnus-sum-thread-tree-single-leaf     " \u2570\u2500 ")) ;; " ╰─ "
         
         
         ;; Make sure cited text has a light gray background, in case people
         ;; forget to add a blank line after their citations.
         (use-package gnus-cite)
         
         ;; Thanks to David Engster
         ;; [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.gnus.general#87vdnimyxd.fsf@randomsample.de][Posting on ding@gnus.org]]
         (defun DE-collapse-group-names ()
           (save-excursion
             (let (previous-group current-group common-prefix
                                  common-dot-count prefix suffix)
               (goto-char (point-min))
               (while (not (eobp))
                 (when (setq current-group
                             (get-text-property (point) 'gnus-group))
                   (setq current-group (symbol-name current-group))
                   (when (string-match "\\(.+\\):\\(.+\\)" current-group)
                     (setq current-group (match-string 2 current-group)))
                   (setq common-prefix (substring current-group 0
                                                  (mismatch previous-group current-group))
                         common-dot-count (count ?. common-prefix)
                         prefix (mapconcat (lambda (x) x)
                                           (make-list common-dot-count "  .") "")
                         suffix (and (string-match
                                      (format "\\([^.]*[.]\\)\\{%d\\}\\(.+\\)" common-dot-count)
                                      current-group)
                                     (match-string 2 current-group))
                         previous-group current-group)
                   (unless (zerop (length prefix))
                     (when (search-forward current-group (point-at-eol) t)
                       (let ((props (text-properties-at (1- (point)))))
                         (replace-match (apply 'propertize (concat prefix suffix)
                                               props))))))
                 (forward-line 1)))))
         
         (add-hook 'gnus-group-prepare-hook 'DE-collapse-group-names)
         (add-hook 'gnus-group-update-group-hook 'DE-collapse-group-names)
         
         ;; Queueing messages in Gnus (instead of Postfix) when
         ;; disconnected:
         
         ;; uncomment to enable
         ;; (add-hook 'message-send-hook 'queue-message-if-not-connected)
         
         (defun quickping (host)
           (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))
         
         (defun queue-message-if-not-connected ()
           (set (make-local-variable 'gnus-agent-queue-mail)
                (if (quickping "smtp.gmail.com") t 'always)))
         ;;
         ;;
         
         ;; I like citations in email to be set off from the rest of the text
         ;; by a slightly different background color.  This helps immeasurably
         ;; when people forget to leave a blank line after citations.  see
         ;; gnus-settings.el and wl-settings.el, where I inherit this face.
         (defface dwa/mail-citation '((((class color)
                                        (background dark))
                                       (:background "#383838"))
                                      (((class color)
                                        (background light))
                                       (:background "#efefef")))
           "Mail citation base face."))

         (bind-key "H-s" 'message-send-and-exit)

))
       
 #+end_src
*** gnus
:PROPERTIES:
:tangle:   no
:END:
 #+begin_src emacs-lisp
   (use-package gnus
     :bind (("C-. C-. g" . gnus))
     :config
     (progn
       (use-package bbdb)
       (use-package bbdb-gnus)
       (use-package bbdb-message)
   
       (use-package gnus-harvest
         init: (gnus-harvest-install 'message-x))
       (use-package starttls)
       (gnus-registry-initialize)
       (autoload 'gnus-dired-mode "gnus-dired" nil t)
       (add-hook 'dired-mode-hook 'gnus-dired-mode)
   
       (defun my-process-running-p (name)
         (catch 'proc-running
           (dolist (proc (process-list))
             (if (and (string-match name (process-name proc))
                      (eq 'run (process-status proc)))
                 (throw 'process-running-child-p proc)))))
   
       (defun start-offlineimap-regular()
         (interactive)
         (shell-command "offlineimap&" "*offlineimap*" nil))
   
       (defun start-offlineimap ()
         (interactive)
         (shell-command
          "launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.offline-imap.plist")
         (message "Offlineimap started"))
   
       (defun shutdown-offlineimap ()
         (interactive)
         (message "Stopping offlineimap...")
         (set-process-sentinel
          (start-process-shell-command
           "*offlineimap*" "*offlineimap*"
           "launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.offline-imap.plist")
          (lambda (process event)
            (when (string= event "finished\n")
              (message "Stopping offlineimap...done")))))
   
   
       (defun gnus-query (query)
         (interactive "sMail Query: ")
         (let ((nnir-imap-default-search-key "imap"))
           (gnus-group-make-nnir-group
            nil
            `((query    . ,query)
              (criteria . "")
              (server   . "nnimap:Mail") ))))
       
       (bind-key "s-M-f" 'gnus-query)
   
       (defun gnus-goto-article (message-id)
         (with-temp-buffer
           (erase-buffer)
           ;; Insert dummy article
           (insert (format "From nobody Tue Sep 13 22:05:34 2011\n\n"))
           (gnus-group-read-ephemeral-group
            message-id
            `(nndoc ,message-id
                    (nndoc-address ,(current-buffer))
                    (nndoc-article-type mbox))
            :activate
            (cons (current-buffer) gnus-current-window-configuration)
            (not :request-only)
            '(-1)                          ; :select-articles
            (not :parameters)
            0                              ; :number
            )
           (gnus-summary-refer-article message-id)
                                           ;           (and (bound-and-true-p gnus-registry-enabled)
                                           ;            (gnus-try-warping-via-registry))
           ))
   
       (defun gnus-current-message-id ()
         (with-current-buffer gnus-original-article-buffer
           (nnheader-narrow-to-headers)
           (message-fetch-field "message-id")))
   
       (defun gnus-open-article-in-apple-mail ()
         (interactive)
         (let ((message-id (gnus-current-message-id)))
           (start-process (concat "open message:" message-id) nil
                          "open" (concat "message://<"
                                         (substring message-id 1 -1) ">"))))
   
       (defun gmail-report-spam ()
         "Report the current or marked mails as spam.
   This moves them into the Spam folder."
         (interactive)
         (gnus-summary-move-article nil "[Gmail].Spam"))
   
   
       (use-package gnus-sum
         :init
         (progn
           (bind-key "$" 'gmail-report-spam gnus-summary-mode-map)
           (bind-key "<C-backspace>" 'gnus-summary-mark-as-expirable gnus-summary-mode-map)
           (bind-key  "<S-backspace>" 'gnus-summary-expire-thread gnus-summary-mode-map)
           (bind-key "O O" 'gnus-open-article-in-apple-mail gnus-summary-mode-map)
           (bind-key "C-c C-o" 'gnus-article-browse-urls gnus-summary-mode-map)))
   
       (defadvice message-goto-from (after insert-boostpro-address activate)
         (if (looking-back ": ")
             (insert "Tony Day <tonyday567@gmail.com>"))
         (goto-char (line-end-position))
         (re-search-backward ": ")
         (goto-char (match-end 0)))
   
       (setq my-smtpmailer-alist
             '((".*"
                ("tonyday567@gmail.com" . "smtp.gmail.com")
                ("tony.day@scarcecapital.com" . "smtp.gmail.com"))
               ))
   
       (defun my-set-smtp-server ()
         (when (message-field-value "to")
           (let* ((to-field (cadr (mail-extract-address-components
                                   (message-field-value "to"))))
                  (from (let ((field (message-field-value "from")))
                          (and field (cadr (mail-extract-address-components field)))))
                  (result
                   (car (assoc-default (or from to-field)
                                       my-smtpmailer-alist
                                       'string-match
                                       (cons user-mail-address
                                             (if (boundp 'smtpmail-default-smtp-server)
                                                 smtpmail-default-smtp-server
                                               ""))))))
             (if from
                 (setq smtpmail-mail-address from
                       mail-envelope-from from
                       smtpmail-smtp-server (cdr result)
                       smtpmail-smtp-service 587)
               ;; set mailer address and port
               (setq smtpmail-mail-address (car result)
                     mail-envelope-from (car result)
                     smtpmail-smtp-server (cdr result)
                     smtpmail-smtp-service 587)
               (message-remove-header "From")
               (message-add-header
                (format "From: %s <%s>" user-full-name (car result)))))))
       
       (add-hook 'message-send-hook 'my-set-smtp-server)
       
   ;;;_ + Determine layout of the summary windows
       
       (progn
         (gnus-add-configuration
          '(article
            (horizontal 1.0
                        (vertical 1.0
                                  (group 10)
                                  (summary 1.0 point))
                        (vertical .5 (article 1.0)))))
         
         
         (gnus-add-configuration
          '(summary
            (horizontal 1.0
                        (vertical 1.0
                                  (group 10)
                                  (summary 1.0 point))
                        (vertical .5 (article 1.0)))))
         
         (gnus-add-configuration
          '(message
            (horizontal 1.0
                        (vertical 1.0
                                  (group 10)
                                  (summary 1.0))
                        (vertical .5
                                  (message 1.0 point)))))
         
         (gnus-add-configuration
          '(reply
            (horizontal 1.0
                        (vertical 1.0
                                  (group 10)
                                  (summary 1.0))
                        (vertical .5
                                  (message 1.0 point)
                                  (article .25)))))
         
         (gnus-add-configuration
          '(reply-yank
            (horizontal 1.0
                        (vertical 1.0
                                  (group 10)
                                  (summary 1.0))
                        (vertical .5
                                  (message 1.0 point)))))
         )
       
   ;;;_ + Cleanup all Gnus buffers on exit
       
       (defun exit-gnus-on-exit ()
         (if (and (fboundp 'gnus-group-exit)
                  (gnus-alive-p))
             (with-current-buffer (get-buffer "*Group*")
               (gnus-group-exit))))
       
       (add-hook 'kill-emacs-hook 'exit-gnus-on-exit)
   
   ;;;_ + Scoring
   
       (eval-when-compile
         (defvar arg))
       
       (defun gnus-score-groups ()
         (interactive)
         (save-excursion
           (dolist (info (cdr gnus-newsrc-alist))
             ;; Only consider this group if it's at or below the current level
             (when (<= (gnus-info-level info)
                       (if (numberp arg)
                           arg
                         (or (gnus-group-default-level nil t)
                             (gnus-group-default-list-level)
                             gnus-level-subscribed)))
               (let* ((group (gnus-info-group info))
                      (unread (gnus-group-unread group)))
                 (when (and (not (string-match "^\\(\\(nnimap\\+\\)?Mail:\\)?" group))
                            (numberp unread) (> unread 0))
                   (ignore-errors
                     (gnus-summary-read-group group nil t))
                   (when (and gnus-summary-buffer
                              (buffer-live-p gnus-summary-buffer)
                              (eq (current-buffer)
                                  (get-buffer gnus-summary-buffer)))
                     (gnus-summary-exit))))))))
       
   ;;;_ + Summary line formats
       
       (defun gnus-user-format-function-Z (header)
         (let ((to (cdr (assq 'To (mail-header-extra header))))
               (newsgroups (cdr (assq 'Newsgroups (mail-header-extra header))))
               (mail-parse-charset gnus-newsgroup-charset)
               (mail-parse-ignored-charsets
                (with-current-buffer gnus-summary-buffer
                  gnus-newsgroup-ignored-charsets)))
           (cond
            ((and to gnus-ignored-from-addresses
                  (string-match gnus-ignored-from-addresses
                                (mail-header-from header)))
             (concat "-> "
                     (or (car (funcall gnus-extract-address-components
                                       (funcall
                                        gnus-decode-encoded-word-function to)))
                         (funcall gnus-decode-encoded-word-function to))))
            ((and newsgroups gnus-ignored-from-addresses
                  (string-match gnus-ignored-from-addresses
                                (mail-header-from header)))
             (concat "=> " newsgroups))
            (t
             (let* ((from (mail-header-from header))
                    (data (condition-case nil
                              (mail-extract-address-components from)
                            (error nil)))
                    (name (car data))
                    (net (car (cdr data))))
               (or name net))))))
       
       (defsubst dot-gnus-tos (time)
         "Convert TIME to a floating point number."
         (+ (* (car time) 65536.0)
            (cadr time)
            (/ (or (car (cdr (cdr time))) 0) 1000000.0)))
       
       (defun gnus-user-format-function-S (header)
         "Return how much time it's been since something was sent."
         (condition-case err
             (let ((date (mail-header-date header)))
               (if (> (length date) 0)
                   (let* ((then (dot-gnus-tos
                                 (apply 'encode-time (parse-time-string date))))
                          (now (dot-gnus-tos (current-time)))
                          (diff (- now then)))
                     (cond ((>= diff (* 86400.0 7.0 52.0))
                            (if (>= diff (* 86400.0 7.0 52.0 10.0))
                                (format "%3dY" (floor (/ diff (* 86400.0 7.0 52.0))))
                              (format "%3.1fY" (/ diff (* 86400.0 7.0 52.0)))))
                           ((>= diff (* 86400.0 30.0))
                            (if (>= diff (* 86400.0 30.0 10.0))
                                (format "%3dM" (floor (/ diff (* 86400.0 30.0))))
                              (format "%3.1fM" (/ diff (* 86400.0 30.0)))))
                           ((>= diff (* 86400.0 7.0))
                            (if (>= diff (* 86400.0 7.0 10.0))
                                (format "%3dw" (floor (/ diff (* 86400.0 7.0))))
                              (format "%3.1fw" (/ diff (* 86400.0 7.0)))))
                           ((>= diff 86400.0)
                            (if (>= diff (* 86400.0 10.0))
                                (format "%3dd" (floor (/ diff 86400.0)))
                              (format "%3.1fd" (/ diff 86400.0))))
                           ((>= diff 3600.0)
                            (if (>= diff (* 3600.0 10.0))
                                (format "%3dh" (floor (/ diff 3600.0)))
                              (format "%3.1fh" (/ diff 3600.0))))
                           ((>= diff 60.0)
                            (if (>= diff (* 60.0 10.0))
                                (format "%3dm" (floor (/ diff 60.0)))
                              (format "%3.1fm" (/ diff 60.0))))
                           (t
                            (format "%3ds" (floor diff)))))))
           (error "    ")))
       
       (eval-when-compile
         (defvar thread)
         (defvar gnus-tmp-level))
       
       (defun gnus-user-format-function-t-johnw (header)
         (let ((tcount (gnus-summary-number-of-articles-in-thread
                        (and (boundp 'thread) (car thread)) gnus-tmp-level)))
           (if (> tcount 1)
               (number-to-string tcount)
             " ")))
       
   ;;;_ + gnus-article-browse-urls
       
       (defun gnus-article-browse-urls ()
         "Visit a URL from the `gnus-article-buffer' by prompting via a
       poping up a buffer showing the list of URLs found with the
       `gnus-button-url-regexp'."
         (interactive)
         (gnus-configure-windows 'article)
         (gnus-summary-select-article nil nil 'pseudo)
         (let ((temp-buffer (generate-new-buffer " *Article URLS*"))
               (urls (gnus-article-get-current-urls))
               (this-window (selected-window))
               (browse-window (get-buffer-window gnus-article-buffer))
               (count 0))
           (save-excursion
             (save-window-excursion
               (set-buffer temp-buffer)
               (mapc (lambda (string)
                       (insert (format "\t%d: %s\n" count string))
                       (setq count (1+ count))) urls)
               (not-modified)
               (pop-to-buffer temp-buffer)
               (setq count
                     (string-to-number
                      (char-to-string (if (fboundp
                                           'read-char-exclusive)
                                          (read-char-exclusive)
                                        (read-char)))))
               (kill-buffer temp-buffer))
             (if browse-window
                 (progn (select-window browse-window)
                        (browse-url (nth count urls)))))
           (select-window this-window)))
       
       (defun gnus-article-get-current-urls ()
         "Return a list of the urls found in the current `gnus-article-buffer'"
         (let (url-list)
           (with-current-buffer gnus-article-buffer
             (setq url-list (gnus-article-get-urls-region (point-min) (point-max))))
           url-list))
       
       (defun gnus-article-get-urls-region (min max)
         "Return a list of urls found in the region between MIN and MAX"
         (let (url-list)
           (save-excursion
             (save-restriction
               (narrow-to-region min max)
               (goto-char (point-min))
               (while (re-search-forward gnus-button-url-regexp nil t)
                 (let ((match-string (match-string-no-properties 0)))
                   (if (and (not (equal (substring match-string 0 4) "file"))
                            (not (member match-string url-list)))
                       (setq url-list (cons match-string url-list)))))))
           url-list))
       
       
   ;;;_* keybindings
       
   ;;;_ + gnus-group-score
       
       (eval-after-load "gnus-group"
         '(progn
            (bind-key "s" 'gnus-score-groups gnus-group-score-map)
            (bind-key "v o" 'start-offlineimap gnus-group-mode-map)))
       
       (eval-after-load "w3m"
         '(bind-key "\C-m" 'w3m-view-url-with-external-browser w3m-minor-mode-map))
       
   ;;;_ + dave's stuff
       
       (defun dwa/gnus-summary-ignore-thread ()
         (interactive)
         (gnus-summary-top-thread)
         (let ((message-id (gnus-summary-header "message-id")))
           (dolist (hdr-type '(("references" . s) ("message-id" . e)))
             (gnus-summary-score-entry
              (car hdr-type)                       ; Header
              (gnus-summary-header "message-id")   ; Match
              (cdr hdr-type)                       ; Type
              (- (gnus-score-delta-default nil))   ; Score
              nil                                  ; Temp
              nil                                  ; Prompt
              nil                                  ; not silent
              nil)))                               ; non-standard overview.
         (gnus-summary-kill-thread))
       (bind-key "i" 'dwa/gnus-summary-ignore-thread gnus-summary-mode-map)
       
       ;;
       ;; Support proportional fonts in the summary and group buffers by inserting a forced alignment
       ;;
       ;; See http://news.gmane.org/find-root.php?message_id=%3cyoij63rj41q5.fsf%40remote5.student.chalmers.se%3e
       (defvar my-align-gnus-summary (propertize " " 'display '(space :align-to 5)))
       (defvar my-align-gnus-subject (propertize " " 'display '(space :align-to 30)))
       
       (defvar my-align-gnus-group (propertize " " 'display '(space :align-to 8)))
       
       
       ;; Display word docs inline with antiword installed.  See
       ;; http://www.emacswiki.org/emacs/MimeTypesWithGnus
       (when nil
         (require 'mm-view)
         (add-to-list 'mm-inline-media-tests
                      '("application/msword" mm-inline-text identity))
         (add-to-list 'mm-automatic-external-display "application/msword")
         (add-to-list 'mm-attachment-override-types "application/msword")
         (add-to-list 'mm-automatic-display "application/msword"))
       
       (defun dwa/gnus-summary-first-unread-or-first-subject ()
         "Place the point on the subject line of the first unseen article.
   If all article have been seen, on the subject line of the last article."
         (interactive)
         (prog1
             (unless
                 (when (gnus-summary-first-subject t nil t)
                   (gnus-summary-show-thread)
                   (gnus-summary-first-subject t nil t))
               (goto-char (point-min)))))
       (setq gnus-auto-select-subject 'dwa/gnus-summary-first-unread-or-first-subject)
       
                                           ;(require 'gnus-spec)
                                           ;(eval-when-compile (gnus-compile))
       
       (require 'gravatar nil 'noerror)
       (require 'gnus-gravatar nil 'noerror)
       (spam-initialize)
       (bind-key "$" 'gnus-summary-mark-as-spam gnus-summary-mode-map)
       (bind-key "v o" 'start-offlineimap gnus-summary-mode-map)
       
       
       (defvar my-gnus-group-faces
         '(
           gnus-group-news-1
           gnus-group-news-1-empty
           gnus-group-news-2
           gnus-group-news-2-empty
           gnus-group-news-3
           gnus-group-news-3-empty
           gnus-group-news-4
           gnus-group-news-4-empty
           gnus-group-news-5
           gnus-group-news-5-empty
           gnus-group-news-6
           gnus-group-news-6-empty
           gnus-group-news-low
           gnus-group-news-low-empty
           gnus-group-mail-1
           gnus-group-mail-1-empty
           gnus-group-mail-2
           gnus-group-mail-2-empty
           gnus-group-mail-3
           gnus-group-mail-3-empty
           gnus-group-mail-low
           gnus-group-mail-low-empty))
       
       (defvar my-gnus-summary-faces
         '(
           gnus-summary-selected
           gnus-summary-cancelled
           gnus-summary-high-ticked
           gnus-summary-low-ticked
           gnus-summary-normal-ticked
           gnus-summary-high-ancient
           gnus-summary-low-ancient
           gnus-summary-normal-ancient
           gnus-summary-high-undownloaded
           gnus-summary-low-undownloaded
           gnus-summary-normal-undownloaded
           gnus-summary-high-unread
           gnus-summary-low-unread
           gnus-summary-normal-unread
           gnus-summary-high-read
           gnus-summary-low-read
           gnus-summary-normal-read
           gnus-summary-expirable-face))
       
                                           ;(defvar my-gnus-group-face-attributes '(:family "DejaVu Sans" :weight normal :width condensed))
       (defvar my-gnus-summary-face-attributes '(:family "DejaVu Sans" :weight normal :width condensed))
       
                                           ;(dolist (facename my-gnus-group-faces)
                                           ;  (apply 'set-face-attribute facename nil my-gnus-group-face-attributes))
       (dolist (facename my-gnus-summary-faces)
         (when (facep facename)
           (apply 'set-face-attribute facename nil my-gnus-summary-face-attributes)))
       
       (defface gnus-summary-expirable-face
         '((((class color) (background dark))
            (:foreground "grey50" :italic t :strike-through t))
           (((class color) (background light))
            (:foreground "grey55" :italic t :strike-through t)))
         "Face used to highlight articles marked as expirable."
         :group 'gnus-summary-visual)
       
       ;; prettier summary buffers
       (when window-system
         (setq gnus-sum-thread-tree-indent "  ")                            ;; "  "
         (setq gnus-sum-thread-tree-root "\u229e ")                         ;; "⊞ "
         (setq gnus-sum-thread-tree-false-root "\u22a1 ")                   ;; "⊡ "
         (setq gnus-sum-thread-tree-single-indent   " -  ")              ;; " -  "
         (setq gnus-sum-thread-tree-vertical        " \u2502")              ;; " │"
         (setq gnus-sum-thread-tree-leaf-with-other " \u251c\u2500 ")  ;; " ├─ "
         (setq gnus-sum-thread-tree-single-leaf     " \u2570\u2500 ")) ;; " ╰─ "
       
       
       ;; Make sure cited text has a light gray background, in case people
       ;; forget to add a blank line after their citations.
       (use-package gnus-cite)
       
       ;; Thanks to David Engster
       ;; [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.gnus.general#87vdnimyxd.fsf@randomsample.de][Posting on ding@gnus.org]]
       (defun DE-collapse-group-names ()
         (save-excursion
           (let (previous-group current-group common-prefix
                                common-dot-count prefix suffix)
             (goto-char (point-min))
             (while (not (eobp))
               (when (setq current-group
                           (get-text-property (point) 'gnus-group))
                 (setq current-group (symbol-name current-group))
                 (when (string-match "\\(.+\\):\\(.+\\)" current-group)
                   (setq current-group (match-string 2 current-group)))
                 (setq common-prefix (substring current-group 0
                                                (mismatch previous-group current-group))
                       common-dot-count (count ?. common-prefix)
                       prefix (mapconcat (lambda (x) x)
                                         (make-list common-dot-count "  .") "")
                       suffix (and (string-match
                                    (format "\\([^.]*[.]\\)\\{%d\\}\\(.+\\)" common-dot-count)
                                    current-group)
                                   (match-string 2 current-group))
                       previous-group current-group)
                 (unless (zerop (length prefix))
                   (when (search-forward current-group (point-at-eol) t)
                     (let ((props (text-properties-at (1- (point)))))
                       (replace-match (apply 'propertize (concat prefix suffix)
                                             props))))))
               (forward-line 1)))))
       
       (add-hook 'gnus-group-prepare-hook 'DE-collapse-group-names)
       (add-hook 'gnus-group-update-group-hook 'DE-collapse-group-names)
       
       ;; Queueing messages in Gnus (instead of Postfix) when
       ;; disconnected:
       
       ;; uncomment to enable
       ;; (add-hook 'message-send-hook 'queue-message-if-not-connected)
       
       (defun quickping (host)
         (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))
       
       (defun queue-message-if-not-connected ()
         (set (make-local-variable 'gnus-agent-queue-mail)
              (if (quickping "smtp.gmail.com") t 'always)))
       ;;
       ;;
       
       ;; I like citations in email to be set off from the rest of the text
       ;; by a slightly different background color.  This helps immeasurably
       ;; when people forget to leave a blank line after citations.  see
       ;; gnus-settings.el and wl-settings.el, where I inherit this face.
       (defface dwa/mail-citation '((((class color)
                                      (background dark))
                                     (:background "#383838"))
                                    (((class color)
                                      (background light))
                                     (:background "#efefef")))
         "Mail citation base face.")))
   
 #+end_src

*** orgstruct mode for mail
:PROPERTIES:
:tangle:   no
:END:

from org-mode.org

=orgstruct++-mode= is enabled in =Gnus= message buffers to aid in
creating structured email messages.

#+begin_src emacs-lisp :tangle yes
(add-hook 'message-mode-hook 'orgstruct++-mode 'append)
(add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
(add-hook 'mail-setup-hook 'bbdb-mail-aliases)
;;(add-hook 'message-mode-hook 'bbdb-define-all-aliases 'append)
(add-hook 'message-mode-hook 'orgtbl-mode 'append)
(add-hook 'message-mode-hook 'turn-on-flyspell 'append)
(add-hook 'message-mode-hook
          '(lambda () (setq fill-column 72))
          'append)
(add-hook 'message-mode-hook
          '(lambda () (local-set-key (kbd "C-c M-o") 'org-mime-htmlize))
          'append)
#+end_src






*** graphviz
:PROPERTIES:
:tangle:   no
:END:
   #+begin_src emacs-lisp 
   (use-package graphviz-dot-mode)   
  #+end_src
*** grep
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , grep

(use-package grep
  :bind (("M-s d" . find-grep-dired)
         ("M-s f" . find-grep)
         ("M-s g" . grep)
         ("M-s r" . rgrep))
  :init
  (progn
    (defun find-grep-in-project (command-args)
      (interactive
       (let ((default (thing-at-point 'symbol)))
         (list (read-shell-command "Run find (like this): "
                                   (cons (concat "git --no-pager grep -n "
                                                 default)
                                         (+ 24 (length default)))
                                   'grep-find-history))))
      (if command-args
          (let ((null-device nil))      ; see grep
            (grep command-args))))

    (bind-key "M-s p" 'find-grep-in-project))

  :config
  (progn
    (use-package grep-ed)

    (grep-apply-setting 'grep-command "egrep -nH -e ")
    (grep-apply-setting
     'grep-find-command
     '("find . -type f -print0 | xargs -P4 -0 egrep -nH -e " . 52))))

#+end_src

*** gtags
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , gtags

(use-package gtags
  :commands gtags-mode
  :diminish gtags-mode
  :config
  (progn
    (defun my-gtags-or-semantic-find-tag ()
      (interactive)
      (if (and (fboundp 'semantic-active-p)
               (funcall #'semantic-active-p))
          (call-interactively #'semantic-complete-jump)
        (call-interactively #'gtags-find-tag)))

    (bind-key "M-." 'my-gtags-or-semantic-find-tag gtags-mode-map)

    (bind-key "C-c t ." 'gtags-find-rtag)
    (bind-key "C-c t f" 'gtags-find-file)
    (bind-key "C-c t p" 'gtags-parse-file)
    (bind-key "C-c t g" 'gtags-find-with-grep)
    (bind-key "C-c t i" 'gtags-find-with-idutils)
    (bind-key "C-c t s" 'gtags-find-symbol)
    (bind-key "C-c t r" 'gtags-find-rtag)
    (bind-key "C-c t v" 'gtags-visit-rootdir)

    (bind-key "<mouse-2>" 'gtags-find-tag-from-here gtags-mode-map)

    (use-package helm-gtags
      :bind ("M-T" . helm-gtags-select)
      :config
      (bind-key "M-," 'helm-gtags-resume gtags-mode-map))))

#+end_src
*** gud
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , gud

(use-package gud
  :commands gud-gdb
  :init
  (progn
    (defun show-debugger ()
      (interactive)
      (let ((gud-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*gud-" (buffer-name buf))
                     (throw 'found buf))))))
        (if gud-buf
            (switch-to-buffer-other-window gud-buf)
          (call-interactively 'gud-gdb))))

    (bind-key "C-. g" 'show-debugger))

  :config
  (progn
    (bind-key "<f9>" 'gud-cont)
    (bind-key "<f10>" 'gud-next)
    (bind-key "<f11>" 'gud-step)
    (bind-key "S-<f11>" 'gud-finish)))

#+end_src
*** haskell-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , haskell-mode

(require 'haskell-config)

#+end_src
*** helm
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , helm

(use-package helm-config
  :if (not running-alternate-emacs)
  :init
  (progn
    (bind-key "C-c M-x" 'helm-M-x)
    (bind-key "C-h a" 'helm-c-apropos)
    (bind-key "M-s a" 'helm-do-grep)
    (bind-key "M-s b" 'helm-occur)
    (bind-key "M-s F" 'helm-for-files)

    (use-package helm-commands)

    (bind-key "C-h e a" 'my-helm-apropos)
    (bind-key "C-x M-!" 'helm-command-from-zsh)
    (bind-key "C-x f" 'helm-find-git-file)

    (use-package helm-descbinds
      :commands helm-descbinds
      :init
      (fset 'describe-bindings 'helm-descbinds))

    (bind-key "C-h b" 'helm-descbinds))

  :config
  (helm-match-plugin-mode t))

#+end_src

#+results:
: t

*** hi-lock
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , hi-lock

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))

#+end_src
*** hilit-chg
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , hilit-chg

(use-package hilit-chg
  :bind ("M-o C" . highlight-changes-mode))

#+end_src
*** hl-line
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , hl-line

(use-package hl-line
  :bind ("M-o h" . hl-line-mode)
  :config
  (use-package hl-line+))

#+end_src
*** ido
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ido

(use-package ido
  :defines (ido-cur-item
            ido-require-match
            ido-selected
            ido-final-text
            ido-show-confirm-message)
  :init
  (ido-mode t)

  :config
  (progn
    (use-package ido-hacks
      :init
      (ido-hacks-mode 1))

    (use-package ido-springboard)

    (defun ido-smart-select-text ()
      "Select the current completed item.  Do NOT descend into directories."
      (interactive)
      (when (and (or (not ido-require-match)
                     (if (memq ido-require-match
                               '(confirm confirm-after-completion))
                         (if (or (eq ido-cur-item 'dir)
                                 (eq last-command this-command))
                             t
                           (setq ido-show-confirm-message t)
                           nil))
                     (ido-existing-item-p))
                 (not ido-incomplete-regexp))
        (when ido-current-directory
          (setq ido-exit 'takeprompt)
          (unless (and ido-text (= 0 (length ido-text)))
            (let ((match (ido-name (car ido-matches))))
              (throw 'ido
                     (setq ido-selected
                           (if match
                               (replace-regexp-in-string "/\\'" "" match)
                             ido-text)
                           ido-text ido-selected
                           ido-final-text ido-text)))))
        (exit-minibuffer)))

    (add-hook 'ido-minibuffer-setup-hook
              #'(lambda ()
                  (bind-key "C-<return>" 'ido-smart-select-text
                            ido-file-completion-map)))

    (defun ido-switch-buffer-tiny-frame (buffer)
      (interactive (list (ido-read-buffer "Buffer: " nil t)))
      (with-selected-frame
          (make-frame '((width                . 80)
                        (height               . 22)
                        (left-fringe          . 0)
                        (right-fringe         . 0)
                        (vertical-scroll-bars . nil)
                        (unsplittable         . t)
                        (has-modeline-p       . nil)
                        ;;(background-color     . "grey80")
                        (minibuffer           . nil)))
        (switch-to-buffer buffer)
        (set (make-local-variable 'mode-line-format) nil)))

    (bind-key "C-x 5 t" 'ido-switch-buffer-tiny-frame))

  (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
  (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
  (defun ido-sort-mtime ()
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                        (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (ido-to-end  ;; move . files to end (again)
     (delq nil (mapcar
                (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                ido-temp-list)))))

#+end_src


*** iedit
#+begin_src emacs-lisp
  (use-package iedit
:init (progn
(defun iedit-dwim (arg)
  "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
  (interactive "P")
  (if arg
      (iedit-mode)
    (save-excursion
      (save-restriction
        (widen)
        ;; this function determines the scope of `iedit-start'.
        (narrow-to-defun)
        (if iedit-mode
            (iedit-done)
          ;; `current-word' can of course be replaced by other
          ;; functions.
          (iedit-start (current-word)))))))

(bind-key "H-;" 'iedit-dwim)
)


)

#+end_src

*** ielm
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ielm

(use-package ielm
  :bind ("C-c :" . ielm)
  :config
  (progn
    (defun my-ielm-return ()
      (interactive)
      (let ((end-of-sexp (save-excursion
                           (goto-char (point-max))
                           (skip-chars-backward " \t\n\r")
                           (point))))
        (if (>= (point) end-of-sexp)
            (progn
              (goto-char (point-max))
              (skip-chars-backward " \t\n\r")
              (delete-region (point) (point-max))
              (call-interactively #'ielm-return))
          (call-interactively #'paredit-newline))))

    (add-hook 'ielm-mode-hook
              (function
               (lambda ()
                 (bind-key "<return>" 'my-ielm-return ielm-map)))
              t)))

#+end_src
*** image-file
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , image-file

(use-package image-file
  :init
  (auto-image-file-mode 1))

#+end_src
*** info
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , info

(use-package info
  :bind ("C-h C-i" . info-lookup-symbol)
  :init
  (remove-hook 'menu-bar-update-hook 'mac-setup-help-topics)

  :config
  (progn
    (defadvice info-setup (after load-info+ activate)
      (use-package info+))

    (defadvice Info-exit (after remove-info-window activate)
      "When info mode is quit, remove the window."
      (if (> (length (window-list)) 1)
          (delete-window)))))

(use-package info-look
  :commands info-lookup-add-help)
#+end_src

**** getting info directories right
#+TBLNAME: info-dirs
| /Users/tonyday/.emacs.d/info |
| /usr/share/info/             |
| ~/.emacs.d/site-lisp/auctex/doc      |

  #+begin_src emacs-lisp :var table=info-dirs
     (setq clean-table
           (delete nil  
                   (loop for line in table
                         collect 
                         (delete "" (delete-dups line)))))
    (setq Info-default-directory-list (apply #'append clean-table))
    (setq Info-directory-list Info-default-directory-list)
  #+end_src

  #+results:
  | /Users/tonyday/.emacs.d/info | /usr/share/info/ | ~/.emacs.d/site-lisp/auctex/doc |

**** checks
#+begin_src emacs-lisp :tangle no
  (getenv "INFOPATH")
#+end_src

#+begin_src emacs-lisp :tangle no
  (print (loop for f in Info-default-directory-list
               collect
               (list f)))
#+end_src

*** indirect
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , indirect

(use-package indirect
  :bind ("C-c C" . indirect-region))

#+end_src
*** initsplit
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , initsplit

(eval-after-load "cus-edit"
  '(use-package initsplit))

#+end_src
*** ipa
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ipa

(use-package ipa
  :commands ipa-insert
  :init
  (progn
    (autoload 'ipa-load-annotations-into-buffer "ipa")
    (add-hook 'find-file-hook 'ipa-load-annotations-into-buffer)))

#+end_src
*** js2-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , js2-mode

(use-package js2-mode
  :mode ("\\.js\\'" . js2-mode))

#+end_src
*** keyfreq
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
  (use-package keyfreq
    :init
    (progn
      (keyfreq-mode 1)
      (keyfreq-autosave-mode 1)))
#+end_src

*** ledger
#+begin_src emacs-lisp
;;;_ , ledger

(use-package "ldg-new"
  :commands ledger-mode
  :init
  (progn
    (defun my-ledger-start-entry (&optional arg)
      (interactive "p")
      (find-file-other-window "~/Documents/Accounts/ledger.dat")
      (goto-char (point-max))
      (skip-syntax-backward " ")
      (if (looking-at "\n\n")
          (goto-char (point-max))
        (delete-region (point) (point-max))
        (insert ?\n)
        (insert ?\n))
      (insert (format-time-string "%Y/%m/%d ")))

    (bind-key "C-c L" 'my-ledger-start-entry)

    (defun ledger-matchup ()
      (interactive)
      (while (re-search-forward "\\(\\S-+Unknown\\)\\s-+\\$\\([-,0-9.]+\\)"
                                nil t)
        (let ((account-beg (match-beginning 1))
              (account-end (match-end 1))
              (amount (match-string 2))
              account answer)
          (goto-char account-beg)
          (set-window-point (get-buffer-window) (point))
          (recenter)
          (redraw-display)
          (with-current-buffer (get-buffer "nrl-mastercard-old.dat")
            (goto-char (point-min))
            (when (re-search-forward (concat "\\(\\S-+\\)\\s-+\\$" amount)
                                     nil t)
              (setq account (match-string 1))
              (goto-char (match-beginning 1))
              (set-window-point (get-buffer-window) (point))
              (recenter)
              (redraw-display)
              (setq answer
                    (read-char (format "Is this a match for %s (y/n)? "
                                       account)))))
          (when (eq answer ?y)
            (goto-char account-beg)
            (delete-region account-beg account-end)
            (insert account))
          (forward-line))))))

#+end_src
*** lisp-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , lisp-mode

;; Utilities every Emacs Lisp coders should master:
;;
;;   paredit          Let's you manipulate sexps with ease
;;   redshank         Think: Lisp refactoring
;;   edebug           Knowing the traditional debugger is good too
;;   eldoc
;;   cldoc
;;   elint
;;   elp
;;   ert

(use-package lisp-mode
  ;; :load-path "site-lisp/slime/contrib/"
  :init
  (progn
    (defface esk-paren-face
      '((((class color) (background dark))
         (:foreground "grey50"))
        (((class color) (background light))
         (:foreground "grey55")))
      "Face used to dim parentheses."
      :group 'starter-kit-faces)

    ;; Change lambda to an actual lambda symbol
    (mapc (lambda (major-mode)
            (font-lock-add-keywords
             major-mode
             '(("(\\(lambda\\)\\>"
                (0 (ignore
                    (compose-region (match-beginning 1)
                                    (match-end 1) ?λ))))
               ("(\\|)" . 'esk-paren-face)
               ("(\\(ert-deftest\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+\\|\\sw+\\)?"
                (1 font-lock-keyword-face)
                (2 font-lock-function-name-face
                 nil t)))))
          lisp-modes)

    (defvar slime-mode nil)
    (defvar lisp-mode-initialized nil)

    (defun initialize-lisp-mode ()
      (unless lisp-mode-initialized
        (setq lisp-mode-initialized t)

        (use-package redshank
          :diminish redshank-mode)

        (use-package elisp-slime-nav
          :diminish elisp-slime-nav-mode)

        (use-package edebug)

        (use-package eldoc
          :diminish eldoc-mode
          :defer t
          :init
          (use-package eldoc-extension
            :disabled t
            :defer t
            :init
            (add-hook 'emacs-lisp-mode-hook
                      #'(lambda () (require 'eldoc-extension)) t))

          :config
          (eldoc-add-command 'paredit-backward-delete
                             'paredit-close-round))

        (use-package cldoc
          :diminish cldoc-mode)

        (use-package ert
          :commands ert-run-tests-interactively
          :bind ("C-c e t" . ert-run-tests-interactively))

        (use-package elint
          :commands 'elint-initialize
          :init
          (defun elint-current-buffer ()
            (interactive)
            (elint-initialize)
            (elint-current-buffer))

          :config
          (progn
            (add-to-list 'elint-standard-variables 'current-prefix-arg)
            (add-to-list 'elint-standard-variables 'command-line-args-left)
            (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
            (add-to-list 'elint-standard-variables 'emacs-major-version)
            (add-to-list 'elint-standard-variables 'window-system)))

        (use-package highlight-cl
          :init
          (mapc (function
                 (lambda (mode-hook)
                   (add-hook mode-hook
                             'highlight-cl-add-font-lock-keywords)))
                lisp-mode-hooks))

        (defun my-elisp-indent-or-complete (&optional arg)
          (interactive "p")
          (call-interactively 'lisp-indent-line)
          (unless (or (looking-back "^\\s-*")
                      (bolp)
                      (not (looking-back "[-A-Za-z0-9_*+/=<>!?]+")))
            (call-interactively 'lisp-complete-symbol)))

        (defun my-lisp-indent-or-complete (&optional arg)
          (interactive "p")
          (if (or (looking-back "^\\s-*") (bolp))
              (call-interactively 'lisp-indent-line)
            (call-interactively 'slime-indent-and-complete-symbol)))

        (defun my-byte-recompile-file ()
          (save-excursion
            (byte-recompile-file buffer-file-name)))

        ;; Register Info manuals related to Lisp
        (use-package info-lookmore
          :init
          (progn
            (info-lookmore-elisp-cl)
            (info-lookmore-elisp-userlast)
            (info-lookmore-elisp-gnus)
            (info-lookmore-apropos-elisp)))

        (mapc (lambda (mode)
                (info-lookup-add-help
                 :mode mode
                 :regexp "[^][()'\" \t\n]+"
                 :ignore-case t
                 :doc-spec '(("(ansicl)Symbol Index" nil nil nil))))
              lisp-modes)))

    (defun my-lisp-mode-hook ()
      (initialize-lisp-mode)

      (auto-fill-mode 1)
      (paredit-mode 1)
      (redshank-mode 1)
      (elisp-slime-nav-mode 1)

      (local-set-key (kbd "<return>") 'paredit-newline)

      (if (memq major-mode
                '(emacs-lisp-mode inferior-emacs-lisp-mode ielm-mode))
          (progn
            (bind-key "<M-return>" 'outline-insert-heading emacs-lisp-mode-map)
            (bind-key "<tab>" 'my-elisp-indent-or-complete emacs-lisp-mode-map))
        (turn-on-cldoc-mode)

        (bind-key "<tab>" 'my-lisp-indent-or-complete lisp-mode-map)
        (bind-key "M-q" 'slime-reindent-defun lisp-mode-map)
        (bind-key "M-l" 'slime-selector lisp-mode-map))

      (yas/minor-mode 1))

    (hook-into-modes #'my-lisp-mode-hook lisp-mode-hooks)))

#+end_src
*** llvm-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , llvm-mode

(use-package llvm-mode
  :mode ("\\.ll\\'" . llvm-mode))

#+end_src
*** log4j-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , log4j-mode

(use-package log4j-mode
  :disabled t
  :mode ("\\.log\\'" . log4j-mode))

#+end_src
*** lua-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , lua-mode

(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode)
  :interpreter ("lua" . lua-mode))

#+end_src
*** lusty-explorer
    :PROPERTIES:
    :tangle:   no
    :END:
#+begin_src emacs-lisp
;;;_ , lusty-explorer

(use-package lusty-explorer
  :bind ("C-x C-f" . lusty-file-explorer)
  :config
  (progn
    (add-hook 'lusty-setup-hook
              (lambda ()
                (bind-key "SPC" 'lusty-select-match lusty-mode-map)
                (bind-key "C-d" 'exit-minibuffer lusty-mode-map)))

    (defun lusty-open-this ()
      "Open the given file/directory/buffer, creating it if not already present."
      (interactive)
      (when lusty--active-mode
        (ecase lusty--active-mode
          (:file-explorer
           (let* ((path (minibuffer-contents-no-properties))
                  (last-char (aref path (1- (length path)))))
             (lusty-select-match)
             (lusty-select-current-name)))
          (:buffer-explorer (lusty-select-match)))))

    (defvar lusty-only-directories nil)

    (defun lusty-file-explorer-matches (path)
      (let* ((dir (lusty-normalize-dir (file-name-directory path)))
             (file-portion (file-name-nondirectory path))
             (files
              (and dir
                   ;; NOTE: directory-files is quicker but
                   ;;       doesn't append slash for directories.
                   ;;(directory-files dir nil nil t)
                   (file-name-all-completions "" dir)))
             (filtered (lusty-filter-files
                        file-portion
                        (if lusty-only-directories
                            (loop for f in files
                                  when (= ?/ (aref f (1- (length f))))
                                  collect f)
                          files))))
        (if (or (string= file-portion "")
                (string= file-portion "."))
            (sort filtered 'string<)
          (lusty-sort-by-fuzzy-score filtered file-portion))))

    (defun lusty-read-directory ()
      "Launch the file/directory mode of LustyExplorer."
      (interactive)
      (let ((lusty--active-mode :file-explorer))
        (lusty--define-mode-map)
        (let* ((lusty--ignored-extensions-regex
                (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
               (minibuffer-local-filename-completion-map lusty-mode-map)
               (lusty-only-directories t))
          (lusty--run 'read-directory-name default-directory ""))))

    (defun lusty-read-file-name ()
      "Launch the file/directory mode of LustyExplorer."
      (interactive)
      (let ((lusty--active-mode :file-explorer))
        (lusty--define-mode-map)
        (let* ((lusty--ignored-extensions-regex
                (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
               (minibuffer-local-filename-completion-map lusty-mode-map)
               (lusty-only-directories nil))
          (lusty--run 'read-file-name default-directory ""))))

    (if (featurep 'icicles)
        (defadvice lusty-file-explorer (around lusty-file-explorer-without-icy
                                               activate)
          (cl-flet ((message (&rest ignore)))
            (let ((icy-was-on icicle-mode))
              (if icy-was-on (icy-mode 0))
              (unwind-protect
                  ad-do-it
                (if icy-was-on (icy-mode 1)))))))))

#+end_src
*** macrostep
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , macrostep

(use-package macrostep
  :bind ("C-c e m" . macrostep-expand))

#+end_src
*** magit
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
    ;;;_ , magit
    
    (use-package magit
      :bind ("C-x g" . magit-status)
      :defer t
      :config
      (progn
        (setenv "GIT_PAGER" "")
    
        (add-hook 'magit-log-edit-mode-hook
                  #'(lambda ()
                      (set-fill-column 72)
                      (flyspell-mode)))
    
        (use-package magit-topgit)
        (use-package rebase-mode)
        (use-package magithub)
        (use-package org-magit)))
    
#+end_src

#+name: git-repos
| ~/git/hft                   |
| ~/stuff                     |
| ~/.emacs.d                  |
| ~/git/o-blog                |
| ~/projects/opoker           |
| ~/projects/alice            |
| ~/projects/metalice         |
| ~/projects/fgr              |
| ~/git/tonyday567.github.com |


#+begin_src emacs-lisp :var table=git-repos  
     (setq magit-repo-dirs
           (loop for file in table
                     collect (car file)))
#+end_src

#+results:
| ~/git/hft | ~/stuff | ~/.emacs.d | ~/git/o-blog | ~/projects/opoker | ~/projects/alice | ~/projects/metalice | ~/projects/fgr | ~/git/tonyday567.github.com |

*** markdown-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , markdown-mode

(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :init
  (progn
    (defun markdown-preview-file ()
      "run Marked on the current file and revert the buffer"
      (interactive)
      (shell-command
       (format "open -a /Applications/Marked.app %s"
               (shell-quote-argument (buffer-file-name)))))

    (bind-key "C-x M" 'markdown-preview-file)))

#+end_src

http://lucindo.com.br/lisp/milki/markdown.html

*** merlin
#+begin_src emacs-lisp
;;;_ , merlin

(defun merlin-record-times ()
  (interactive)
  (require 'rx)
  (let* ((text (buffer-substring-no-properties (line-beginning-position)
                                               (line-end-position)))
         (regex
          (rx (and string-start (0+ space)
                   (group (and (= 2 num) ?/ (= 2 num) ?/ (= 2 num)
                               space (= 2 num) ?: (= 2 num) space
                               (in "AP") ?M)) (1+ space)
                   (group (and (= 2 num) ?/ (= 2 num) ?/ (= 2 num)
                               space (= 2 num) ?: (= 2 num) space
                               (in "AP") ?M)) (1+ space)
                   (? (and (group ?*) (1+ space)))
                   (group (1+ (or digit (in ".hms"))))
                   (1+ space) (group (1+ nonl)) string-end))))
    (if (string-match regex text)
        (let ((start (match-string 1 text))
              (end (match-string 2 text))
              (cleared (match-string 3 text))
              (duration (match-string 4 text)) commodity
              (account (match-string 5 text)))
          (when (string-match "\\([0-9.]+\\)\\([mhs]\\)" duration)
            (setq commodity (match-string 2 duration)
                  duration (match-string 1 duration))
            (cond ((string= commodity "h")
                   (setq commodity "hours"))
                  ((string= commodity "m")
                   (setq commodity "minutes"))
                  ((string= commodity "s")
                   (setq commodity "seconds"))))
          (if (string-match "\\([0-9.][0-9.a-z]+\\)" account)
              (setq account (match-string 1 account)))
          (do-applescript
           (format
            "
          tell application \"Merlin\"
          activate

          set act to 0

          set listActivity to every activity of first document
          repeat with oneActivity in listActivity
          if subtitle of oneActivity is \"%s\" then
          set act to oneActivity
          exit repeat
          end if
          end repeat

          if act is 0 then
          set myselection to selected object of main window of first document as list

          if (count of myselection) is 0 then
          display dialog \"Please select activity to set time for\" buttons {\"OK\"}
          else
          set act to beginning of myselection
          end if
          end if

          if act is 0 or (class of act is project) or (is milestone of act is true) then
          display dialog \"Cannot locate activity for %s\" buttons {\"OK\"}
          else
          tell act
          if ((class is not project) and (is milestone is not true)) then
          set actual start date to (date \"%s\")
          if %s then
          set actual end date to (date \"%s\")
          delete last actuals reporting date

          set given remaining work to {amount:0, unit:hours, floating:false, ¬
          relative error:0}
          else
          delete actual end date
          set last actuals reporting date to (date \"%s\")
          end if
          set given actual work to {amount:%s, unit:%s, floating:false, ¬
          relative error:0}
          end if
          end tell
          end if
          end tell" account account start (if cleared "true" "false")
            end end  duration commodity))))))

#+end_src
*** miniedit
:PROPERTIES:
:tangle:   yes
:END:
    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. This binds =C-M-e= in a
    minibuffer) so that you can edit the contents of the minibuffer
    before submitting it.

#+begin_src emacs-lisp
  (use-package miniedit
    :commands minibuffer-edit
    :init
    (progn
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-ns-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-completion-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-must-match-map)))
#+end_src

*** mudel
#+begin_src emacs-lisp
;;;_ , mudel

(use-package mudel
  :commands mudel
  :bind ("C-c M" . mud)
  :init
  (defun mud ()
    (interactive)
    (mudel "4dimensions" "4dimensions.org" 6000)))

#+end_src
*** mule
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , mule

(use-package mule
  :init
  (progn
    (prefer-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))))

#+end_src
*** multi-term
#+begin_src emacs-lisp
;;;_ , multi-term

(use-package multi-term
  :bind (("C-. t" . multi-term-next)
         ("C-. T" . multi-term))
  :init
  (defun screen ()
    (interactive)
    (let (term-buffer)
      ;; Set buffer.
      (setq term-buffer
            (let ((multi-term-program (executable-find "screen"))
                  (multi-term-program-switches "-DR"))
              (multi-term-get-buffer)))
      (set-buffer term-buffer)
      ;; Internal handle for `multi-term' buffer.
      (multi-term-internal)
      ;; Switch buffer
      (switch-to-buffer term-buffer)))

  :config
  (progn
    (if t
        (defalias 'my-term-send-raw-at-prompt 'term-send-raw)
      (defun my-term-send-raw-at-prompt ()
        (interactive)
        (if (save-excursion
              (search-backward " $ " (line-beginning-position) t))
            (progn
              (if (memq 'meta (event-modifiers last-command-event))
                  (progn
                    (term-send-raw-string
                     (format "\e%c"
                             (logand last-command-event (lognot #x8000000)))))
                (call-interactively #'term-send-raw)))
          (call-interactively (lookup-key (current-global-map)
                                          (vector last-command-event))))))

    (defun my-term-end-of-buffer ()
      (interactive)
      (call-interactively #'end-of-buffer)
      (if (and (eobp) (bolp))
          (delete-char -1)))

    (require 'term)

    (defadvice term-process-pager (after term-process-rebind-keys activate)
      (define-key term-pager-break-map  "\177" 'term-pager-back-page))))

#+end_src
*** nf-procmail-mode
#+begin_src emacs-lisp
;;;_ , nf-procmail-mode

(use-package nf-procmail-mode
  :commands nf-procmail-mode)

#+end_src
*** nroff-mode
#+begin_src emacs-lisp
;;;_ , nroff-mode

(use-package nroff-mode
  :commands nroff-mode
  :config
  (progn
    (defun update-nroff-timestamp ()
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^\\.Dd ")
          (let ((stamp (format-time-string "%B %e, %Y")))
            (unless (looking-at stamp)
              (delete-region (point) (line-end-position))
              (insert stamp)
              (let (after-save-hook)
                (save-buffer)))))))

    (add-hook 'nroff-mode-hook
              #'(lambda ()
                  (add-hook 'after-save-hook 'update-nroff-timestamp nil t)))))

#+end_src
*** nxhtml
:PROPERTIES:
:tangle:   no
:END:

#+begin_src emacs-lisp
     (load "~/.emacs.d/site-lisp/nxhtml/autostart.el")

#+end_src

*** nxml-mode
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
  ;;;_ , nxml-mode
  
  (use-package nxml-mode
    :commands nxml-mode
    :init
    (defalias 'xml-mode 'nxml-mode)
    :mode ("\\.html$" . nxml-mode)
    :config
    (progn
      (add-to-list 'rng-schema-locating-files "~/.emacs.d/site-lisp/html5-el/schemas.xml")
      (use-package whattf-dt)
  
      (defun my-nxml-mode-hook ()
        (bind-key "<return>" 'newline-and-indent nxml-mode-map))
  
      (add-hook 'nxml-mode-hook 'my-nxml-mode-hook)
  
      (defun tidy-xml-buffer ()
        (interactive)
        (save-excursion
          (call-process-region (point-min) (point-max) "tidy" t t nil
                               "-xml" "-i" "-wrap" "0" "-omit" "-q")))
  
      (bind-key "C-. C-. t" 'tidy-xml-buffer nxml-mode-map)))
  
#+end_src
*** o-blog
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
  ;;;_ , o-blog
  
  (use-package o-blog
    :commands (o-blog-publish
               o-blog-tangle-publish-and-view)
    :config
    (progn
      (defvar o-blog-local-site "~/Sites/dev")
      (defvar o-blog-out-dir "out")
      (defvar o-blog-local-url-index "http://127.0.0.1/~tonyday/dev/index.html")
      (defvar github-site-dir "~/git/tonyday567.github.com")
  
      (defun o-blog-publish ()
        (interactive)
        "publish blog locally"
        (org-publish-blog buffer-file-name)
        (if (file-exists-p o-blog-local-site)
            (delete-directory o-blog-local-site t))
        (if (file-exists-p (format "%s/%s" default-directory "assets/ico/favicon.ico"))
           (copy-file (format "%s/%s" default-directory "assets/ico/favicon.ico")
                      (format "%s%s/%s" default-directory o-blog-out-dir "favicon.ico") t))
        (copy-directory 
         (format "%s%s" default-directory o-blog-out-dir) o-blog-local-site))
  
      (defun o-blog-tangle-publish-and-view ()
        (interactive)
        "tangle template  and style files in current buffer, publish blog locally
  and view local index.html url"
        (org-babel-tangle-file buffer-file-name)
        (o-blog-publish)
        (browse-url o-blog-local-url-index))
  
      (defun o-blog-tangle-and-publish ()
        (interactive)
        "tangle template  and style files in current buffer, publish blog locally
  and view local index.html url"
        (org-babel-tangle-file buffer-file-name)
        (o-blog-publish))
    
      (defun o-blog-tangle-publish-push ()
        (interactive)
        "tangle, publish blog locally, then push to github"
        (org-babel-tangle-file buffer-file-name)
        (o-blog-publish)
        (copy-directory 
         (format "%s%s" default-directory o-blog-out-dir)
         github-site-dir nil t t))
      
          (defun ob-get-posts-by-property (BLOG PROP VAL)
          "Returns a list of valid posts with the property PROP equal to VAL"
          (with-current-buffer (ob:blog-buffer BLOG)
            
            (let ((headings nil))
              (org-map-entries
               `(if (string= VAL (org-entry-get (point) PROP))
                    (setq headings (cons (org-get-heading t t) headings)))
               t
               'file)
              (setq headings (delq nil headings))
              (ob:get-posts
               (lambda (x)
                 (cl-some
                  (lambda (z)
                    (string= z (ob:post-title x)))
                  headings))
               4))))

      
      (defun ob-get-post-by-title (POSTS TITLE)
        "Returns a valid post with the title TITLE or null"
        (let ((POST-LIST POSTS)) 
          (while (and POSTS
                      (not (string= (ob:post-title (car POST-LIST)) TITLE)))
            (setq POST-LIST (cdr POST-LIST)))
          (car POST-LIST))))
    
    
    :bind (("C-c C-v ," . o-blog-publish)
           ("C-c C-v ." . o-blog-tangle-publish-and-view)
           ("C-c C-v /" . o-blog-tangle-and-publish)
           ("C-c C-v SPC" . o-blog-tangle-publish-push)))
#+end_src

#+results:
: t

*** org-mode
:PROPERTIES:
:tangle:   yes
:END:

Org-mode is specially treated for a few reasons:
- it has already been loaded in init.el so we could bootstrap everything else via an org-mode file.
- I prefer to go through Brent Hansen's org-mode.org setup and tweak that rather than reinvent my own config.

There's a few settings needed for org-mode.org to work (I tweak it post mostly)

#+begin_src emacs-lisp
(setq org-mode-user-lisp-path 
      (expand-file-name org-dir user-emacs-directory))
(setq org-user-agenda-files (quote ()))
(setq org-mode-user-contrib-lisp-path 
      (expand-file-name "site-lisp/org-mode/contrib/lisp" user-emacs-directory))
(org-babel-load-file (expand-file-name "~/.emacs.d/site-lisp/org-mode.org"))
#+end_src

**** org-capture

I organise org-capture parameters by using org tables:

#+name: captures
| key | desc           | type       | target type   | target path                | target header | template                                             |
|-----+----------------+------------+---------------+----------------------------+---------------+------------------------------------------------------|
| ,   | ,,             | entry      | file          | ~/stuff/org/refile.org     |               | * %?\n                                               |
| t   | todo           |            |               |                            |               |                                                      |
| tu  | urgent todo    | entry      | file          | ~/stuff/org/refile.org     |               | * NEXT %? :urgent:\n:PROPERTIES:\n:OPEN: %U\n:END:\n |
| tl  | linked todo    | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n%a\n                                      |
| tn  | next todo      | entry      | file          | ~/stuff/org/refile.org     |               | * NEXT %?\n                                          |
| tt  | todo todo      | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n                                          |
| tb  | yank body      | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n%c\n                                      |
| th  | yank header    | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %c\n%?\n                                      |
| i   | idea           |            |               |                            |               |                                                      |
| ii  | idea           | entry      | file+headline | ~/stuff/content/ideas.org  | incoming      | * %? \n                                              |
| il  | idea link      | entry      | file+headline | ~/stuff/content/ideas.org  | links         | * %a \n %?                                           |
| iy  | idea yank      | entry      | file+headline | ~/stuff/content/ideas.org  | incoming      | * %?%c \n                                            |
| z   | bugz           | entry      | file+headline | ~/stuff/org/bugz.org       | incoming      | * TODO %?\n%a                                        |
| s   | snipz          |            |               |                            |               |                                                      |
| sr  | snipz request  | entry      | file+headline | ~/stuff/org/snipz.org      | incoming      | * TODO %?\n%a\n                                      |
| sn  | snipz note     | entry      | file+headline | ~/stuff/org/snipz.org      | incoming      | * %?\n%c\n                                           |
| b   | binding        | table-line | file+headline | ~/stuff/emacs/bindings.org | incoming      |                                                      |
| k   | kill ring      |            |               |                            |               |                                                      |
| kb  | kill ring body | entry      | file          | ~/stuff/org/refile.org     |               | * %?\n%c\n                                           |
| kh  | kill ring head | entry      | file          | ~/stuff/org/refile.org     |               | * %c\n%?\n                                           |


#+begin_src emacs-lisp :var data=captures  
  (setq org-capture-templates 
        (loop for row in (org-table-remove-header data)
              collect
              (eval (quote (car (read-from-string 
                                (replace-regexp-in-string "(  )" ""                                                     (replace-regexp-in-string "\"\"" "" 
                                (replace-regexp-in-string "\\\\n" "n" 
                                 (apply 'format "(%S %S %s (%s %S %S) %S)" row))))))))))
#+end_src

**** agenda-files
:PROPERTIES:
:tangle:   no
:END:

Moved to the default agenda files control via custom.

Using tables as well for agenda files is very useful, especially for
quickly changing ordering.

#+TBLNAME: agenda-files
| .emacs.d |           | README.org                 |               |
| .emacs.d |           | dotemacs.org               |               |
| git      | acme      | acme.org                   |               |
| git      | o-blog    | example                    | oblog-min.org |
| stuff    |           | stuff.org                  |               |
| stuff    | biz       | scarce.org                 |               |
| stuff    | content   | allocation_final.org       |               |
| stuff    | content   | life.org                   |               |
| stuff    | content   | writing.org                |               |
| stuff    | content   | ideas.org                  |               |
| stuff    | content   | tail-material.org          |               |
| stuff    | content   | grob.org                   |               |
| stuff    | dev       | alice.org                  |               |
| stuff    | dev       | webdev.org                 |               |
| stuff    | dev       | sandpit                    | sandpit.org   |
| stuff    | dev       | dot.org                    |               |
| stuff    | dev       | beamer.org                 |               |
| stuff    | emacs     | emacs.org                  |               |
| stuff    | emacs     | bindings.org               |               |
| stuff    | factor    | factor.org                 |               |
| stuff    | org       | refile.org                 |               |
| stuff    | org       | bugz.org                   |               |
| stuff    | org       | snipz.org                  |               |
| stuff    | org       | org.org                    |               |
| stuff    | quant     | rdev.org                   |               |
| stuff    | quant     | volatility.org             |               |
| stuff    | quant     | strategy_run_annotated.org |               |
| stuff    | quant     | strategy_run_default.org   |               |
| stuff    | quant     | momentum.org               |               |
| stuff    | quant     | mom-report.org             |               |
| stuff    | quant     | jgb.org                    |               |
| stuff    | quant     | data.org                   |               |
| stuff    | quant     | quaff.org                  |               |
| stuff    | quant     | moments.org                |               |
| stuff    | quant     | da.org                     |               |
| stuff    | site      | site-dev.org               |               |
| stuff    | sys       | sys.org                    |               |
| projects | fgr       | fgr.org                    |               |
| projects | opoker    | opoker.org                 |               |
| projects | alice     | alice.org                  |               |
| projects | metaalice | metaalice.org              |               |

  #+begin_src emacs-lisp :var data=agenda-files
    (setq clean-table
          (delete nil  
                  (loop for line in data
                        collect 
                        (delete "" (delete-dups line)))))
    
    (setq org-agenda-files
          (mapcar
           (lambda (x) 
             (concat "~/"
                     (mapconcat
                      'eval x "/")))
           clean-table))
  #+end_src

  #+results:
  | ~/.emacs.d/README.org | ~/.emacs.d/dotemacs.org | ~/git/acme/acme.org | ~/git/o-blog/example/oblog-min.org | ~/stuff/stuff.org | ~/stuff/biz/scarce.org | ~/stuff/content/allocation_final.org | ~/stuff/content/life.org | ~/stuff/content/writing.org | ~/stuff/content/ideas.org | ~/stuff/content/tail-material.org | ~/stuff/content/grob.org | ~/stuff/dev/alice.org | ~/stuff/dev/webdev.org | ~/stuff/dev/sandpit/sandpit.org | ~/stuff/dev/dot.org | ~/stuff/dev/beamer.org | ~/stuff/emacs/emacs.org | ~/stuff/emacs/bindings.org | ~/stuff/factor/factor.org | ~/stuff/org/refile.org | ~/stuff/org/bugz.org | ~/stuff/org/snipz.org | ~/stuff/org/org.org | ~/stuff/quant/rdev.org | ~/stuff/quant/volatility.org | ~/stuff/quant/strategy_run_annotated.org | ~/stuff/quant/strategy_run_default.org | ~/stuff/quant/momentum.org | ~/stuff/quant/mom-report.org | ~/stuff/quant/jgb.org | ~/stuff/quant/data.org | ~/stuff/quant/quaff.org | ~/stuff/quant/moments.org | ~/stuff/quant/da.org | ~/stuff/site/site-dev.org | ~/stuff/sys/sys.org | ~/projects/fgr/fgr.org | ~/projects/opoker/opoker.org | ~/projects/alice/alice.org | ~/projects/metaalice/metaalice.org |

**** other stuff
***** tags
  #+begin_src emacs-lisp
  ; Tags with fast selection keys
(setq org-tag-alist (quote (("urgent" . ?u)
                            ("bill" . ?b)
                            ("scarce" . ?s)
                            ("crypt" . ?c)
                            ("emacs" . ?e))))
#+end_src 

  #+results:
  | (urgent . 117) | (bill . 98) | (scarce . 115) | (crypt . 99) | (emacs . 101) |
***** babel languages
   #+begin_src emacs-lisp 
    (org-babel-do-load-languages
       (quote org-babel-load-languages)
       (quote ((emacs-lisp . t)
               (sh . t)
               (dot . t)
               (gnuplot . t)
               (org . t)
               (octave . t)
               (js . t)
               (R . t))))
  #+end_src

   #+results:
   | (emacs-lisp . t) | (sh . t) | (dot . t) | (gnuplot . t) | (org . t) | (octave . t) | (js . t) | (R . t) |
***** override hansen settings
    
#+begin_src emacs-lisp
      (remove-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp)
#+end_src

***** packages

  #+begin_src emacs-lisp
  (use-package org-habit)
  (use-package org-colview)
  (use-package org-special-blocks)
  (use-package org-mac-iCal)
  (use-package org-mac-link-grabber)
#+end_src

***** jumping
#+begin_src emacs-lisp
  (defun org-jump ()
    (interactive)
    (bookmark-set "org-jumped-from")
    (org-refile t nil nil "Jump")
    (bookmark-set "org-jumped-to"))
    
   
  (defun org-jump-back()
    (interactive)
    (if (equal (point) (bookmark-get-position "org-jumped-from"))
        (bookmark-jump "org-jumped-to")
      (if (bookmark-get-position "org-jumped-to")
          (bookmark-jump "org-jumped-from"))))
     
  
  (bind-key "C-. j" 'org-jump)
  (bind-key "C-. l" 'org-jump-back)
#+end_src


***** remove results
#+begin_src emacs-lisp
(defun org-remove-results ()
  (interactive)  
  (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward "^#\\+results:.*
\\(^\\|.+
\\)*
" nil t)
      (replace-match ""))))

(bind-key "C-c t r" 'org-remove-results)

#+end_src

***** org-random-entry
#+begin_src emacs-lisp
  (defun org-random-entry (&optional arg)
    "Select and goto a random todo item from the global agenda"
    (interactive "P")
    (if org-agenda-overriding-arguments
        (setq arg org-agenda-overriding-arguments))
    (if (and (stringp arg) (not (string-match "\\S-" arg))) (setq arg nil))
    (let* ((today (org-today))
           (date (calendar-gregorian-from-absolute today))
           (kwds org-todo-keywords-for-agenda)
           (lucky-entry nil)
           (completion-ignore-case t)
           (org-select-this-todo-keyword
            (if (stringp arg) arg
              (and arg (integerp arg) (> arg 0)
                   (nth (1- arg) kwds))))
           rtn rtnall files file pos marker buffer)
      (when (equal arg '(4))
        (setq org-select-this-todo-keyword
              (org-icompleting-read "Keyword (or KWD1|K2D2|...): "
                                    (mapcar 'list kwds) nil nil)))
      (and (equal 0 arg) (setq org-select-this-todo-keyword nil))
      (catch 'exit
        (org-compile-prefix-format 'todo)
        (org-set-sorting-strategy 'todo)
        (setq files (org-agenda-files nil 'ifmode)
              rtnall nil)
        (while (setq file (pop files))
          (catch 'nextfile
            (org-check-agenda-file file)
            (setq rtn (org-agenda-get-day-entries file date :todo))
            (setq rtnall (append rtnall rtn))))
        
        (when rtnall
          (setq lucky-entry
                (nth (random
                      (safe-length
                       (setq entries rtnall)))
                     entries))
          
          (setq marker (or (get-text-property 0 'org-marker lucky-entry)
                           (org-agenda-error)))
          (setq buffer (marker-buffer marker))
          (setq pos (marker-position marker))
          (org-pop-to-buffer-same-window buffer)
          (widen)
          (goto-char pos)
          (when (derived-mode-p 'org-mode)
            (org-show-context 'agenda)
            (save-excursion
              (and (outline-next-heading)
                   (org-flag-heading nil))) ; show the next heading
            (when (outline-invisible-p)
              (show-entry))                 ; display invisible text
            (run-hooks 'org-agenda-after-show-hook))))))
  
  (bind-key "C-. C-. r" 'org-random-entry)
    
#+end_src

***** update-calender
#+begin_src emacs-lisp
  (defun update-calender ()
    (setq diary-file "~/Documents/diary")
    (org-mac-iCal))
  
  (bind-key "H-c" 'update-calender)  
#+end_src

#+results:
: #<buffer dotemacs.org>

***** grab link

[[http://orgmode.org/worg/org-contrib/org-mac-link-grabber.html][org-mac-link-grabber.el – Grab links from open Mac applications]]
#+begin_src emacs-lisp
  (bind-key "H-l" 'omlg-grab-link)
#+end_src

**** org bindings

shoving the binds in binds so I can see where everything is
#+name: org-bindings
| key       | binding                                           |
|-----------+---------------------------------------------------|
| C-c l     | org-store-link                                    |
| C-c a     | org-agenda                                        |
| C-c b     | org-iswitchb                                      |
| <f12>     | org-agenda                                        |
| <f5>      | bh/org-todo                                       |
| <S-f5>    | bh/widen                                          |
| <f7>      | bh/set-truncate-lines                             |
| <f8>      | org-cycle-agenda-files                            |
| <f9> <f9> | bh/show-org-agenda                                |
| <f9> c    | calendar                                          |
| <f9> f    | boxquote-insert-file                              |
| <f9> h    | bh/hide-other                                     |
| <f9> n    | org-narrow-to-subtree                             |
| <f9> w    | widen                                             |
| <f9> u    | bh/narrow-up-one-level                            |
| <f9> I    | bh/punch-in                                       |
| <f9> O    | bh/punch-out                                      |
| <f9> o    | bh/make-org-scratch                               |
| <f9> r    | boxquote-region                                   |
| <f9> s    | bh/switch-to-scratch                              |
| <f9> t    | bh/insert-inactive-timestamp                      |
| <f9> T    | tabify                                            |
| <f9> U    | untabify                                          |
| <f9> v    | visible-mode                                      |
| <f9> SPC  | bh/clock-in-last-task                             |
| C-<f9>    | previous-buffer                                   |
| M-<f9>    | org-toggle-inline-images                          |
| C-x n r   | narrow-to-region                                  |
| C-<f10>   | next-buffer                                       |
| <f11>     | org-clock-goto                                    |
| C-<f11>   | org-clock-in                                      |
| C-s-<f12> | bh/save-then-publish                              |
| C-M-r     | org-capture                                       |
| C-c r     | org-capture                                       |
| C-M-r     | org-capture                                       |
| C-c r     | org-capture                                       |
| <f9> p    | bh/phone-call                                     |
| C-s-<f12> | bh/save-then-publish                              |
| <f5>      | bh/org-todo                                       |
| <S-f5>    | bh/widen                                          |
| <f9> t    | bh/insert-inactive-timestamp                      |
| M-x       | smex                                              |
| C-x x     | smex                                              |
| M-X       | smex-major-mode-commands                          |
| <C-f6>    | (lambda () (interactive) (bookmark-set "SAVED"))  |
| <f6>      | (lambda () (interactive) (bookmark-jump "SAVED")) |
| M-s c     | org-occur-in-agenda-files                         |

#+begin_src emacs-lisp :var table=org-bindings
  (bind-keys-from-table (org-table-remove-header table))
#+end_src

**** TODO org R&D
:PROPERTIES:
:tangle:   no
:ID:       F066ACCB-918B-4326-A354-13ECA60A7D57
:END:
- [ ] transform to use-package method
- [ ] extract and deprecate hansen org-mode

jwiegley org setup
#+begin_src emacs-lisp
;;;_ , org-mode

(use-package dot-org
  :commands org-agenda-list
  :bind (("M-C"   . jump-to-org-agenda)
         ("M-m"   . org-smart-capture)
         ("M-M"   . org-inline-note)
         ("C-c a" . org-agenda)
         ("C-c S" . org-store-link)
         ("C-c l" . org-insert-link))
  :init
  (progn
    (unless running-alternate-emacs
      (run-with-idle-timer 300 t 'jump-to-org-agenda))

    (if (string-match "\\.elc\\'" load-file-name)
        (add-hook 'after-init-hook
                  #'(lambda ()
                      (org-agenda-list)
                      (org-fit-agenda-window)
                      (org-resolve-clocks))) t)))

#+end_src

***** diminish
#+begin_src emacs-lisp
  ;;(diminish 'org-indent-mode)
#+end_src

*** paredit
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , paredit

(use-package paredit
  :commands paredit-mode
  :diminish paredit-mode
  :config
  (progn
    (use-package paredit-ext)

    (bind-key "C-M-l" 'paredit-recentre-on-sexp paredit-mode-map)

    (bind-key ")" 'paredit-close-round-and-newline paredit-mode-map)
    (bind-key "M-)" 'paredit-close-round paredit-mode-map)

    (bind-key "M-k" 'paredit-raise-sexp paredit-mode-map)
    (bind-key "M-h" 'mark-containing-sexp paredit-mode-map)
    (bind-key "M-I" 'paredit-splice-sexp paredit-mode-map)

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (bind-key "C-. d" 'paredit-forward-down paredit-mode-map)
    (bind-key "C-. B" 'paredit-splice-sexp-killing-backward paredit-mode-map)
    (bind-key "C-. C" 'paredit-convolute-sexp paredit-mode-map)
    (bind-key "C-. F" 'paredit-splice-sexp-killing-forward paredit-mode-map)
    (bind-key "C-. a" 'paredit-add-to-next-list paredit-mode-map)
    (bind-key "C-. A" 'paredit-add-to-previous-list paredit-mode-map)
    (bind-key "C-. j" 'paredit-join-with-next-list paredit-mode-map)
    (bind-key "C-. J" 'paredit-join-with-previous-list paredit-mode-map)

    (add-hook 'allout-mode-hook
              #'(lambda ()
                  (bind-key "M-k" 'paredit-raise-sexp allout-mode-map)
                  (bind-key "M-h" 'mark-containing-sexp allout-mode-map)))))

#+end_src
*** paren
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , paren

(unless
    (use-package mic-paren
          :init
          (paren-activate))

  (use-package paren
    :init
    (show-paren-mode 1)))

#+end_src
*** per-window-point
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , per-window-point

(use-package per-window-point
  :init
  (pwp-mode 1))

#+end_src
*** persistent-scratch
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , persistent-scratch

(use-package persistent-scratch
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive)))

#+end_src
*** popup-ruler
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , popup-ruler

(use-package popup-ruler
  :bind (("C-. r" . popup-ruler)
         ("C-. R" . popup-ruler-vertical)))

#+end_src
*** pp-c-l
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , pp-c-l

(use-package pp-c-l
  :init
  (hook-into-modes 'pretty-control-l-mode '(prog-mode-hook)))

#+end_src
*** ps-print
#+begin_src emacs-lisp
;;;_ , ps-print

(use-package ps-print
  :defer t
  :config
  (progn
    (defun ps-spool-to-pdf (beg end &rest ignore)
      (interactive "r")
      (let ((temp-file (concat (make-temp-name "ps2pdf") ".pdf")))
        (call-process-region beg end (executable-find "ps2pdf")
                             nil nil nil "-" temp-file)
        (call-process (executable-find "open") nil nil nil temp-file)))

    (setq ps-print-region-function 'ps-spool-to-pdf)))

#+end_src
*** puppet-mode
#+begin_src emacs-lisp
;;;_ , puppet-mode

(use-package puppet-mode
  :mode ("\\.pp\\'" . puppet-mode)
  :config
  (use-package puppet-ext))

#+end_src
*** python-mode
#+begin_src emacs-lisp
;;;_ , python-mode

(use-package python-mode
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)
  :config
  (progn
    (defvar python-mode-initialized nil)

    (defun my-python-mode-hook ()
      (unless python-mode-initialized
        (setq python-mode-initialized t)

        (info-lookup-add-help
         :mode 'python-mode
         :regexp "[a-zA-Z_0-9.]+"
         :doc-spec
         '(("(python)Python Module Index" )
           ("(python)Index"
            (lambda
              (item)
              (cond
               ((string-match
                 "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
                (format "%s.%s" (match-string 2 item)
                        (match-string 1 item)))))))))

      (setq indicate-empty-lines t)
      (set (make-local-variable 'parens-require-spaces) nil)
      (setq indent-tabs-mode nil)

      (bind-key "C-c C-z" 'python-shell python-mode-map)
      (unbind-key "C-c c" python-mode-map))

    (add-hook 'python-mode-hook 'my-python-mode-hook)))

#+end_src
*** quickrun
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , quickrun

(use-package quickrun
  :bind* ("C-c C-r" . quickrun))

#+end_src
*** recentf
:PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , recentf

(use-package recentf
  :if (not noninteractive)
  :init
  (progn
    (setq recentf-save-file  "~/.emacs.d/data/recentf")
    (recentf-mode 1)

    (defun recentf-add-dired-directory ()
      (if (and dired-directory
               (file-directory-p dired-directory)
               (not (string= "/" dired-directory)))
          (let ((last-idx (1- (length dired-directory))))
            (recentf-add-file
             (if (= ?/ (aref dired-directory last-idx))
                 (substring dired-directory 0 last-idx)
               dired-directory)))))

    (add-hook 'dired-mode-hook 'recentf-add-dired-directory)))

#+end_src
*** repeat-insert
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , repeat-insert

(use-package repeat-insert
  :disabled t
  :commands (insert-patterned
             insert-patterned-2
             insert-patterned-3
             insert-patterned-4))

#+end_src
*** ruby-mode
#+begin_src emacs-lisp
;;;_ , ruby-mode

(use-package ruby-mode
  :mode ("\\.rb\\'" . ruby-mode)
  :interpreter ("ruby" . ruby-mode)
  :config
  (progn
    (use-package yari
      :init
      (progn
        (defvar yari-helm-source-ri-pages
          '((name . "RI documentation")
            (candidates . (lambda () (yari-ruby-obarray)))
            (action  ("Show with Yari" . yari))
            (candidate-number-limit . 300)
            (requires-pattern . 2)
            "Source for completing RI documentation."))

        (defun helm-yari (&optional rehash)
          (interactive (list current-prefix-arg))
          (when current-prefix-arg (yari-ruby-obarray rehash))
          (helm 'yari-helm-source-ri-pages (yari-symbol-at-point)))))

    (defun my-ruby-smart-return ()
      (interactive)
      (when (memq (char-after) '(?\| ?\" ?\'))
        (forward-char))
      (call-interactively 'newline-and-indent))

    (defun my-ruby-mode-hook ()
      (require 'inf-ruby)
      (inf-ruby-keys)

      (bind-key "<return>" 'my-ruby-smart-return ruby-mode-map)
      (bind-key "C-h C-i" 'helm-yari ruby-mode-map)

      (set (make-local-variable 'yas/fallback-behavior)
           '(apply ruby-indent-command . nil))
      (bind-key "<tab>" 'yas/expand-from-trigger-key ruby-mode-map))

    (add-hook 'ruby-mode-hook 'my-ruby-mode-hook)))

#+end_src
*** selectkey
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , selectkey

(use-package selectkey
  :init
  (progn
    (bind-key "C-. b" 'selectkey-select-prefix-map)

    (selectkey-define-select-key compile "c" "\\*compilation")
    (selectkey-define-select-key shell-command "o" "Shell Command")
    (selectkey-define-select-key shell "s" "\\*shell" (shell))
    (selectkey-define-select-key multi-term "t" "\\*terminal" (multi-term-next))
    (selectkey-define-select-key eshell "z" "\\*eshell" (eshell))))

#+end_src
*** session
#+begin_src emacs-lisp
;;;_ , session

(use-package session
  :if (not noninteractive)
  :load-path "site-lisp/session/lisp/"
  :init
  (progn
    (session-initialize)

    (defun remove-session-use-package-from-settings ()
      (when (string= (buffer-file-name)
                     (expand-file-name "settings.el"
                                       user-emacs-directory))
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^ '(session-use-package " nil t)
            (delete-region (line-beginning-position)
                           (1+ (line-end-position)))))))

    (add-hook 'before-save-hook 'remove-session-use-package-from-settings)

    ;; expanded folded secitons as required
    (defun le::maybe-reveal ()
      (when (and (or (memq major-mode  '(org-mode outline-mode))
                     (and (boundp 'outline-minor-mode)
                          outline-minor-mode))
                 (outline-invisible-p))
        (if (eq major-mode 'org-mode)
            (org-reveal)
          (show-subtree))))

    (add-hook 'session-after-jump-to-last-change-hook
              'le::maybe-reveal)

    (defun save-information ()
      (with-temp-message "Saving Emacs information..."
        (recentf-cleanup)

        (loop for func in kill-emacs-hook
              unless (memq func '(exit-gnus-on-exit server-force-stop))
              do (funcall func))

        (unless (or noninteractive
                    running-alternate-emacs
                    (eq 'listen (process-status server-process)))
          (server-start))))

    (run-with-idle-timer 300 t 'save-information)

    (if window-system
        (add-hook 'after-init-hook 'session-initialize t))))

#+end_src
*** sh-script
#+begin_src emacs-lisp
;;;_ , sh-script

(use-package sh-script
  :defer t
  :config
  (progn
    (defvar sh-script-initialized nil)
    (defun initialize-sh-script ()
      (unless sh-script-initialized
        (setq sh-script-initialized t)
        (info-lookup-add-help :mode 'shell-script-mode
                              :regexp ".*"
                              :doc-spec
                              '(("(bash)Index")))))

    (add-hook 'shell-mode-hook 'initialize-sh-script)))

#+end_src
*** sh-toggle
#+begin_src emacs-lisp
;;;_ , sh-toggle

(use-package sh-toggle
  :bind ("C-. C-z" . shell-toggle))

#+end_src
*** slime
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , slime

(use-package slime
  :commands (sbcl slime)
  :init
  (add-hook
   'slime-load-hook
   #'(lambda ()
       (slime-setup
        '(slime-asdf
          slime-autodoc
          slime-banner
          slime-c-p-c
          slime-editing-commands
          slime-fancy-inspector
          slime-fancy
          slime-fuzzy
          slime-highlight-edits
          slime-parse
          slime-presentation-streams
          slime-presentations
          slime-references
          slime-repl
          slime-sbcl-exts
          slime-package-fu
          slime-fontifying-fu
          slime-mdot-fu
          slime-scratch
          slime-tramp
          ;; slime-enclosing-context
          ;; slime-typeout-frame
          slime-xref-browser))

       (define-key slime-repl-mode-map [(control return)] 'other-window)

       (define-key slime-mode-map [return] 'paredit-newline)
       (define-key slime-mode-map [(control ?h) ?F] 'info-lookup-symbol)))

  :config
  (progn
    (eval-when-compile
      (defvar slime-repl-mode-map))



    (setq slime-net-coding-system 'utf-8-unix)

    (setq slime-lisp-implementations
          '((sbcl
             ("sbcl" "--core"
              "/Users/johnw/Library/Lisp/sbcl.core-with-slime-X86-64")
             :init
             (lambda (port-file _)
               (format "(swank:start-server %S)\n" port-file)))
            (ecl ("ecl" "-load" "/Users/johnw/Library/Lisp/init.lisp"))
            (clisp ("clisp" "-i" "/Users/johnw/Library/Lisp/lwinit.lisp"))))

    (setq slime-default-lisp 'sbcl)
    (setq slime-complete-symbol*-fancy t)
    (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)

    (defun sbcl (&optional arg)
      (interactive "P")
      (let ((slime-default-lisp (if arg 'sbcl64 'sbcl))
            (current-prefix-arg nil))
        (slime)))
    (defun clisp () (interactive) (let ((slime-default-lisp 'clisp)) (slime)))
    (defun ecl () (interactive) (let ((slime-default-lisp 'ecl)) (slime)))

    (defun start-slime ()
      (interactive)
      (unless (slime-connected-p)
        (save-excursion (slime))))

    (add-hook 'slime-mode-hook 'start-slime)
    (add-hook 'slime-load-hook #'(lambda () (require 'slime-fancy)))
    (add-hook 'inferior-lisp-mode-hook #'(lambda () (inferior-slime-mode t)))

    (use-package hyperspec
      :init
      (setq common-lisp-hyperspec-root
            "/opt/local/share/doc/lisp/HyperSpec-7-0/HyperSpec/"))))

#+end_src
*** smart-compile
#+begin_src emacs-lisp
;;;_ , smart-compile

(use-package smart-compile
  :commands smart-compile
  :bind (("C-c c" . smart-compile)
         ("A-n"   . next-error)
         ("A-p"   . previous-error))
  :init
  (progn
    (defun show-compilation ()
      (interactive)
      (let ((compile-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*compilation\\*" (buffer-name buf))
                     (throw 'found buf))))))
        (if compile-buf
            (switch-to-buffer-other-window compile-buf)
          (call-interactively 'compile))))

  (bind-key "M-O" 'show-compilation)))

#+end_src
*** smerge-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , smerge-mode

(use-package smerge-mode
  :commands (smerge-mode smerge-command-prefix)
  :init
  (setq smerge-command-prefix (kbd "C-. C-=")))

#+end_src

*** stopwatch
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , stopwatch

(use-package stopwatch
  :bind ("<f8>" . stopwatch))

#+end_src
*** sunrise-commander
#+begin_src emacs-lisp
;;;_ , sunrise-commander

(use-package sunrise-commander
  :disabled t
  :commands (sunrise sunrise-cd)
  :init
  (progn
    (defun my-activate-sunrise ()
      (interactive)
      (let ((sunrise-exists
             (loop for buf in (buffer-list)
                   when (string-match " (Sunrise)$" (buffer-name buf))
                   return buf)))
        (if sunrise-exists
            (call-interactively 'sunrise)
          (sunrise "~/dl/" "~/Archives/"))))

    (bind-key "C-c j" 'my-activate-sunrise)
    (bind-key "C-c C-j" 'sunrise-cd))

  :config
  (progn
    (require 'sunrise-x-modeline)
    (require 'sunrise-x-tree)
    (require 'sunrise-x-tabs)

    (bind-key "/" 'sr-sticky-isearch-forward sr-mode-map)
    (bind-key "<backspace>" 'sr-scroll-quick-view-down sr-mode-map)
    (bind-key "C-x t" 'sr-toggle-truncate-lines sr-mode-map)

    (bind-key "q" 'sr-history-prev sr-mode-map)
    (bind-key "z" 'sr-quit sr-mode-map)

    (unbind-key "C-e" sr-mode-map)
    (unbind-key "C-p" sr-tabs-mode-map)
    (unbind-key "C-n" sr-tabs-mode-map)
    (unbind-key "M-<backspace>" sr-term-line-minor-mode-map)

    (bind-key "M-[" 'sr-tabs-prev sr-tabs-mode-map)
    (bind-key "M-]" 'sr-tabs-next sr-tabs-mode-map)

    (defun sr-browse-file (&optional file)
      "Display the selected file with the default appication."
      (interactive)
      (setq file (or file (dired-get-filename)))
      (save-selected-window
        (sr-select-viewer-window)
        (let ((buff (current-buffer))
              (fname (if (file-directory-p file)
                         file
                       (file-name-nondirectory file)))
              (app (cond
                    ((eq system-type 'darwin)       "open %s")
                    ((eq system-type 'windows-nt)   "open %s")
                    (t                              "xdg-open %s"))))
          (start-process-shell-command "open" nil (format app file))
          (unless (eq buff (current-buffer))
            (sr-scrollable-viewer (current-buffer)))
          (message "Opening \"%s\" ..." fname))))

    (defun sr-goto-dir (dir)
      "Change the current directory in the active pane to the given one."
      (interactive (list (progn
                           (require 'lusty-explorer)
                           (lusty-read-directory))))
      (if sr-goto-dir-function
          (funcall sr-goto-dir-function dir)
        (unless (and (eq major-mode 'sr-mode)
                     (sr-equal-dirs dir default-directory))
          (if (and sr-avfs-root
                   (null (posix-string-match "#" dir)))
              (setq dir (replace-regexp-in-string
                         (expand-file-name sr-avfs-root) "" dir)))
          (sr-save-aspect
           (sr-within dir (sr-alternate-buffer (dired dir))))
          (sr-history-push default-directory)
          (sr-beginning-of-buffer))))))

#+end_src
*** tablegen-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , tablegen-mode

(use-package tablegen-mode
  :description "\
  This mode is used for editing .td files in the LLVM/Clang source code."
  :mode ("\\.td\\'" . tablegen-mode))

#+end_src
*** texinfo
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , texinfo

(use-package texinfo
  :defines texinfo-section-list
  :mode ("\\.texi\\'" . texinfo-mode)
  :config
  (progn
    (defun my-texinfo-mode-hook ()
      (dolist (mapping '((?b . "emph")
                         (?c . "code")
                         (?s . "samp")
                         (?d . "dfn")
                         (?o . "option")
                         (?x . "pxref")))
        (local-set-key (vector (list 'alt (car mapping)))
                       `(lambda () (interactive)
                          (TeX-insert-macro ,(cdr mapping))))))

    (add-hook 'texinfo-mode-hook 'my-texinfo-mode-hook)

    (defun texinfo-outline-level ()
      ;; Calculate level of current texinfo outline heading.
      (require 'texinfo)
      (save-excursion
        (if (bobp)
            0
          (forward-char 1)
          (let* ((word (buffer-substring-no-properties
                        (point) (progn (forward-word 1) (point))))
                 (entry (assoc word texinfo-section-list)))
            (if entry
                (nth 1 entry)
              5)))))))

#+end_src

*** tramp
:PROPERTIES:
:tangle:   yes
:END:

Manually tyype this to get sudo in ido-find-file:

/sudo:root@localhost:/

#+begin_src emacs-lisp
    (use-package tramp
  :init (progn
          (defun find-alternative-file-with-sudo ()
            (interactive)
            (let ((fname (or buffer-file-name
                             dired-directory)))
              (when fname
                (if (string-match "^/sudo:root@localhost:" fname)
                    (setq fname (replace-regexp-in-string
                                 "^/sudo:root@localhost:" ""
                                 fname))
                  (setq fname (concat "/sudo:root@localhost:" fname)))
                (find-alternate-file fname)))))
  
  :bind  (("H-t" . find-alternative-file-with-sudo))
  
  )
#+end_src

*** twitter
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  (use-package twittering-mode
:defer t
   :config (setq twittering-use-master-password t))
#+end_src


*** undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :init (global-undo-tree-mode))
#+end_src

*** vkill
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , vkill

(use-package vkill
  :commands vkill
  :init
  (progn
    (defun vkill-and-helm-occur ()
      (interactive)
      (vkill)
      (call-interactively #'helm-occur))

    (bind-key "C-x L" 'vkill-and-helm-occur))

  :config
  (setq vkill-show-all-processes t))

#+end_src
*** w3m
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , w3m

(use-package w3m
  :commands (w3m-search w3m-find-file)
  :bind (("C-. u"   . w3m-browse-url)
         ("C-. U"   . w3m-browse-url-new-session)
         ("C-. A-u" . w3m-browse-chrome-url-new-session))
  :init
  (progn
    (setq w3m-command "/usr/local/bin/w3m")

    (setq w3m-coding-system 'utf-8
          w3m-file-coding-system 'utf-8
          w3m-file-name-coding-system 'utf-8
          w3m-input-coding-system 'utf-8
          w3m-output-coding-system 'utf-8
          w3m-terminal-coding-system 'utf-8)

    (add-hook 'w3m-mode-hook 'w3m-link-numbering-mode)

    (autoload 'w3m-session-crash-recovery-remove "w3m-session")

    (defun show-browser ()
      (interactive)
      (let ((w3m-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*w3m" (buffer-name buf))
                     (throw 'found buf))))))
        (if w3m-buf
            (switch-to-buffer-other-window w3m-buf)
          (call-interactively 'w3m-find-file))))

    (bind-key "C-. w" 'show-browser)

    (defun wikipedia-query (term)
      (interactive (list (read-string "Wikipedia search: " (word-at-point))))
      (require 'w3m-search)
      (w3m-search "en.wikipedia" term))

    (eval-when-compile
      (autoload 'w3m-search-escape-query-string "w3m-search"))

    (defun wolfram-alpha-query (term)
      (interactive (list (read-string "Ask Wolfram Alpha: " (word-at-point))))
      (require 'w3m-search)
      (w3m-browse-url (concat "http://m.wolframalpha.com/input/?i="
                              (w3m-search-escape-query-string term))))

    (defun goto-emacswiki ()
      (interactive)
      (w3m-browse-url "http://www.emacswiki.org"))

    (defun w3m-browse-url-new-session (url)
      (interactive (progn
                     (require 'browse-url)
                     (browse-url-interactive-arg "Emacs-w3m URL: ")))
      (w3m-browse-url url t))

    (defun w3m-browse-chrome-url-new-session ()
      (interactive)
      (let ((url (do-applescript
                  (string-to-multibyte "tell application \"Google Chrome\"
  URL of active tab of front window
  end tell"))))
        (w3m-browse-url (substring url 1 (1- (length url))) t)))

    (bind-key "A-M-e" 'goto-emacswiki)
    (bind-key "A-M-g" 'w3m-search)
    (bind-key "A-M-w" 'wikipedia-query))

  :config
  (let (proxy-host proxy-port)
    (with-temp-buffer
      (shell-command "scutil --proxy" (current-buffer))

      (when (re-search-forward "HTTPPort : \\([0-9]+\\)" nil t)
        (setq proxy-port (match-string 1)))
      (when (re-search-forward "HTTPProxy : \\(\\S-+\\)" nil t)
        (setq proxy-host (match-string 1))))

    (if (and proxy-host proxy-port)
        (setq w3m-command-arguments
              (nconc w3m-command-arguments
                     (list "-o" (format "http_proxy=http://%s:%s/"
                                        proxy-host proxy-port)))))

    (use-package w3m-type-ahead
      :requires w3m
      :init
      (add-hook 'w3m-mode-hook 'w3m-type-ahead-mode))

    (add-hook 'w3m-display-hook
              (lambda (url)
                (let ((buffer-read-only nil))
                  (delete-trailing-whitespace))))

    (defun my-w3m-linknum-follow ()
      (interactive)
      (w3m-linknum-follow))

    (bind-key "k" 'w3m-delete-buffer w3m-mode-map)
    (bind-key "i" 'w3m-view-previous-page w3m-mode-map)
    (bind-key "p" 'w3m-previous-anchor w3m-mode-map)
    (bind-key "n" 'w3m-next-anchor w3m-mode-map)

    (defun dka-w3m-textarea-hook()
      (save-excursion
        (while (re-search-forward "\r\n" nil t)
          (replace-match "\n" nil nil))
        (delete-other-windows)))

    (add-hook 'w3m-form-input-textarea-mode-hook 'dka-w3m-textarea-hook)

    (bind-key "<return>" 'w3m-view-url-with-external-browser
              w3m-minor-mode-map)
    (bind-key "S-<return>" 'w3m-safe-view-this-url w3m-minor-mode-map)

    (use-package w3m-lnum)))

#+end_src

*** wcount-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , wcount-mode

(use-package wcount-mode
  :commands wcount)

#+end_src
*** whitespace
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , whitespace

(use-package whitespace
  :diminish (global-whitespace-mode
             whitespace-mode
             whitespace-newline-mode)
  :commands (whitespace-buffer
             whitespace-cleanup
             whitespace-mode)
  :init
  (progn
    (hook-into-modes 'whitespace-mode
                     '(prog-mode-hook
                       c-mode-common-hook))

    (defun normalize-file ()
      (interactive)
      (save-excursion
      (goto-char (point-min))
        (whitespace-cleanup)
        (delete-trailing-whitespace)
        (goto-char (point-max))
        (delete-blank-lines)
        (set-buffer-file-coding-system 'unix)
        (goto-char (point-min))
        (while (re-search-forward "\r$" nil t)
          (replace-match ""))
        (set-buffer-file-coding-system 'utf-8)
        (let ((require-final-newline t))
          (save-buffer))))

    (defun maybe-turn-on-whitespace ()
      "Depending on the file, maybe clean up whitespace."
      (let ((file (expand-file-name ".clean"))
            parent-dir)
        (while (and (not (file-exists-p file))
                    (progn
                      (setq parent-dir
                            (file-name-directory
                             (directory-file-name
                              (file-name-directory file))))
                      ;; Give up if we are already at the root dir.
                      (not (string= (file-name-directory file)
                                    parent-dir))))
          ;; Move up to the parent dir and try again.
          (setq file (expand-file-name ".clean" parent-dir)))
        ;; If we found a change log in a parent, use that.
        (when (and (file-exists-p file)
                   (not (file-exists-p ".noclean"))
                   (not (and buffer-file-name
                             (string-match "\\.texi\\'" buffer-file-name))))
          (add-hook 'write-contents-hooks
                    #'(lambda ()
                        (ignore (whitespace-cleanup))) nil t)
          (whitespace-cleanup))))

    (add-hook 'find-file-hooks 'maybe-turn-on-whitespace t))

  :config
  (progn
    (remove-hook 'find-file-hooks 'whitespace-buffer)
    (remove-hook 'kill-buffer-hook 'whitespace-buffer)))

#+end_src
*** winner
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , winner

(use-package winner
  :diminish winner-mode
  :if (not noninteractive)
  :init
  (progn
    (winner-mode 1)

    (bind-key "M-N" 'winner-redo)
    (bind-key "M-P" 'winner-undo)))

#+end_src
*** workgroups
#+begin_src emacs-lisp
;;;_ , workgroups

(use-package workgroups
  :diminish workgroups-mode
  :if (not noninteractive)
  :init
  (progn
    (workgroups-mode 1)

    (let ((workgroups-file (expand-file-name "workgroups" user-data-directory)))
      (if (file-readable-p workgroups-file)
          (wg-load workgroups-file)))

    (bind-key "C-\\" 'wg-switch-to-previous-workgroup wg-map)
    (bind-key "\\" 'toggle-input-method wg-map)))

#+end_src
*** wrap-region
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , wrap-region

(use-package wrap-region
  :commands wrap-region-mode
  :diminish wrap-region-mode
  :config
  (wrap-region-add-wrappers
   '(("$" "$")
     ("/" "/" nil ruby-mode)
     ("/* " " */" "#" (java-mode javascript-mode css-mode c-mode c++-mode))
     ("`" "`" nil (markdown-mode ruby-mode shell-script-mode)))))

#+end_src
*** write-room
:PROPERTIES:
:tangle:   yes
:END:


#+begin_src emacs-lisp
;;;_ , write-room
(defvar in-write-room nil)

(defun write-room ()
  "Make a frame without any bling."
  (interactive)
  ;; to restore:
  ;; (setq mode-line-format (default-value 'mode-line-format))
  (let ((frame (make-frame
                '((minibuffer . nil)
                  (vertical-scroll-bars . nil)
                  (left-fringe . 0); no fringe
                  (right-fringe . 0)
                  ;;(background-mode . dark)
                  ;;(background-color . "cornsilk")
                  ;;(foreground-color . "black")
                  (cursor-color . "green")
                  (border-width . 0)
                  (border-color . "black"); should be unnecessary
                  (internal-border-width . 64); whitespace!
                  (cursor-type . box)
                  (menu-bar-lines . 0)
                  (tool-bar-lines . 0)
                  (fullscreen . fullboth)  ; this should work
                  (unsplittable . t)))))
    (select-frame frame)
    (find-file "~/Documents/Notes.txt")
    (setq mode-line-format nil
          fill-column 65)
    (set-window-margins (selected-window) 50 50)))

(defun toggle-write-room ()
  (interactive)
  (if in-write-room
      (progn
        (select-frame (make-frame))
        (setq mode-line-format (default-value 'mode-line-format))
        (setq in-write-room nil))
    (progn
      (setq in-write-room t)
      (write-room))))

(bind-key "C-c w" 'toggle-write-room)
#+end_src

*** yasnippet
:PROPERTIES:
:tangle:  yes
:END:

#+begin_src emacs-lisp
  ;;;_ , yasnippet
  
  (use-package yasnippet
    :if (not noninteractive)
    :commands (yas-minor-mode
               yas-expand
               yas-trigger-key
               yas-org-very-safe-expand
               yas-next-field-or-maybe-expand)
    :diminish yas-minor-mode
    :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
    :init
    (progn
      ;;(yas-global-mode t)
      (defun yas-org-very-safe-expand ()
        (let ((yas-fallback-behavior 'return-nil)) (yas-expand)))
      
      (hook-into-modes #'(lambda () (yas-minor-mode 1))
       '(prog-mode-hook
         org-mode-hook
         ruby-mode-hook
         message-mode-hook
         gud-mode-hook
         erc-mode-hook))
      (add-hook 'org-mode-hook
                (lambda ()
                  (set (make-local-variable 'yas-trigger-key) [tab])
                  (add-to-list 'org-tab-first-hook 'yas-org-very-safe-expand))))
    :config
    (progn
      (yas-load-directory (expand-file-name "snippets/" user-emacs-directory))
  
      (bind-key "<tab>" 'yas-next-field-or-maybe-expand yas-keymap)
  
      (defun yas-new-snippet (&optional choose-instead-of-guess)
        (interactive "P")
        (let ((guessed-directories (yas-guess-snippet-directories)))
          (switch-to-buffer "*new snippet*")
          (erase-buffer)
          (kill-all-local-variables)
          (snippet-mode)
          (set (make-local-variable 'yas-guessed-modes)
               (mapcar #'(lambda (d)
                           (intern (yas-table-name (car d))))
                       guessed-directories))
          (unless (and choose-instead-of-guess
                       (not (y-or-n-p "Insert a snippet with useful headers? ")))
            (yas-expand-snippet "\
    # -*- mode: snippet -*-
    # name: $1
    # --
    $0"))))
      (defvar ctl-c-y-map)
      (define-prefix-command 'ctl-c-y-map)
      (bind-key "C-c y" 'ctl-c-y-map)
      (bind-key "C-c y TAB" 'yas-expand)
      (bind-key "C-c y n" 'yas-new-snippet)
      (bind-key "C-c y f" 'yas-find-snippets)
      (bind-key "C-c y r" 'yas-reload-all)
      (bind-key "C-c y v" 'yas-visit-snippet-file)))
  
#+end_src

*** yaoddmuse
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , yaoddmuse

(use-package yaoddmuse
  :bind (("C-c w f" . yaoddmuse-browse-page-default)
         ("C-c w e" . yaoddmuse-edit-default)
         ("C-c w p" . yaoddmuse-post-library-default)))

#+end_src
*** zencoding-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , zencoding-mode

(use-package zencoding-mode
  :commands zencoding-mode
  :init
  (progn
    (add-hook 'nxml-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook
              #'(lambda ()
                (bind-key "<return>" 'newline-and-indent html-mode-map))))

  :config
  (progn
    (defvar zencoding-mode-keymap (make-sparse-keymap))
    (bind-key "C-c C-c" 'zencoding-expand-line zencoding-mode-keymap)
    (unbind-key "C-<return>" zencoding-mode-keymap)))

#+end_src

* files
  :PROPERTIES:
  :tangle:   no
  :END:

#+name: init-file-loads
| file                 | toggle |
|----------------------+--------|
| org-mode-prequel.org |        |
| org-mode.org         |        |
| org-mode-mods.org    |        |
| my-old-org.org       |        |

#+begin_src emacs-lisp :var init-file-loads=init-file-loads
  (defvar other-init-files
        (list ())
        "Files that are loaded in addition to dotemacs.org.")
  (setq file-loads (org-table-list-and-toggle init-file-loads))
  (dolist (file file-loads)
    (org-babel-load-file (expand-file-name file user-emacs-directory)))
#+end_src

* endboot
:PROPERTIES:
:tangle:   yes
:END:
** Load customization settings (turned off)
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , Load customization settings

(defvar running-alternate-emacs nil)

(if (string-match (concat "/Applications/\\(Misc/\\)?"
                          "Emacs\\([A-Za-z]+\\).app/Contents/MacOS/")
                  invocation-directory)

    (let ((settings (with-temp-buffer
                      (insert-file-contents
                       (expand-file-name "settings.el" user-emacs-directory))
                      (goto-char (point-min))
                      (read (current-buffer))))
          (suffix (downcase (match-string 2 invocation-directory))))

      (setq running-alternate-emacs t
            user-data-directory
            (replace-regexp-in-string "/data/" (format "/data-%s/" suffix)
                                      user-data-directory))

      (let* ((regexp "/\\.emacs\\.d/data/")
             (replace (format "/.emacs.d/data-%s/" suffix)))
        (dolist (setting settings)
          (let ((value (and (listp setting)
                            (nth 1 (nth 1 setting)))))
            (if (and (stringp value)
                     (string-match regexp value))
                (setcar (nthcdr 1 (nth 1 setting))
                        (replace-regexp-in-string regexp replace value)))))

        (eval settings)))

  (load (expand-file-name "settings" user-emacs-directory)))

#+end_src

** simple custom

Custom file load needs to go at the end, to override org-mode.org
settings.
 
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "settings.el" user-emacs-directory))
(load custom-file)
#+end_src

** Post initialization
#+begin_src emacs-lisp
;;;_. Post initialization

(when window-system
  (let ((elapsed (float-time (time-subtract (current-time)
                                            emacs-start-time))))
    (message "Loading %s...done (%.3fs)" load-file-name elapsed))

  (add-hook 'after-init-hook
            `(lambda ()
               (let ((elapsed (float-time (time-subtract (current-time)
                                                         emacs-start-time))))
                 (message "Loading %s...done (%.3fs) [after-init]"
                          ,load-file-name elapsed)))
            t))

#+end_src
  
* clipboard
:PROPERTIES:
:tangle:   no
:END:
** other dots

| directory name      | http                                             |
|---------------------+--------------------------------------------------|
| emacs24-starter-kit | https://github.com/eschulte/emacs24-starter-kit  |
| jwiegley            | https://github.com/jwiegley/dot-emacs            |
| prelude             | https://github.com/bbatsov/prelude               |
| emacs-live          | https://github.com/overtone/emacs-live           |
| defunkt             | https://github.com/defunkt/emacs                 |
| cabbage             | https://github.com/senny/cabbage                 |
| purcell             | https://github.com/purcell/emacs.d               |
| magnars             | https://github.com/magnars/.emacs.d              |
| ghoseb              | https://github.com/ghoseb/dotemacs               |
| rmm5t               | https://github.com/rmm5t/dotfiles                |
| alexott             | https://github.com/alexott/emacs-configs         |
| starter-kit         | https://github.com/technomancy/emacs-starter-kit |


Other sites
- [[info:emacs#Init%20File][info:emacs#Init File]]
- http://www.emacswiki.org/emacs/RobertAdesamConfig
- http://www.emacswiki.org/emacs/EmacsInitFileOfSylecn
- http://www.emacswiki.org/emacs/CategoryDotEmacs

** debugs and tools
:PROPERTIES:
:tangle:   no
:END:
*** hacking jw init.el
- regexp-search-replace
  
  #+begin_example
  ^;;;_[,. ]+\(.*\)$  
  #+end_example

  #+begin_example
  '#+end_src
  '** \1
  '#+begin_src emacs-lisp
  '\&  
  #+end_example
- clean-up extra end_src and insert last one
- adjust sections manually (allout format = programmatically possible too)
- add column properties thingy to add tangle option
- turn tangle on

*** alternative load-path method

#+begin_src emacs-lisp
  (defun test-funk ()
    (setq src-dir (expand-file-name "src" user-emacs-directory))
    ;; add the src directory to the load path
    (add-to-list 'load-path src-dir user-emacs-directory)
    ;; load all subdirectories
      (when (file-exists-p src-dir)
        (let ((default-directory src-dir))
          (normal-top-level-add-subdirs-to-load-path))))
#+end_src

#+begin_src emacs-lisp
  (defun test-funk ()
    (setq src-dir (expand-file-name "src" user-emacs-directory))
     (when (file-exists-p src-dir)
        (add-to-list 'load-path src-dir)
        (mapc #'sk-load
              (remove-duplicates
               (mapcar #'remove-extension
                       (directory-files user-dir t ".*\.\\(org\\|el\\)\\(\\.gpg\\)?$"))
               :test #'string=))))))
#+end_src

*** current startup bugz and readings
**** flet
`flet' is an obsolete macro (as of 24.3); use either `cl-flet' or `cl-letf'. [3 times]
**** babel insisting on messaging tangled
**** diary
No event to add
Appointment reminders enabled (no diary file found)
**** eieio
Unsafe call to `eieio-persistent-read'.



**** org-modifier
org-modifier-cursor-error: This command is active in special context like tables, headlines or items

**** CTags
Exuberant CTags not found.  Found ectags that comes with Emacs

**** DONE slow packages
CLOSED: [2012-12-28 Fri 23:57]
:LOGBOOK:
- State "DONE"       from "NEXT"       [2012-12-28 Fri 23:57]
CLOCK: [2012-12-28 Fri 20:29]--[2012-12-28 Fri 23:50] =>  3:21
:END:
Configuring package gnus...done (1.473s)
Loading package bbdb-gnus...done (0.905s)
Loading package org-magit...done (0.996s)
Configuring package erc...done (0.419s)
Loading package erc-yank...done (0.374s)
Loading /Users/tonyday/.emacs.d/dotemacs.el...done (10.830s) [after-init]

**** yas load messages
[yas] Loading compiled snippets from /Users/tonyday/.emacs.d/snippets/org-mode
[yas] Prepared just-in-time loading for /Users/tonyday/git/jwiegley-dot-emacs/site-lisp/yasnippet/snippets
[yas] Prepared just-in-time loading for ~/.emacs.d/snippets
[yas] Reloaded everything (snippets will load just-in-time)....




** development area
:PROPERTIES:
:tangle:   no
:END:

*** html5check hook
#+begin_src emacs-lisp
  (add-hook 'html-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c v")
                           (lambda () (interactive)
                             (save-buffer)
                             (shell-command (concat "html5check.py " (shell-quote-argument (buffer-file-name))))
                             ))))
#+end_src
** automated git

#+begin_src sh
#!/bin/sh
REPO="tonyday567.github.com"

echo "Repository: $REPO"
cd ~/git/$REPO
# Remove deleted files
git ls-files --deleted -z
git add .
git commit -m "automatic commit"
#+end_src
