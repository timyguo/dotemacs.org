#+TITLE: dotemacs
#+AUTHOR: Tony Day
#+EMAIL: tonyday567 at gmail dot com
#+COLUMNS: %25ITEM %30tangle
#+PROPERTIES: tangle yes

* upfront
:PROPERTIES:
:tangle:   no
:END:

** design
:PROPERTIES:
:tangle:   no
:END:

General design:
- is restrained by the necessary existence of init.el.
- file structure is as flat as possible, subject to submodule needs
- is opinionated as to what should be added (mostly according to
  questionable author tastes)
- is mostly about hooking jwiegley dots up, especially use-package
  and bind, and then doing things to them that are dangerous.

** flow 
:LOGBOOK:
:END:
The main sections are (in order)
- bootstrap. stuff that absolutely has to go at the front and load before
  everything else. order matters.
- guff. code that is not associated with packages but where ordering
  is unimportant.
- packages. package requires and configurations that can be put most anywhere and can be
  unordered (or in alphabetical order for the neatos).
- files. file loads that are files just for convenience (and can be loaded
  in alphabetical order).
- endboot. stuff that has to go at the end.


* init.el
:PROPERTIES:
:tangle:   init.el
:END:

The init.el file is the only file in the startup of emacs
that *needs* to be a .el file.  If you update it here and don't
tangle it the old copy will remain in place only to be overwritten
automatically next restart.

Not much we can do about that.

It does exactly 3 things.
1. finds out where it is and sets the current directory as the
   user-emacs-directory (~/.emacs.d in 99% of cases these days). This
   means that it can start anywhere if pointed to with:
  
   #+begin_src sh :tangle no
     /Applications/Emacs.app/Contents/MacOS/Emacs -q -l not-the-home/init.el     
   #+end_src
  
  or

  #+begin_src sh :tangle no
    emacs -q -l not-the-home/init.el     
  #+end_src
  
  The other way to test outside of your regular ~/.emacs.d is to set
  $HOME=~/fakehome and place init.el in ~/fakehome/.emacs.d.  
2. loads the org directory (if it exists).  This is needed in case
  there is a more recent org-mode installed in which case usage of
  babel before loading the path will result in a mixed install.  Not
  fun debugging that.    
3. loads the /real/ init code, which i have called dotemacs and which
   is contained in this file.

** debug initial values
:PROPERTIES:
:tangle:   no
:END:
   set debugs as separate blocks and turn on and off in org using tangle
     #+begin_src emacs-lisp
     (defun debug-message (&optional debug-name debug-value)
             (message (concat 
                "#+begin_debug\n"
                (format "%s\n" buffer-file-name)
                (if debug-name
                  (format "%s\n" debug-name))
                (if debug-value
                    (format "%s\n" debug-value))
                "#+end_debug\n")))
     #+end_src

  #+begin_src emacs-lisp
     (debug-message "load-path init.el entry" load-path)
     (debug-message "user-emacs-directory init.el entry" user-emacs-directory)
  #+end_src
 
** init.el

  
#+Begin_src emacs-lisp :tangle init.el :var tangled-in=(buffer-file-name)
  ;; see dotemacs.org for documentation
  (setq user-emacs-directory
        (file-name-directory (or load-file-name user-emacs-directory "~/.emacs.d/")))
  (defvar org-dir
  "repos/jwiegley/override/org-mode/lisp"
  "location of the directory containing org-mode")
  (add-to-list 'load-path (expand-file-name org-dir user-emacs-directory))
  (defvar dotemacs-org-file
  "dotemacs.org"
  "Name of the org file containing the main startup code")
  (if (boundp 'tangled-in)
     (setq dotemacs-org-file tangled-in))
  (org-babel-load-file (expand-file-name dotemacs-org-file user-emacs-directory))
#+end_src

* bootstrap
:PROPERTIES:
:tangle:   yes
:END:
** initialization
:PROPERTIES:
:TANGLE:   yes
:END:

#+begin_src emacs-lisp
;;;_. Initialization

(setq message-log-max 16384)

(defconst emacs-start-time (current-time))

(unless noninteractive
  (message "Loading %s..." load-file-name))

#+end_src

** org table defuns

Helper code to enable the use of org-tables in the stratup process.
Remember right here we are in a load environment and relying on
standard emacs packages to do stuff.

#+begin_src emacs-lisp
(require 'cl)
(defun org-table-list-and-toggle (table)
"turns an org-table into a list"                                       
(if (eq (cadr table) 'hline) 
    (setq table (cddr table)))
(loop for el in table
      when (not (equal "" (cadr el))) 
      collect
      (car el)))

  (defun org-table-remove-header (table)
    "turns an org-table into a list"                                       
    (if (eq (cadr table) 'hline) 
        (setq table (cddr table))))
#+end_src
 
** load-path
  :PROPERTIES:
  :tangle: 
  :END:
*** path load defuns
#+begin_src emacs-lisp
(defun add-to-load-path (path &optional dir)
  "add dir to load path. "  
  (setq load-path
        (cons (expand-file-name path (or dir user-emacs-directory)) 
load-path)))

(defun add-to-load-path-include-subdirs (path)
  "add level 1 subdirectories of path to te load-path."
  (add-to-load-path path)
  (dolist (entry (nreverse (directory-files-and-attributes
                            (expand-file-name path user-emacs-directory))))
    (if (and (cadr entry)
             (not (equal "." (car entry)))
             (not (equal ".." (car entry)))) 
        (add-to-load-path (car entry)
                          (expand-file-name path user-emacs-directory)))))
#+end_src

*** group load path table

These directory groups (directory and sub-directories) are added to the path.

#+name: group-load-path-table
| directory                | toggle |
|--------------------------+--------|
| site-lisp                | t      |
| repos/jwiegley/site-lisp | t      |
| repos/jwiegley/override  | t      |
| repos/jwiegley/lisp      | t      |
| elpa                     | t      |

And here's where we start taking advantage of using org on startup.
If you would like to add more group loads, just add to the above
table. You can temporarily turn anything off by deleting the toggle
row.

#+begin_src emacs-lisp :var table=group-load-path-table
(defvar group-load-directories
      (list "lisp" "site-lisp")
      "directories that should have their subdirectories added 
to the load-path. Can be absolute or relative to user-emacs-directory")

(setq group-load-directories (org-table-list-and-toggle table))
(mapc #'add-to-load-path-include-subdirs
          (nreverse group-load-directories))
#+end_src

*** load path table

Any other directories needed on the path go here:

#+name: load-path-table
| directory                                                 | toggle |
|-----------------------------------------------------------+--------|
| ~/.emacs.d                                                | t      |
| ~/.emacs.d/elpa/ess-20121027.2218/lisp                    | t      |
| ~/.emacs.d/repos/jwiegley/overrides/org-mode/contrib/lisp | t      |

#+begin_src emacs-lisp :var table=load-path-table
(defvar path-directories
      (list "~/.emacs.d")
      "Directories that should be added to load-path.")

(setq path-directories (org-table-list-and-toggle table))
    (mapc #'add-to-load-path
          (nreverse path-directories))
    (setq load-path (delete-dups load-path))
(require 'autoloads nil t)
(require 'cus-load nil t)
#+end_src

#+results:
: cus-load

*** load-path check
    :PROPERTIES:
    :tangle:   no
    :END:

checking on the result ...

The nice thing here is the startup process can store results in
variable, or you can just C-c C-c the block in org-mode after the event.

#+begin_src emacs-lisp
(setq load-path-check 
(loop for f in load-path
               collect
               (list f)))
#+end_src

#+RESULTS:
| /Users/tonyday/.emacs.d                                                                                                   |
| /Users/tonyday/.emacs.d/elpa/ess-20121027.2218/lisp                                                                       |
| /Users/tonyday/.emacs.d/repos/jwiegley/overrides/org-mode/contrib/lisp                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/org-mode/contrib/lisp                                                     |
| /Users/tonyday/.emacs.d/site-lisp/less-css-mode                                                                           |
| /Users/tonyday/.emacs.d/site-lisp/o-blog                                                                                  |
| /Users/tonyday/.emacs.d/site-lisp                                                                                         |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ac                                                                       |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ace-jump-mode                                                            |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/asynk                                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/auctex                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/auto-overlays                                                            |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/autopair                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/bm                                                                       |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/bookmark-plus                                                            |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/boxquote                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/command-log-mode                                                         |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/debbugs                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/deft                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/dired-sync                                                               |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/doxymacs                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/dvc                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/el-get                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/el-mock                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/elisp-depend                                                             |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/elisp-slime-nav                                                          |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/elnode                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/emacs-edbi                                                               |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/emacs-quickrun                                                           |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/emacs-w3m                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/emms                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ess                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/eval-expr                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ghc-mod                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/gist                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/git-commit-mode                                                          |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/haskell-mode                                                             |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/helm                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/helm-descbinds                                                           |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/hpaste                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/hsenv.el                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ido-hacks                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/info-lookmore                                                            |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ipa-el                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/lua-mode                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/lusty-emacs                                                              |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/macrostep                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/magit                                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/markdown-mode                                                            |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/melpa                                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/org-magit                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/org-merge-driver                                                         |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/python-mode                                                              |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/ruby-mode                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/session                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/slime                                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/sunrise-commander                                                        |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/swank-js                                                                 |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/workgroups                                                               |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/wrap-region                                                              |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/yaml-mode                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/yari-with-buttons                                                        |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/yasnippet                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp/zencoding-mode                                                           |
| /Users/tonyday/.emacs.d/repos/jwiegley/site-lisp                                                                          |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/bbdb                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/gnus                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/org-mode                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/tramp                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/override                                                                           |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/alert                                                                         |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/bind-key                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/chess                                                                         |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/emacs-async                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/emacs-edg                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/erc-yank                                                                      |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/gnus-harvest                                                                  |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/haskell-config                                                                |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/initsplit                                                                     |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/muse                                                                          |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/planner                                                                       |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/regex-tool                                                                    |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/springboard                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp/use-package                                                                   |
| /Users/tonyday/.emacs.d/repos/jwiegley/lisp                                                                               |
| /Users/tonyday/.emacs.d/elpa/anything-1.287                                                                               |
| /Users/tonyday/.emacs.d/elpa/archives                                                                                     |
| /Users/tonyday/.emacs.d/elpa/auctex-11.86                                                                                 |
| /Users/tonyday/.emacs.d/elpa/bbdb-20120923.1954                                                                           |
| /Users/tonyday/.emacs.d/elpa/clojure-mode-1.11.5                                                                          |
| /Users/tonyday/.emacs.d/elpa/csv-mode-20091203.1911                                                                       |
| /Users/tonyday/.emacs.d/elpa/csv-nav-20091121.37                                                                          |
| /Users/tonyday/.emacs.d/elpa/elisp-slime-nav-0.2                                                                          |
| /Users/tonyday/.emacs.d/elpa/ess-20121027.2218                                                                            |
| /Users/tonyday/.emacs.d/elpa/find-file-in-project-3.2                                                                     |
| /Users/tonyday/.emacs.d/elpa/htmlize-1.39                                                                                 |
| /Users/tonyday/.emacs.d/elpa/ido-ubiquitous-1.5                                                                           |
| /Users/tonyday/.emacs.d/elpa/js-comint-0.0.1                                                                              |
| /Users/tonyday/.emacs.d/elpa/js2-mode-20090814                                                                            |
| /Users/tonyday/.emacs.d/elpa/json-1.2                                                                                     |
| /Users/tonyday/.emacs.d/elpa/magit-1.1.1                                                                                  |
| /Users/tonyday/.emacs.d/elpa/magithub-0.2                                                                                 |
| /Users/tonyday/.emacs.d/elpa/org-magit-0.2.0                                                                              |
| /Users/tonyday/.emacs.d/elpa/org2blog-0.5                                                                                 |
| /Users/tonyday/.emacs.d/elpa/paredit-22                                                                                   |
| /Users/tonyday/.emacs.d/elpa/slime-20100404.1                                                                             |
| /Users/tonyday/.emacs.d/elpa/smex-1.1.4                                                                                   |
| /Users/tonyday/.emacs.d/elpa/xml-rpc-1.6.8                                                                                |
| /Users/tonyday/.emacs.d/elpa/yaml-mode-0.0.7                                                                              |
| /Users/tonyday/.emacs.d/elpa/yasnippet-0.8.0                                                                              |
| /Users/tonyday/.emacs.d/elpa/yasnippet-bundle-0.6.1                                                                       |
| /Users/tonyday/.emacs.d/elpa/zenburn-theme-1.5                                                                            |
| /Users/tonyday/.emacs.d/elpa                                                                                              |
| /Users/tonyday/.emacs.d/repos/jwiegley/override/org-mode/lisp                                                             |
| /Users/david/src/emacs-dev/emacs-bzr/build-2012-10-24/nextstep/Emacs.app/Contents/Resources/share/emacs/24.2.50/site-lisp |
| /Users/david/src/emacs-dev/emacs-bzr/build-2012-10-24/nextstep/Emacs.app/Contents/Resources/share/emacs/site-lisp         |
| /Applications/Emacs241012.app/Contents/Resources/site-lisp                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp                                                                     |
| /Applications/Emacs241012.app/Contents/Resources/lisp/vc                                                                  |
| /Applications/Emacs241012.app/Contents/Resources/lisp/url                                                                 |
| /Applications/Emacs241012.app/Contents/Resources/lisp/textmodes                                                           |
| /Applications/Emacs241012.app/Contents/Resources/lisp/progmodes                                                           |
| /Applications/Emacs241012.app/Contents/Resources/lisp/play                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/org                                                                 |
| /Applications/Emacs241012.app/Contents/Resources/lisp/nxml                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/net                                                                 |
| /Applications/Emacs241012.app/Contents/Resources/lisp/mh-e                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/mail                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/language                                                            |
| /Applications/Emacs241012.app/Contents/Resources/lisp/international                                                       |
| /Applications/Emacs241012.app/Contents/Resources/lisp/gnus                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/eshell                                                              |
| /Applications/Emacs241012.app/Contents/Resources/lisp/erc                                                                 |
| /Applications/Emacs241012.app/Contents/Resources/lisp/emulation                                                           |
| /Applications/Emacs241012.app/Contents/Resources/lisp/emacs-lisp                                                          |
| /Applications/Emacs241012.app/Contents/Resources/lisp/cedet                                                               |
| /Applications/Emacs241012.app/Contents/Resources/lisp/calendar                                                            |
| /Applications/Emacs241012.app/Contents/Resources/lisp/calc                                                                |
| /Applications/Emacs241012.app/Contents/Resources/lisp/obsolete                                                            |
| /Applications/Emacs241012.app/Contents/Resources/leim                                                                     |

** elpa
   :PROPERTIES:
   :tangle:   yes
   :END:

*** elpa archive repositories
    :PROPERTIES:
    :tangle: 
    :END:

#+begin_src emacs-lisp
    (setq package-enable-at-startup nil)
    (setq package-archives
          '(("melpa" . "http://melpa.milkbox.net/packages/")
            ("gnu"         . "http://elpa.gnu.org/packages/")
            ("marmalade"   . "http://marmalade-repo.org/packages/")))
    ;;(package-initialize)
 #+end_src

*** dependency checks
:PROPERTIES:
:tangle:   no
:END:

#+TBLNAME: table-elpa-check
| package              | check? | notes                      |
|----------------------+--------+----------------------------|
| auctex               | t      |                            |
| clojure-mode         |        |                            |
| elisp-slime-nav      | t      | add to sklisp              |
| find-file-in-project | t      | delay                      |
| idle-highlight-...   |        | didnt install properly     |
| ido-ubiquitous       | t      | package add elsewhere      |
| js-comint            |        |                            |
| js2-mode             |        |                            |
| json                 |        |                            |
| magit                | t      |                            |
| magithub             | t      | learn                      |
| org                  |        | direct from repo           |
| org-magit            |        |                            |
| org2blog             |        |                            |
| paredit              | t      |                            |
| slime                | t      | check                      |
| smex                 | t      |                            |
| xml-rpc              | t      | dep for org2blog           |
| yaml-mode            | t      | check                      |
| yasnippet            | t      |                            |
| zenburn-theme        | t      | check how themes are added |

#+begin_src emacs-lisp :var table=table-elpa-check
  (defvar package-list-to-check
        (list "")
        "packages that should be checked and loaded if not found")
  (setq package-list-to-check (org-table-list-and-toggle table))
      (unless package-archive-contents
        (package-refresh-contents))
      (dolist (package package-list-to-check)
         (eval (car (read-from-string (format "(unless (package-installed-p '%s)
                                               (package-install '%s))" package package)))))
#+end_src

#+results:

** theme
  #+begin_src emacs-lisp
    (setq custom-theme-load-path (quote (custom-theme-directory t 
          "/Users/tonyday/.emacs.d/elpa/zenburn-theme-1.5")))
    (load-theme 'zenburn t)
  #+end_src

** use-package and bind
   :PROPERTIES:
   :tangle: 
   :END:
#+begin_src emacs-lisp
(require 'use-package)
(eval-when-compile
  (setq use-package-verbose (null byte-compile-current-file)))
#+end_src

#+begin_src emacs-lisp
  (require 'bind-key)    
  (defun bind-keys-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(bind-key %S '%s)" row))))))
#+end_src

#+RESULTS:
: bind-keys-from-table

** read system environment
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , Read system environment

(let ((plist (expand-file-name "~/.MacOSX/environment.plist")))
  (when (file-readable-p plist)
    (let ((dict (cdr (assq 'dict (cdar (xml-parse-file plist))))))
      (while dict
        (if (and (listp (car dict))
                 (eq 'key (caar dict)))
            (setenv (car (cddr (car dict)))
                    (car (cddr (car (cddr dict))))))
        (setq dict (cdr dict))))

    ;; Configure exec-path based on the new PATH
    (setq exec-path nil)
    (mapc (apply-partially #'add-to-list 'exec-path)
          (nreverse (split-string (getenv "PATH") ":")))))

#+end_src

** check emacs version
#+begin_src emacs-lisp
      (defvar running-alternate-emacs nil)
#+end_src
   
* guff
:PROPERTIES:
:tangle:   yes
:END:
** process settings table

#+name: process-settings-table
| variable                       | value |
|--------------------------------+-------|


#+name: process-settings-function-table
| function                   | args   |
|----------------------------+--------|


#+begin_src emacs-lisp
  (defun set-variables-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(setq %s %s)" row))))))

  (defun set-functions-from-table (data)
    "Takes a list of key bindings and commands (both in string format) and binds them using bind-key
  "
    (dolist (row data)
      (eval (car (read-from-string 
                  (apply 'format "(%s %s)" row))))))

#+end_src

  #+results:
  : set-functions-from-table

  - unit test one row
    #+begin_src emacs-lisp :tangle no
(setq row1 '("frame-title-format" "'(buffer-file-name \"%f\" (\"%b\"))" "" "window-system"))
(eval (car (read-from-string 
                (apply 'format "(setq %s %s)" row1))))
#+end_src

  #+begin_src emacs-lisp :var table=process-settings-table
  (set-variables-from-table (org-table-remove-header table))  
  #+end_src

  #+begin_src emacs-lisp :var table=process-settings-function-table
  (set-functions-from-table (org-table-remove-header table))
  #+end_src

** orphan settings
:PROPERTIES:
:tangle: 
:END:

Miscellaneous settings and snippets that I haven't org-tabled or categorised.
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** orphan requires

** orphaned defuns
** extra bindings
   :PROPERTIES:
   :tangle: 
   :END:

#+name: tob
| key       | binding                             |
|-----------+-------------------------------------|
| C-+       | text-scale-increase                 |
| C--       | text-scale-decrease                 |
| C-c C-v k | org-table-recalculate-buffer-tables |

- unit test one row
  #+begin_src emacs-lisp :var table=tob[2,] :tangle no
(setq row '("C-c C-v k" "org-table-recalculate-buffer-tables"))
(eval (car (read-from-string 
                     (apply 'format "(bind-key %S '%s)" row))))
#+end_src

  #+RESULTS:
  : org-table-recalculate-buffer-tables

#+begin_src emacs-lisp :var table=tob
  (bind-keys-from-table (org-table-remove-header table))  
#+end_src

#+RESULTS:

** utility macros and functions
#+begin_src emacs-lisp
;;;_ , Utility macros and functions

(defmacro hook-into-modes (func modes)
  `(dolist (mode-hook ,modes)
     (add-hook mode-hook ,func)))

(defun system-idle-time ()
  (with-temp-buffer
    (call-process "ioreg" nil (current-buffer) nil
                  "-c" "IOHIDSystem" "-d" "4" "-S")
    (goto-char (point-min))
    (and (re-search-forward "\"HIDIdleTime\" = \\([0-9]+\\)" nil t)
         (/ (float (string-to-number (match-string 1)))
            1000000000.0))))

(defun quickping (host)
  (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))

(defun cleanup-term-log ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (require 'ansi-color)
  (ansi-color-apply-on-region (point-min) (point-max))
  (goto-char (point-min))
  (while (re-search-forward "\\(.\\|
$\\|P.+\\\\\n\\)" nil t)
    (overlay-put (make-overlay (match-beginning 0) (match-end 0))
                 'invisible t))
  (set-buffer-modified-p nil))

(add-hook 'find-file-hooks
          (function
           (lambda ()
             (if (string-match "/\\.iTerm/.*\\.log\\'"
                               (buffer-file-name))
                 (cleanup-term-log)))))

#+end_src
** enable disabled commands
#+begin_src emacs-lisp
;;;_ , Enable disabled commands

(put 'downcase-region  'disabled nil)   ; Let downcasing work
(put 'erase-buffer     'disabled nil)
(put 'eval-expression  'disabled nil)   ; Let ESC-ESC work
(put 'narrow-to-page   'disabled nil)   ; Let narrowing work
(put 'narrow-to-region 'disabled nil)   ; Let narrowing work
(put 'set-goal-column  'disabled nil)
(put 'upcase-region    'disabled nil)   ; Let upcasing work

#+end_src
** keybindings
:PROPERTIES:
:tangle: 
:END:
#+begin_src emacs-lisp
;;;_. Keybindings

;; Main keymaps for personal bindings are:
;;
;;   C-x <letter>  primary map (has many defaults too)
;;   C-c <letter>  secondary map (not just for mode-specific)
;;   C-. <letter>  tertiary map
;;
;;   M-g <letter>  goto map
;;   M-s <letter>  search map
;;   M-o <letter>  markup map (even if only temporarily)
;;
;;   C-<capital letter>
;;   M-<capital letter>
;;
;;   A-<anything>
;;   M-A-<anything>
;;
;; Single-letter bindings still available:
;;   C- ,'";:?<>|!#$%^&*`~ <tab>
;;   M- ?#

#+end_src
*** global-map
#+begin_src emacs-lisp
;;;_ , global-map

#+end_src
**** C-?
:PROPERTIES:
:tangle: 
:END:
#+begin_src emacs-lisp
;;;_  . C-?

(defvar ctl-period-map)
(define-prefix-command 'ctl-period-map)
(bind-key "C-." 'ctl-period-map)

(bind-key* "<C-return>" 'other-window)

(defun collapse-or-expand ()
  (interactive)
  (if (> (length (window-list)) 1)
      (delete-other-windows)
    (bury-buffer)))

(bind-key "C-z" 'collapse-or-expand)

#+end_src
**** M-?
#+begin_src emacs-lisp
;;;_  . M-?

(defadvice async-shell-command (before uniqify-running-shell-command activate)
  (let ((buf (get-buffer "*Async Shell Command*")))
    (if buf
        (let ((proc (get-buffer-process buf)))
          (if (and proc (eq 'run (process-status proc)))
              (with-current-buffer buf
                (rename-uniquely)))))))

(bind-key "M-!" 'async-shell-command)
(bind-key "M-/" 'dabbrev-expand)
(bind-key "M-'" 'insert-pair)
(bind-key "M-\"" 'insert-pair)

(defun align-code (beg end &optional arg)
  (interactive "rP")
  (if (null arg)
      (align beg end)
    (let ((end-mark (copy-marker end)))
      (indent-region beg end-mark nil)
      (align beg end-mark))))

(bind-key "M-[" 'align-code)
(bind-key "M-`" 'other-frame)

(bind-key "M-j" 'delete-indentation-forward)
(bind-key "M-J" 'delete-indentation)

(bind-key "M-W" 'mark-word)

(defun mark-line (&optional arg)
  (interactive "p")
  (beginning-of-line)
  (let ((here (point)))
    (dotimes (i arg)
      (end-of-line))
    (set-mark (point))
    (goto-char here)))

(bind-key "M-L" 'mark-line)

(defun mark-sentence (&optional arg)
  (interactive "P")
  (backward-sentence)
  (mark-end-of-sentence arg))

(bind-key "M-S" 'mark-sentence)
(bind-key "M-X" 'mark-sexp)
(bind-key "M-H" 'mark-paragraph)
(bind-key "M-D" 'mark-defun)

(bind-key "M-g c" 'goto-char)
(bind-key "M-g l" 'goto-line)

(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))

(bind-key "M-s n" 'find-name-dired)
(bind-key "M-s o" 'occur)

#+end_src

**** M-C-?
#+begin_src emacs-lisp
;;;_  . M-C-?

(bind-key "<C-M-backspace>" 'backward-kill-sexp)

(defun isearch-backward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-backward))

(bind-key "C-M-r" 'isearch-backward-other-window)

(defun isearch-forward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-forward))

(bind-key "C-M-s" 'isearch-forward-other-window)

;; Some further isearch bindings
(bind-key "C-c" 'isearch-toggle-case-fold isearch-mode-map)
(bind-key "C-t" 'isearch-toggle-regexp isearch-mode-map)
(bind-key "C-^" 'isearch-edit-string isearch-mode-map)
(bind-key "C-i" 'isearch-complete isearch-mode-map)

#+end_src

#+results:
: isearch-complete

**** A-?
#+begin_src emacs-lisp
;;;_  . A-?

(define-key key-translation-map (kbd "A-TAB") (kbd "C-TAB"))

#+end_src
*** ctl-x-map
#+begin_src emacs-lisp
;;;_ , ctl-x-map

#+end_src
**** C-x ?
#+begin_src emacs-lisp
;;;_  . C-x ?

(bind-key "C-x B" 'ido-switch-buffer-other-window)
(bind-key "C-x d" 'delete-whitespace-rectangle)
(bind-key "C-x F" 'set-fill-column)
(bind-key "C-x t" 'toggle-truncate-lines)

    (defun transpose-windows (arg)
      "Transpose the buffers shown in two windows."
      (interactive "p")
      (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
        (while (/= arg 0)
          (let ((this-win (window-buffer))
                (next-win (window-buffer (funcall selector))))
            (set-window-buffer (selected-window) next-win)
            (set-window-buffer (funcall selector) this-win)
            (select-window (funcall selector)))
          (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
    (bind-key "C-x 4 t" 'transpose-windows)
  #+end_src

**** C-x C-?
#+begin_src emacs-lisp
;;;_  . C-x C-?

(defun duplicate-line ()
  "Duplicate the line containing point."
  (interactive)
  (save-excursion
    (let (line-text)
      (goto-char (line-beginning-position))
      (let ((beg (point)))
        (goto-char (line-end-position))
        (setq line-text (buffer-substring beg (point))))
      (if (eobp)
          (insert ?\n)
        (forward-line))
      (open-line 1)
      (insert line-text))))

(bind-key "C-x C-d" 'duplicate-line)
(bind-key "C-x C-e" 'pp-eval-last-sexp)
(bind-key "C-x C-n" 'next-line)


(defun find-alternate-file-with-sudo (filename)
  (interactive
   (list (read-file-name "Find alternate file: " nil
                         nil nil (concat "/sudo::" (buffer-file-name)))))
  (find-alternate-file filename))

(bind-key "C-x C-v" 'find-alternate-file-with-sudo)

#+end_src
**** C-x M-?
#+begin_src emacs-lisp
;;;_  . C-x M-?

(bind-key "C-x M-n" 'set-goal-column)

(defun refill-paragraph (arg)
  (interactive "*P")
  (let ((fun (if (memq major-mode '(c-mode c++-mode))
                 'c-fill-paragraph
               (or fill-paragraph-function
                   'fill-paragraph)))
        (width (if (numberp arg) arg))
        prefix beg end)
    (forward-paragraph 1)
    (setq end (copy-marker (- (point) 2)))
    (forward-line -1)
    (let ((b (point)))
      (skip-chars-forward "^A-Za-z0-9`'\"(")
      (setq prefix (buffer-substring-no-properties b (point))))
    (backward-paragraph 1)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (delete-horizontal-space)
    (while (< (point) end)
      (delete-indentation 1)
      (end-of-line))
    (let ((fill-column (or width fill-column))
          (fill-prefix prefix))
      (if prefix
          (setq fill-column
                (- fill-column (* 2 (length prefix)))))
      (funcall fun nil)
      (goto-char beg)
      (insert prefix)
      (funcall fun nil))
    (goto-char (+ end 2))))

(bind-key "C-x M-q" 'refill-paragraph)

#+end_src
*** mode-specific-map
#+begin_src emacs-lisp
;;;_ , mode-specific-map

#+end_src
**** C-c ?
#+begin_src emacs-lisp
;;;_  . C-c ?

(bind-key "C-c <tab>" 'ff-find-other-file)
(bind-key "C-c SPC" 'just-one-space)

;; inspired by Erik Naggum's `recursive-edit-with-single-window'
(defmacro recursive-edit-preserving-window-config (body)
  "*Return a command that enters a recursive edit after executing BODY.
 Upon exiting the recursive edit (with\\[exit-recursive-edit] (exit)
 or \\[abort-recursive-edit] (abort)), restore window configuration
 in current frame."
  `(lambda ()
     "See the documentation for `recursive-edit-preserving-window-config'."
     (interactive)
     (save-window-excursion
       ,body
       (recursive-edit))))

(bind-key "C-c 0"
  (recursive-edit-preserving-window-config (delete-window)))
(bind-key "C-c 1"
  (recursive-edit-preserving-window-config
   (if (one-window-p 'ignore-minibuffer)
       (error "Current window is the only window in its frame")
     (delete-other-windows))))

(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))

(bind-key "C-c d" 'delete-current-line)

(bind-key "C-c e E" 'elint-current-buffer)

(defun do-eval-buffer ()
  (interactive)
  (call-interactively 'eval-buffer)
  (message "Buffer has been evaluated"))

(bind-key "C-c e b" 'do-eval-buffer)
(bind-key "C-c e c" 'cancel-debug-on-entry)
(bind-key "C-c e d" 'debug-on-entry)
(bind-key "C-c e e" 'toggle-debug-on-error)
(bind-key "C-c e f" 'emacs-lisp-byte-compile-and-load)
(bind-key "C-c e j" 'emacs-lisp-mode)
(bind-key "C-c e l" 'find-library)
(bind-key "C-c e r" 'eval-region)
(bind-key "C-c e s" 'scratch)
(bind-key "C-c e v" 'edit-variable)

(defun find-which (name)
  (interactive "sCommand name: ")
  (find-file-other-window
   (substring (shell-command-to-string (format "which %s" name)) 0 -1)))

(bind-key "C-c e w" 'find-which)
(bind-key "C-c e z" 'byte-recompile-directory)

(bind-key "C-c f" 'flush-lines)
(bind-key "C-c g" 'goto-line)

(bind-key "C-c k" 'keep-lines)

(eval-when-compile
  (defvar emacs-min-top)
  (defvar emacs-min-left)
  (defvar emacs-min-height)
  (defvar emacs-min-width))

(unless noninteractive
  (if running-alternate-emacs
      (progn
        (defvar emacs-min-top (if (= 1050 (x-display-pixel-height)) 574 722))
        (defvar emacs-min-left 5)
        (defvar emacs-min-height 25)
        (defvar emacs-min-width 80))

    (defvar emacs-min-top 22)
    (defvar emacs-min-left (- (x-display-pixel-width) 918))
    (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
    (defvar emacs-min-width 100)))

(defun emacs-min ()
  (interactive)
  (set-frame-parameter (selected-frame) 'fullscreen nil)
  (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'top emacs-min-top)
  (set-frame-parameter (selected-frame) 'left emacs-min-left)
  (set-frame-parameter (selected-frame) 'height emacs-min-height)
  (set-frame-parameter (selected-frame) 'width emacs-min-width)

  (when running-alternate-emacs
    (set-background-color "grey85")
    (set-face-background 'fringe "gray80")))

(if window-system
    (add-hook 'after-init-hook 'emacs-min))

(defun emacs-max ()
  (interactive)
  (if t
      (progn
        (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
    (set-frame-parameter (selected-frame) 'top 26)
    (set-frame-parameter (selected-frame) 'left 2)
    (set-frame-parameter (selected-frame) 'width
                         (floor (/ (float (x-display-pixel-width)) 9.15)))
    (if (= 1050 (x-display-pixel-height))
        (set-frame-parameter (selected-frame) 'height
                             (if (>= emacs-major-version 24)
                                 66
                               55))
      (set-frame-parameter (selected-frame) 'height
                           (if (>= emacs-major-version 24)
                               75
                             64)))))

(defun emacs-toggle-size ()
  (interactive)
  (if (> (cdr (assq 'width (frame-parameters))) 100)
      (emacs-min)
    (emacs-max)))

(bind-key "C-c m" 'emacs-toggle-size)

(defun insert-date ()
  (interactive)
  (insert (format-time-string "%Y-%m-%d")))

(defcustom user-initials nil
  "*Initials of this user."
  :set
  #'(lambda (symbol value)
      (if (fboundp 'font-lock-add-keywords)
          (mapc
           #'(lambda (mode)
               (font-lock-add-keywords
                mode (list (list (concat "\\<\\(" value " [^:\n]+\\):")
                                 1 font-lock-warning-face t))))
           '(c-mode c++-mode emacs-lisp-mode lisp-mode
                    python-mode perl-mode java-mode groovy-mode
                    haskell-mode literate-haskell-mode)))
      (set symbol value))
  :type 'string
  :group 'mail)

(defun insert-user-timestamp ()
  "Insert a quick timestamp using the value of `user-initials'."
  (interactive)
  (insert (format "%s (%s): " user-initials
                  (format-time-string "%Y-%m-%d" (current-time)))))

(bind-key "C-c n" 'insert-user-timestamp)
(bind-key "C-c o" 'customize-option)
(bind-key "C-c O" 'customize-group)

(bind-key "C-c q" 'fill-region)
(bind-key "C-c r" 'replace-regexp)
(bind-key "C-c s" 'replace-string)
(bind-key "C-c u" 'rename-uniquely)

(autoload 'auth-source-search "auth-source")

(defun tinify-url (url)
  (interactive "sURL to shorten: ")
  (let* ((api-login "jwiegley")
         (api-key
          (funcall
           (plist-get
            (car (auth-source-search :host "api.j.mp" :user api-login
                                     :type 'netrc :port 80))
            :secret))))
    (cl-flet ((message (&rest ignore)))
      (with-current-buffer
          (let ((query
                 (format "format=txt&longUrl=%s&login=%s&apiKey=%s"
                         (url-hexify-string url) api-login api-key)))
            (url-retrieve-synchronously
             (concat "http://api.j.mp/v3/shorten?" query)))
        (goto-char (point-min))
        (re-search-forward "^$")
        (prog1
            (kill-new (buffer-substring (1+ (point)) (1- (point-max))))
          (kill-buffer (current-buffer)))))))

(bind-key "C-c U" 'tinify-url)

(defun view-clipboard ()
  (interactive)
  (delete-other-windows)
  (switch-to-buffer "*Clipboard*")
  (let ((inhibit-read-only t))
    (erase-buffer)
    (clipboard-yank)
    (goto-char (point-min))
    (html-mode)
    (view-mode)))

(bind-key "C-c V" 'view-clipboard)
(bind-key "C-c z" 'clean-buffer-list)

(bind-key "C-c [" 'align-regexp)
(bind-key "C-c =" 'count-matches)
(bind-key "C-c ;" 'comment-or-uncomment-region)

#+end_src
**** C-c C-?
#+begin_src emacs-lisp
;;;_  . C-c C-?

(defun delete-to-end-of-buffer ()
  (interactive)
  (kill-region (point) (point-max)))

(bind-key "C-c C-z" 'delete-to-end-of-buffer)

#+end_src
**** C-c M-?
#+begin_src emacs-lisp
;;;_  . C-c M-?

(defun unfill-paragraph (arg)
  (interactive "*p")
  (let (beg end)
    (forward-paragraph arg)
    (setq end (copy-marker (- (point) 2)))
    (backward-paragraph arg)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (when (> (count-lines beg end) 1)
      (while (< (point) end)
        (goto-char (line-end-position))
        (let ((sent-end (memq (char-before) '(?. ?\; ?! ??))))
          (delete-indentation 1)
          (if sent-end
              (insert ? )))
        (end-of-line))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "[^.;!?:]\\([ \t][ \t]+\\)" end t)
          (replace-match " " nil nil nil 1))))))

(bind-key "C-c M-q" 'unfill-paragraph)

(defun unfill-region (beg end)
  (interactive "r")
  (setq end (copy-marker end))
  (save-excursion
    (goto-char beg)
    (while (< (point) end)
      (unfill-paragraph 1)
      (forward-paragraph))))

#+end_src
*** ctl-period-map
#+begin_src emacs-lisp
;;;_ , ctl-period-map

#+end_src
**** C-. ?
#+begin_src emacs-lisp
;;;_  . C-. ?

(bind-key "C-. m" 'kmacro-keymap)

#+end_src
**** C-. C-i
#+begin_src emacs-lisp
;;;_  . C-. C-i

(bind-key "C-. C-i" 'indent-rigidly)

#+end_src
**** C-. C-c
#+begin_src emacs-lisp
(bind-key "C-. C-c" 'org-indent-indent-buffer)
#+end_src

**** C-. C-.
#+begin_src emacs-lisp
(defvar ctl-period-ctl-period-map)
(define-prefix-command 'ctl-period-ctl-period-map)
(bind-key "C-. C-." 'ctl-period-ctl-period-map)

(bind-key "C-. C-. d" 'describe-personal-keybindings)
(bind-key "C-. C-. n" 'next-buffer)
(bind-key "C-. C-. p" 'previous-buffer)
(bind-key "C-. C-. k" 'keyfreq-show)
(bind-key "C-. C-. b" 'bury-buffer)
(bind-key "C-. C-. f" 'recentf-open-files)

#+end_src

#+results:
: previous-buffer


*** help-map
#+begin_src emacs-lisp
;;;_ , help-map

(defvar lisp-find-map)
(define-prefix-command 'lisp-find-map)

(bind-key "C-h e" 'lisp-find-map)

#+end_src

#+results:
: lisp-find-map

**** C-h e ?
#+begin_src emacs-lisp
;;;_  . C-h e ?

(bind-key "C-h e c" 'finder-commentary)
(bind-key "C-h e e" 'view-echo-area-messages)
(bind-key "C-h e f" 'find-function)
(bind-key "C-h e F" 'find-face-definition)

(defun my-describe-symbol  (symbol &optional mode)
  (interactive
   (info-lookup-interactive-arguments 'symbol current-prefix-arg))
  (let (info-buf find-buf desc-buf cust-buf)
    (save-window-excursion
      (ignore-errors
        (info-lookup-symbol symbol mode)
        (setq info-buf (get-buffer "*info*")))
      (let ((sym (intern-soft symbol)))
        (when sym
          (if (functionp sym)
              (progn
                (find-function sym)
                (setq find-buf (current-buffer))
                (describe-function sym)
                (setq desc-buf (get-buffer "*Help*")))
            (find-variable sym)
            (setq find-buf (current-buffer))
            (describe-variable sym)
            (setq desc-buf (get-buffer "*Help*"))
            ;;(customize-variable sym)
            ;;(setq cust-buf (current-buffer))
            ))))

    (delete-other-windows)

    (cl-flet ((switch-in-other-buffer
            (buf)
            (when buf
              (split-window-vertically)
              (switch-to-buffer-other-window buf))))
      (switch-to-buffer find-buf)
      (switch-in-other-buffer desc-buf)
      (switch-in-other-buffer info-buf)
      ;;(switch-in-other-buffer cust-buf)
      (balance-windows))))

(bind-key "C-h e d" 'my-describe-symbol)
(bind-key "C-h e i" 'info-apropos)
(bind-key "C-h e k" 'find-function-on-key)
(bind-key "C-h e l" 'find-library)

(defvar lisp-modes  '(emacs-lisp-mode
                      inferior-emacs-lisp-mode
                      ielm-mode
                      lisp-mode
                      inferior-lisp-mode
                      lisp-interaction-mode
                      slime-repl-mode))

(defvar lisp-mode-hooks
  (mapcar (function
           (lambda (mode)
             (intern
              (concat (symbol-name mode) "-hook"))))
          lisp-modes))

(defun scratch ()
  (interactive)
  (let ((current-mode major-mode))
    (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
    (goto-char (point-min))
    (when (looking-at ";")
      (forward-line 4)
      (delete-region (point-min) (point)))
    (goto-char (point-max))
    (if (memq current-mode lisp-modes)
        (funcall current-mode))))

(bind-key "C-h e s" 'scratch)
(bind-key "C-h e v" 'find-variable)
(bind-key "C-h e V" 'apropos-value)

#+end_src

* packages
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_. Packages

#+end_src

*** o-blog
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , o-blog

(use-package o-blog
  :commands org-publish-blog
  :config
  (defun ob-push-to-dev()
    "copy site from scarce directory to dev."
    (interactive)
    (delete-directory "~/Sites/dev" t)
    (copy-directory "~/git/o-blog/example/out" "~/Sites/dev")
    (browse-url "http://127.0.0.1/~tonyday/dev/index.html"))
  :bind (("C-c C-v p" . org-publish-blog)
         ("C-c C-v q" . ob-push-to-dev)))
#+end_src

*** abbrev
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , abbrev

(use-package abbrev
  :commands abbrev-mode
  :diminish abbrev-mode
  :init
  (hook-into-modes #'abbrev-mode '(text-mode-hook))

  :config
  (progn
   (if (file-exists-p abbrev-file-name)
       (quietly-read-abbrev-file))

   (add-hook 'expand-load-hook
             (lambda ()
               (add-hook 'expand-expand-hook 'indent-according-to-mode)
               (add-hook 'expand-jump-hook 'indent-according-to-mode)))))

#+end_src
*** ace-jump-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ace-jump-mode

(use-package ace-jump-mode
  :bind ("C-. C-s" . ace-jump-mode))

#+end_src
*** allout
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , allout

(use-package allout
  :diminish allout-mode
  :commands allout-mode
  :config
  (progn
    (defvar allout-unprefixed-keybindings nil)

    (defun my-allout-mode-hook ()
      (dolist (mapping '((?b . allout-hide-bodies)
                         (?c . allout-hide-current-entry)
                         (?l . allout-hide-current-leaves)
                         (?i . allout-show-current-branches)
                         (?e . allout-show-entry)
                         (?o . allout-show-to-offshoot)))
        (bind-key (concat (format-kbd-macro allout-command-prefix)
                          " " (char-to-string (car mapping)))
                  (cdr mapping)
                  allout-mode-map))

      (if (memq major-mode lisp-modes)
          (unbind-key "C-k" allout-mode-map)))

    (add-hook 'allout-mode-hook 'my-allout-mode-hook)))

#+end_src
*** ascii
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ascii

(use-package ascii
  :commands (ascii-on ascii-toggle)
  :init
  (progn
    (defun ascii-toggle ()
      (interactive)
      (if ascii-display
          (ascii-off)
        (ascii-on)))

    (bind-key "C-c e A" 'ascii-toggle)))

#+end_src
*** archive-region
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , archive-region

(use-package archive-region
  :commands kill-region-or-archive-region
  :bind ("C-w" . kill-region-or-archive-region))

#+end_src
*** auctex
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , auctex

(use-package tex-site
  :load-path "/repos/jwiegley/site-lisp/auctex/preview/"
  :defines (latex-help-cmd-alist
            latex-help-file)
  ;; jww (2012-06-15): Do I want to use AucTeX for texinfo-mode?
  :mode ("\\.tex\\'" . latex-mode)
  :config
  (progn
    (defun latex-help-get-cmd-alist () ;corrected version:
      "Scoop up the commands in the index of the latex info manual.
   The values are saved in `latex-help-cmd-alist' for speed."
      ;; mm, does it contain any cached entries
      (if (not (assoc "\\begin" latex-help-cmd-alist))
          (save-window-excursion
            (setq latex-help-cmd-alist nil)
            (Info-goto-node (concat latex-help-file "Command Index"))
            (goto-char (point-max))
            (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
              (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                    (value (buffer-substring (match-beginning 2)
                                             (match-end 2))))
                (add-to-list 'latex-help-cmd-alist (cons key value))))))
      latex-help-cmd-alist)

    (use-package latex-mode
      :defer t
      :config
      (info-lookup-add-help :mode 'latex-mode
                            :regexp ".*"
                            :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                            :doc-spec '(("(latex2e)Concept Index" )
                                        ("(latex2e)Command Index"))))))

#+end_src

**** random notes
:PROPERTIES:
:tangle:   no
:END:
Some random old-school instructions

#+begin_src emacs-lisp
  (load "auctex.el" nil t t)
  (load "preview-latex.el" nil t t)
#+end_src



*** auto-complete
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , auto-complete

(use-package auto-complete-config
  :commands auto-complete-mode
  :diminish auto-complete-mode
  :config
  (progn
    (ac-set-trigger-key "TAB")
    (setq ac-use-menu-map t)

    (unbind-key "C-s" ac-completing-map)))

#+end_src
*** autopair
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , autopair

(use-package autopair
  :disabled t
  :commands autopair-mode
  :diminish autopair-mode
  :init
  (hook-into-modes #'autopair-mode '(c-mode-common-hook
                                     text-mode-hook
                                     ruby-mode-hook
                                     python-mode-hook
                                     sh-mode-hook)))

#+end_src
*** autorevert
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , autorevert

(use-package autorevert
  :commands auto-revert-mode
  :diminish auto-revert-mode
  :init
  (add-hook 'find-file-hook
            #'(lambda ()
                (auto-revert-mode 1))))

#+end_src
*** backup-each-save
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , backup-each-save

(use-package backup-each-save
  :defer t
  :init
  (progn
    (autoload 'backup-each-save "backup-each-save")
    (add-hook 'after-save-hook 'backup-each-save)

    (defun my-make-backup-file-name (file)
      (make-backup-file-name-1 (file-truename file)))

    (defun show-backups ()
      (interactive)
      (require 'find-dired)
      (let* ((file (make-backup-file-name (buffer-file-name)))
             (dir (file-name-directory file))
             (args (concat "-iname '" (file-name-nondirectory file)
                           ".~*~'"))
             (dired-buffers dired-buffers)
             (find-ls-option '("-print0 | xargs -0 ls -lta" . "-lta")))
        ;; Check that it's really a directory.
        (or (file-directory-p dir)
            (error "Backup directory does not exist: %s" dir))
        (with-current-buffer (get-buffer-create "*Backups*")
          (let ((find (get-buffer-process (current-buffer))))
            (when find
              (if (or (not (eq (process-status find) 'run))
                      (yes-or-no-p "A `find' process is running; kill it? "))
                  (condition-case nil
                      (progn
                        (interrupt-process find)
                        (sit-for 1)
                        (delete-process find))
                    (error nil))
                (error "Cannot have two processes in `%s' at once"
                       (buffer-name)))))

          (widen)
          (kill-all-local-variables)
          (setq buffer-read-only nil)
          (erase-buffer)
          (setq default-directory dir
                args (concat find-program " . "
                             (if (string= args "")
                                 ""
                               (concat
                                (shell-quote-argument "(")
                                " " args " "
                                (shell-quote-argument ")")
                                " "))
                             (if (string-match "\\`\\(.*\\) {} \\(\\\\;\\|+\\)\\'"
                                               (car find-ls-option))
                                 (format "%s %s %s"
                                         (match-string 1 (car find-ls-option))
                                         (shell-quote-argument "{}")
                                         find-exec-terminator)
                               (car find-ls-option))))
          ;; Start the find process.
          (message "Looking for backup files...")
          (shell-command (concat args "&") (current-buffer))
          ;; The next statement will bomb in classic dired (no optional arg
          ;; allowed)
          (dired-mode dir (cdr find-ls-option))
          (let ((map (make-sparse-keymap)))
            (set-keymap-parent map (current-local-map))
            (define-key map "\C-c\C-k" 'kill-find)
            (use-local-map map))
          (make-local-variable 'dired-sort-inhibit)
          (setq dired-sort-inhibit t)
          (set (make-local-variable 'revert-buffer-function)
               `(lambda (ignore-auto noconfirm)
                  (find-dired ,dir ,find-args)))
          ;; Set subdir-alist so that Tree Dired will work:
          (if (fboundp 'dired-simple-subdir-alist)
              ;; will work even with nested dired format (dired-nstd.el,v 1.15
              ;; and later)
              (dired-simple-subdir-alist)
            ;; else we have an ancient tree dired (or classic dired, where
            ;; this does no harm)
            (set (make-local-variable 'dired-subdir-alist)
                 (list (cons default-directory (point-min-marker)))))
          (set (make-local-variable 'dired-subdir-switches) find-ls-subdir-switches)
          (setq buffer-read-only nil)
          ;; Subdir headlerline must come first because the first marker in
          ;; subdir-alist points there.
          (insert "  " dir ":\n")
          ;; Make second line a ``find'' line in analogy to the ``total'' or
          ;; ``wildcard'' line.
          (insert "  " args "\n")
          (setq buffer-read-only t)
          (let ((proc (get-buffer-process (current-buffer))))
            (set-process-filter proc (function find-dired-filter))
            (set-process-sentinel proc (function find-dired-sentinel))
            ;; Initialize the process marker; it is used by the filter.
            (move-marker (process-mark proc) 1 (current-buffer)))
          (setq mode-line-process '(":%s")))))

    (bind-key "C-x ~" 'show-backups))

  :config
  (progn
    (defun backup-each-save-filter (filename)
      (not (string-match
            (concat "\\(^/tmp\\|\\.emacs\\.d/data\\(-alt\\)?/"
                    "\\|\\.newsrc\\(\\.eld\\)?\\)")
            filename)))

    (setq backup-each-save-filter-function 'backup-each-save-filter)

    (defun my-dont-backup-files-p (filename)
      (unless (string-match filename "/\\(archive/sent/\\|recentf$\\)")
        (normal-backup-enable-predicate filename)))

    (setq backup-enable-predicate 'my-dont-backup-files-p)))

#+end_src
*** bbdb
#+begin_src emacs-lisp
;;;_ , bbdb

(use-package bbdb-com
  :commands bbdb-create
  :bind ("M-B" . bbdb))

#+end_src
*** bm
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , bm

(use-package bm
  :pre-init
  (progn
    (defvar ctl-period-breadcrumb-map)
    (define-prefix-command 'ctl-period-breadcrumb-map)
    (bind-key "C-. c" 'ctl-period-breadcrumb-map))

  :bind (("C-. c b" . bm-last-in-previous-buffer)
         ("C-. c f" . bm-first-in-next-buffer)
         ("C-. c g" . bm-previous)
         ("C-. c l" . bm-show-all)
         ("C-. c c" . bm-toggle)
         ("C-. c m" . bm-toggle)
         ("C-. c n" . bm-next)
         ("C-. c p" . bm-previous)))

#+end_src
*** bookmark
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , bookmark

(use-package bookmark
  :disabled t
  :defer t
  :config
  (progn
    (use-package bookmark+)

    (defun my-bookmark-set ()
      (interactive)
      (cl-flet ((bmkp-completing-read-lax
              (prompt &optional default alist pred hist)
              (completing-read prompt alist pred nil nil hist default)))
        (call-interactively #'bookmark-set)))

    (bind-key "C-x r m" 'my-bookmark-set)))

#+end_src
*** browse-kill-ring+
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , browse-kill-ring+

(use-package browse-kill-ring+)

#+end_src
*** cmake-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , cmake-mode

(use-package cmake-mode
  :mode (("CMakeLists\\.txt\\'" . cmake-mode)
         ("\\.cmake\\'"         . cmake-mode)))

#+end_src
*** compile
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , compile

(use-package compile
  :defer t
  :config
  (add-hook 'compilation-finish-functions
            (lambda (buf why)
              (display-buffer buf))))

#+end_src
*** color-moccur
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , color-moccur

(let ((ad-redefinition-action 'accept))
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind ("M-s O" . moccur)
    :init
    (progn
      (bind-key "M-o" 'isearch-moccur isearch-mode-map)
      (bind-key "M-O" 'isearch-moccur-all isearch-mode-map))

    :config
    (use-package moccur-edit)))

#+end_src

#+results:
: t

*** crosshairs
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , crosshairs

(use-package crosshairs
  :bind ("M-o c" . crosshairs-mode))

#+end_src
*** css-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , css-mode

(use-package css-mode
  :mode ("\\.css\\'" . css-mode))

#+end_src
*** ibuffer
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ibuffer

(use-package ibuffer
  :defer t
  :init
  (add-hook 'ibuffer-mode-hook
            #'(lambda ()
                (ibuffer-switch-to-saved-filter-groups "default")))
    :bind ("C-x C-b" . ibuffer))

#+end_src

#+RESULTS:
: t

*** iflipb
#+begin_src emacs-lisp
;;;_ , iflipb

(use-package iflipb
  :disabled t
  :commands (iflipb-next-buffer iflipb-previous-buffer)
  :bind (("S-<tab>" . my-iflipb-next-buffer)
         ("A-S-<tab>" . my-iflipb-previous-buffer))
  :init
  (progn
    (defvar my-iflipb-auto-off-timeout-sec 2)
    (defvar my-iflipb-auto-off-timer-canceler-internal nil)
    (defvar my-iflipb-ing-internal nil)

    (defun my-iflipb-auto-off ()
      (message nil)
      (setq my-iflipb-auto-off-timer-canceler-internal nil
            my-iflipb-ing-internal nil))

    (defun my-iflipb-next-buffer (arg)
      (interactive "P")
      (iflipb-next-buffer arg)
      (if my-iflipb-auto-off-timer-canceler-internal
          (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
      (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
      (setq my-iflipb-ing-internal t))

    (defun my-iflipb-previous-buffer ()
      (interactive)
      (iflipb-previous-buffer)
      (if my-iflipb-auto-off-timer-canceler-internal
          (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
      (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
      (setq my-iflipb-ing-internal t)))

  :config
  (progn
    (setq iflipb-always-ignore-buffers
          "\\`\\( \\|diary\\|ipa\\|\\.newsrc-dribble\\'\\)"
          iflipb-wrap-around t)

    (defun iflipb-first-iflipb-buffer-switch-command ()
      "Determines whether this is the first invocation of
iflipb-next-buffer or iflipb-previous-buffer this round."
      (not (and (or (eq last-command 'my-iflipb-next-buffer)
                    (eq last-command 'my-iflipb-previous-buffer))
                my-iflipb-ing-internal)))))

#+end_src
*** debbugs
#+begin_src emacs-lisp
;;;_ , debbugs

(use-package debbugs-gnu
  :commands (debbugs-gnu debbugs-gnu-search))

#+end_src
*** dedicated
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , dedicated

(use-package dedicated
  :bind ("C-. d" . dedicated-mode))

#+end_src
*** diff-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , diff-mode

(use-package diff-mode
  :commands diff-mode
  :config
  (use-package diff-mode-))

#+end_src

#+results:
: t

#+begin_src emacs-lisp
(setq vc-diff-switches '("-b" "-B" "-u"))
#+end_src

#+results:
| -b | -B | -u |


*** dired
    :PROPERTIES:
    :tangle:   no
    :END:
#+begin_src emacs-lisp
  ;;;_ , dired
  
  (use-package dired
     :defer t
     :config
    (progn
      ;;(use-package ls-lisp)
      (defun dired-package-initialize ()
        (unless (featurep 'runner)
         (use-package dired-x)
         ;; (use-package dired-async)
         (use-package dired-sort-map)
         (use-package runner))
 
         ;;(setq dired-use-ls-dired t)
         ;;(setq ls-lisp-use-insert-directory-program nil)
         ;;(setq insert-directory-program "gls")

         (bind-key "l" 'dired-up-directory dired-mode-map)
  
         (defun my-dired-switch-window ()
            (interactive)
            (if (eq major-mode 'sr-mode)
                (call-interactively #'sr-change-window)
              (call-interactively #'other-window)))
  
          (bind-key "<tab>" 'my-dired-switch-window dired-mode-map)
  
          (bind-key "M-!" 'async-shell-command dired-mode-map)
          (unbind-key "M-G" dired-mode-map)
          (unbind-key "M-s f" dired-mode-map)
  
          (defadvice dired-omit-startup (after diminish-dired-omit activate)
            "Make sure to remove \"Omit\" from the modeline."
            (diminish 'dired-omit-mode) dired-mode-map)
  
          (defadvice dired-next-line (around dired-next-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (eobp)) (not ad-return-value))
              (forward-line)
              (setq ad-return-value(dired-move-to-filename)))
            (when (eobp)
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename))))
  
          (defadvice dired-previous-line (around dired-previous-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (bobp)) (not ad-return-value))
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename)))
            (when (bobp)
              (call-interactively 'dired-next-line)))
  
          (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))
  
          ;; Omit files that Git would ignore
          (defun dired-omit-regexp ()
            (let ((file (expand-file-name ".git"))
                  parent-dir)
              (while (and (not (file-exists-p file))
                          (progn
                            (setq parent-dir
                                  (file-name-directory
                                   (directory-file-name
                                    (file-name-directory file))))
                            ;; Give up if we are already at the root dir.
                            (not (string= (file-name-directory file)
                                          parent-dir))))
                ;; Move up to the parent dir and try again.
                (setq file (expand-file-name ".git" parent-dir)))
              ;; If we found a change log in a parent, use that.
              (if (file-exists-p file)
                  (let ((regexp (funcall dired-omit-regexp-orig))
                        (omitted-files
                         (shell-command-to-string "git clean -d -x -n")))
                    (if (= 0 (length omitted-files))
                        regexp
                      (concat
                       regexp
                       (if (> (length regexp) 0)
                           "\\|" "")
                       "\\("
                       (mapconcat
                        #'(lambda (str)
                            (concat
                             "^"
                             (regexp-quote
                              (substring str 13
                                         (if (= ?/ (aref str (1- (length str))))
                                             (1- (length str))
                                           nil)))
                             "$"))
                        (split-string omitted-files "\n" t)
                        "\\|")
                       "\\)")))
                (funcall dired-omit-regexp-orig))))))
  
      (eval-after-load "dired-aux"
        '(defun dired-do-async-shell-command (command &optional arg file-list)
           "Run a shell command COMMAND on the marked files asynchronously.
  
  Like `dired-do-shell-command' but if COMMAND doesn't end in ampersand,
  adds `* &' surrounded by whitespace and executes the command asynchronously.
  The output appears in the buffer `*Async Shell Command*'."
           (interactive
            (let ((files (dired-get-marked-files t current-prefix-arg)))
              (list
               ;; Want to give feedback whether this file or marked files are
               ;; used:
               (dired-read-shell-command "& on %s: " current-prefix-arg files)
               current-prefix-arg
               files)))
           (unless (string-match "[ \t][*?][ \t]" command)
             (setq command (concat command " *")))
           (unless (string-match "&[ \t]*\\'" command)
             (setq command (concat command " &")))
           (dired-do-shell-command command arg file-list)))
  
      (add-hook 'dired-mode-hook 'dired-package-initialize)
  
      (defun dired-double-jump (first-dir second-dir)
        (interactive
         (list (ido-read-directory-name "First directory: "
                                        (expand-file-name "~")
                                        nil nil "dl/")
               (ido-read-directory-name "Second directory: "
                                        (expand-file-name "~")
                                        nil nil "Archives/")))
        (dired first-dir)
        (dired-other-window second-dir))
  
      (bind-key "C-c J" 'dired-double-jump))
  
#+end_src

#+RESULTS:
: t


*** my dired
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
  ;;;_ , dired
  
  (use-package dired
     :defer t
     :config
    (progn
      (setq insert-directory-program "gls") 
      ;;(use-package ls-lisp)
      (defun dired-package-initialize ()
        (unless (featurep 'runner)
         (use-package dired-x)
         ;; (use-package dired-async)
         (use-package dired-sort-map)
         (use-package runner))
 
         ;;(setq dired-use-ls-dired t)
         ;;(setq ls-lisp-use-insert-directory-program nil)
         ;;(setq insert-directory-program "gls")

         (bind-key "l" 'dired-up-directory dired-mode-map)
  
         (defun my-dired-switch-window ()
            (interactive)
            (if (eq major-mode 'sr-mode)
                (call-interactively #'sr-change-window)
              (call-interactively #'other-window)))
  
          (bind-key "<tab>" 'my-dired-switch-window dired-mode-map)
  
          (bind-key "M-!" 'async-shell-command dired-mode-map)
          (unbind-key "M-G" dired-mode-map)
          (unbind-key "M-s f" dired-mode-map)
  
          (defadvice dired-omit-startup (after diminish-dired-omit activate)
            "Make sure to remove \"Omit\" from the modeline."
            (diminish 'dired-omit-mode) dired-mode-map)
  
          (defadvice dired-next-line (around dired-next-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (eobp)) (not ad-return-value))
              (forward-line)
              (setq ad-return-value(dired-move-to-filename)))
            (when (eobp)
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename))))
  
          (defadvice dired-previous-line (around dired-previous-line+ activate)
            "Replace current buffer if file is a directory."
            ad-do-it
            (while (and  (not  (bobp)) (not ad-return-value))
              (forward-line -1)
              (setq ad-return-value(dired-move-to-filename)))
            (when (bobp)
              (call-interactively 'dired-next-line)))
  
          (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))
  
          ;; Omit files that Git would ignore
          (defun dired-omit-regexp ()
            (let ((file (expand-file-name ".git"))
                  parent-dir)
              (while (and (not (file-exists-p file))
                          (progn
                            (setq parent-dir
                                  (file-name-directory
                                   (directory-file-name
                                    (file-name-directory file))))
                            ;; Give up if we are already at the root dir.
                            (not (string= (file-name-directory file)
                                          parent-dir))))
                ;; Move up to the parent dir and try again.
                (setq file (expand-file-name ".git" parent-dir)))
              ;; If we found a change log in a parent, use that.
              (if (file-exists-p file)
                  (let ((regexp (funcall dired-omit-regexp-orig))
                        (omitted-files
                         (shell-command-to-string "git clean -d -x -n")))
                    (if (= 0 (length omitted-files))
                        regexp
                      (concat
                       regexp
                       (if (> (length regexp) 0)
                           "\\|" "")
                       "\\("
                       (mapconcat
                        #'(lambda (str)
                            (concat
                             "^"
                             (regexp-quote
                              (substring str 13
                                         (if (= ?/ (aref str (1- (length str))))
                                             (1- (length str))
                                           nil)))
                             "$"))
                        (split-string omitted-files "\n" t)
                        "\\|")
                       "\\)")))
                (funcall dired-omit-regexp-orig))))))
  
      (eval-after-load "dired-aux"
        '(defun dired-do-async-shell-command (command &optional arg file-list)
           "Run a shell command COMMAND on the marked files asynchronously.
  
  Like `dired-do-shell-command' but if COMMAND doesn't end in ampersand,
  adds `* &' surrounded by whitespace and executes the command asynchronously.
  The output appears in the buffer `*Async Shell Command*'."
           (interactive
            (let ((files (dired-get-marked-files t current-prefix-arg)))
              (list
               ;; Want to give feedback whether this file or marked files are
               ;; used:
               (dired-read-shell-command "& on %s: " current-prefix-arg files)
               current-prefix-arg
               files)))
           (unless (string-match "[ \t][*?][ \t]" command)
             (setq command (concat command " *")))
           (unless (string-match "&[ \t]*\\'" command)
             (setq command (concat command " &")))
           (dired-do-shell-command command arg file-list)))
  
      (add-hook 'dired-mode-hook 'dired-package-initialize)
  
      (defun dired-double-jump (first-dir second-dir)
        (interactive
         (list (ido-read-directory-name "First directory: "
                                        (expand-file-name "~")
                                        nil nil "dl/")
               (ido-read-directory-name "Second directory: "
                                        (expand-file-name "~")
                                        nil nil "Archives/")))
        (dired first-dir)
        (dired-other-window second-dir))
  
      (bind-key "C-c J" 'dired-double-jump))
  
#+end_src

#+RESULTS:
: t

*** doxymacs
#+begin_src emacs-lisp
;;;_ , doxymacs

(use-package doxymacs
  :disabled t
  :load-path "site-lisp/doxymacs/lisp/")

#+end_src
*** dvc
#+begin_src emacs-lisp
;;;_ , dvc

(use-package dvc-autoloads
  :load-path "site-lisp/dvc/lisp/")

#+end_src
*** ediff
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ediff

(use-package ediff
  :pre-init
  (progn
    (defvar ctl-period-equals-map)
    (define-prefix-command 'ctl-period-equals-map)
    (bind-key "C-. =" 'ctl-period-equals-map)

    (bind-key "C-. = c" 'compare-windows)) ; not an ediff command, but it fits
  :bind (("C-. = b" . ediff-buffers)
         ("C-. = B" . ediff-buffers3)
         ("C-. = =" . ediff-files)
         ("C-. = f" . ediff-files)
         ("C-. = F" . ediff-files3)
         ("C-. = r" . ediff-revision)
         ("C-. = p" . ediff-patch-file)
         ("C-. = P" . ediff-patch-buffer)
         ("C-. = l" . ediff-regions-linewise)
         ("C-. = w" . ediff-regions-wordwise))
  :config
  (use-package ediff-keep))

#+end_src

#+results:
: t

*** edit-server
#+begin_src emacs-lisp
;;;_ , edit-server

(use-package edit-server
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive))
  :init
  (progn
    (add-hook 'after-init-hook 'server-start t)
    (add-hook 'after-init-hook 'edit-server-start t)))

#+end_src
*** emms
#+begin_src emacs-lisp
;;;_ , emms

(use-package emms-setup
  :load-path "site-lisp/emms/lisp"
  :defines emms-info-functions
  :commands (emms-all emms-devel)
  :init
  (progn
    (defvar emms-initialized nil)

    (defun my-emms ()
      (interactive)
      (unless emms-initialized
        (emms-devel)
        (emms-default-players)
        (require 'emms-info-libtag)
        (setq emms-info-functions '(emms-info-libtag))
        (setq emms-initialized t))
      (call-interactively #'emms-smart-browse))

    (bind-key "C-. M" 'my-emms))

  :config
  (progn
    (bind-key "S-<f7>" 'emms-previous)
    (bind-key "S-<f8>" 'emms-pause)
    (bind-key "S-<f9>" 'emms-next)
    (bind-key "S-<f10>" 'emms-stop)

    (defun emms-player-mplayer-volume-up ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume 1\n"))

    (defun emms-player-mplayer-volume-down ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume -1\n"))

    (bind-key "C-. C--" 'emms-player-mplayer-volume-down)
    (bind-key "C-. C-=" 'emms-player-mplayer-volume-up)))

#+end_src

#+results:
: t

*** erc
#+begin_src emacs-lisp
;;;_ , erc

(use-package erc
  ;; :commands erc
  :if running-alternate-emacs
  :init
  (progn
    (defun irc ()
      (interactive)
      (erc-tls :server "irc.freenode.net"
               :port 6697
               :nick "johnw"
               :password (funcall
                          (plist-get
                           (car (auth-source-search :host "irc.freenode.net"
                                                    :user "johnw"
                                                    :type 'netrc
                                                    :port 6667))
                           :secret)))
      (erc-tls :server "irc.oftc.net"
               :port 6697
               :nick "johnw"))

    (defun im ()
      (interactive)
      (erc :server "localhost"
           :port 6667
           :nick "johnw"
           :password (funcall
                      (plist-get
                       (car (auth-source-search :host "bitlbee"
                                                :user "johnw"
                                                :type 'netrc
                                                :port 6667))
                       :secret)))))

  :config
  (progn
    (erc-track-minor-mode 1)
    (erc-track-mode 1)

    (use-package erc-alert)
    (use-package erc-highlight-nicknames)
    (use-package erc-patch)

    (use-package erc-yank
      :init
      (bind-key "C-y" 'erc-yank erc-mode-map))

    (use-package wtf
      :commands wtf-is
      :init
      (defun erc-cmd-WTF (term &rest ignore)
        "Look up definition for TERM."
        (let ((def (wtf-is term)))
          (if def
              (let ((msg (concat "{Term} " (upcase term) " is " def)))
                (with-temp-buffer
                  (insert msg)
                  (kill-ring-save (point-min) (point-max)))
                (message msg))
            (message (concat "No definition found for " (upcase term)))))))

    (defun switch-to-bitlbee ()
      (interactive)
      (switch-to-buffer-other-window "&bitlbee")
      (call-interactively 'erc-channel-names)
      (goto-char (point-max)))

    (bind-key "C-c b" 'switch-to-bitlbee)

    (defun erc-cmd-SHOW (&rest form)
      "Eval FORM and send the result and the original form as:
FORM => (eval FORM)."
      (let* ((form-string (mapconcat 'identity form " "))
             (result
              (condition-case err
                  (eval (read-from-whole-string form-string))
                (error
                 (format "Error: %s" err)))))
        (erc-send-message (format "%s => %S" form-string result))))

    (defun erc-cmd-INFO (&rest ignore)
      "Send current info node."
      (unless (get-buffer "*info*")
        (error "No *info* buffer"))
      (let (output)
        (with-current-buffer "*info*"
          (let* ((file (file-name-nondirectory Info-current-file))
                 (node Info-current-node))
            (setq output (format "(info \"(%s)%s\") <-- hit C-x C-e to evaluate"
                                 file node))))
        (erc-send-message output)))

    (eval-when-compile
      (defvar erc-fools))

    (defun erc-cmd-FOOL (term &rest ignore)
      (add-to-list 'erc-fools term))

    (defun erc-cmd-UNFOOL (term &rest ignore)
      (setq erc-fools (delete term erc-fools)))

    (defun erc-cmd-OPME ()
      "Request chanserv to op me."
      (erc-message "PRIVMSG"
                   (format "chanserv op %s %s"
                           (erc-default-target)
                           (erc-current-nick)) nil))

    (defun erc-cmd-DEOPME ()
      "Deop myself from current channel."
      (erc-cmd-DEOP (format "%s" (erc-current-nick))))))

#+end_src

*** my erc
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , erc

(use-package erc
  ;; :commands erc
  :init
  (progn
    (defun irc ()
      (interactive)
      (erc-tls :server "irc.freenode.net"
               :port 6697
               :nick "zygomega"
               :password (funcall
                          (plist-get
                           (car (auth-source-search :host "irc.freenode.net"
                                                    :user "zygomega"
                                                    :type 'netrc
                                                    :port 6667))
                           :secret)))
      (erc-tls :server "irc.oftc.net"
               :port 6697
               :nick "zygomega"))

    (defun erc-connect ()
      "alexott connect to IRC."
      (interactive)
      (progn
        (erc-select :server "irc.freenode.net" :port 6667 :nick "zygomega")))


    (defun im ()
      (interactive)
      (erc :server "localhost"
           :port 6667
           :nick "tonyday")))

  :config
  (progn
    (erc-track-minor-mode 1)
    (erc-track-mode 1)

    (use-package erc-alert)
    (use-package erc-highlight-nicknames)
    (use-package erc-patch)
    
    (use-package erc-yank
      :init
      (bind-key "C-y" 'erc-yank erc-mode-map))

    (use-package wtf
      :commands wtf-is
      :init
      (defun erc-cmd-WTF (term &rest ignore)
        "Look up definition for TERM."
        (let ((def (wtf-is term)))
          (if def
              (let ((msg (concat "{Term} " (upcase term) " is " def)))
                (with-temp-buffer
                  (insert msg)
                  (kill-ring-save (point-min) (point-max)))
                (message msg))
            (message (concat "No definition found for " (upcase term)))))))

    (defun switch-to-bitlbee ()
      (interactive)
      (switch-to-buffer-other-window "&bitlbee")
      (call-interactively 'erc-channel-names)
      (goto-char (point-max)))

    (bind-key "C-c b" 'switch-to-bitlbee)

    (defun erc-cmd-SHOW (&rest form)
      "Eval FORM and send the result and the original form as:
FORM => (eval FORM)."
      (let* ((form-string (mapconcat 'identity form " "))
             (result
              (condition-case err
                  (eval (read-from-whole-string form-string))
                (error
                 (format "Error: %s" err)))))
        (erc-send-message (format "%s => %S" form-string result))))

    (defun erc-cmd-INFO (&rest ignore)
      "Send current info node."
      (unless (get-buffer "*info*")
        (error "No *info* buffer"))
      (let (output)
        (with-current-buffer "*info*"
          (let* ((file (file-name-nondirectory Info-current-file))
                 (node Info-current-node))
            (setq output (format "(info \"(%s)%s\") <-- hit C-x C-e to evaluate"
                                 file node))))
        (erc-send-message output)))

    (eval-when-compile
      (defvar erc-fools))

    (defun erc-cmd-FOOL (term &rest ignore)
      (add-to-list 'erc-fools term))

    (defun erc-cmd-UNFOOL (term &rest ignore)
      (setq erc-fools (delete term erc-fools)))

    (defun erc-cmd-OPME ()
      "Request chanserv to op me."
      (erc-message "PRIVMSG"
                   (format "chanserv op %s %s"
                           (erc-default-target)
                           (erc-current-nick)) nil))

    (defun erc-cmd-DEOPME ()
      "Deop myself from current channel."
      (erc-cmd-DEOP (format "%s" (erc-current-nick))))))

#+end_src

*** test erc
:PROPERTIES:
:tangle:   no
:END:

http://www.irchelp.org/irchelp/chanlist//

http://static.quadpoint.org/bitlbee-user-guide.html#quickstart4



#+begin_src emacs-lisp
  (use-package bitlbee)
  (bitlbee-start)

    (defun im ()
      (interactive)
      (erc :server "localhost"
           :port 6667
           :nick "tonyday"))

    (defun switch-to-bitlbee ()
      (interactive)
      (switch-to-buffer-other-window "&bitlbee")
      ;;im(call-interactively 'erc-channel-names)
      (goto-char (point-max)))

    (bind-key "C-. C-. b" 'switch-to-bitlbee)

#+end_src

#+results:
: switch-to-bitlbee

*** dwa erc
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
  (org-babel-load-file (expand-file-name "~/.emacs.d/site-lisp/erc-settings.org"))
#+end_src
*** erlang
#+begin_src emacs-lisp
  (use-package erlang-start)
(setq erlang-root-dir "/usr/local/Cellar/erlang/R15B02/share")
#+end_src

#+results:
: /usr/local/Cellar/erlang/R15B02/share

*** eshell
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , eshell

(use-package eshell
  :defer t
  :init
  (progn
    (defun eshell-initialize ()
      (defun eshell-spawn-external-command (beg end)
        "Parse and expand any history references in current input."
        (save-excursion
          (goto-char end)
          (when (looking-back "&!" beg)
            (delete-region (match-beginning 0) (match-end 0))
            (goto-char beg)
            (insert "spawn "))))

      (add-hook 'eshell-expand-input-functions 'eshell-spawn-external-command)

      (defun ss (server)
        (interactive "sServer: ")
        (call-process "spawn" nil nil nil "ss" server))

      (eval-after-load "em-unix"
        '(progn
           (unintern 'eshell/su)
           (unintern 'eshell/sudo))))

    (add-hook 'eshell-first-time-mode-hook 'eshell-initialize)))

(use-package esh-toggle
  :requires eshell
  :bind ("C-x C-z" . eshell-toggle))

#+end_src
*** ess
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package ess-site
  :bind ("C-. C-. r" . R))
;;(use-package ess-tracebug)
#+end_src

#+results:
: t


#+end_src

#+results:


*** eval-expr
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , eval-expr

(use-package eval-expr
  :bind ("M-:" . eval-expr)
  :config
  (progn
    (setq eval-expr-print-function 'pp
          eval-expr-print-level 20
          eval-expr-print-length 100)

    (defun eval-expr-minibuffer-setup ()
      (set-syntax-table emacs-lisp-mode-syntax-table)
      (paredit-mode))))

#+end_src
*** fetchmail-mode
#+begin_src emacs-lisp
;;;_ , fetchmail-mode

(use-package fetchmail-mode
  :commands fetchmail-mode)

#+end_src
*** ffap
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package ffap
  :bind ("C-c v" . ffap))
#+end_src


*** ffip
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
(use-package find-file-in-project
  :bind ("C-x f" . find-file-in-project))
#+end_src

*** flyspell
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , flyspell

(use-package ispell
  :bind (("C-c i c" . ispell-comments-and-strings)
         ("C-c i d" . ispell-change-dictionary)
         ("C-c i k" . ispell-kill-ispell)
         ("C-c i m" . ispell-message)
         ("C-c i r" . ispell-region)))

(use-package flyspell
  :bind (("C-c i b" . flyspell-buffer)
         ("C-c i f" . flyspell-mode))
  :config
  (define-key flyspell-mode-map [(control ?.)] nil))

#+end_src
*** fold-dwim
#+begin_src emacs-lisp
;;;_ , fold-dwim

(use-package fold-dwim
  :bind (("<f13>" . fold-dwim-toggle)
         ("<f14>" . fold-dwim-hide-all)
         ("<f15>" . fold-dwim-show-all)))

#+end_src
*** gist
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , gist

(use-package gist
  :bind ("C-c G" . gist-region-or-buffer))

#+end_src
*** my gnus
    :PROPERTIES:
    :tangle: 
    :END:
#+begin_src emacs-lisp
;;;_ , gnus

(use-package dotgnus
  :bind (("M-G"   . gnus)
         ("C-x m" . compose-mail))
  :init
  (progn
    ;;(org-babel-load-file (expand-file-name "dotgnus.org" user-emacs-directory))
    (setq gnus-init-file (expand-file-name "dotgnus" user-emacs-directory)
          gnus-home-directory "~/Messages/Gnus/")))

#+end_src

#+results:
: t






*** gnus
    :PROPERTIES:
    :tangle: 
    :END:
#+begin_src emacs-lisp
;;;_ , gnus

(use-package dot-gnus
  :bind (("M-G"   . switch-to-gnus)
         ("C-x m" . compose-mail))
  :init
  (progn
    (setq gnus-init-file (expand-file-name "dot-gnus" user-emacs-directory)
          gnus-home-directory "~/Messages/Gnus/")))

#+end_src
*** grep
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , grep

(use-package grep
  :bind (("M-s d" . find-grep-dired)
         ("M-s f" . find-grep)
         ("M-s g" . grep)
         ("M-s r" . rgrep))
  :init
  (progn
    (defun find-grep-in-project (command-args)
      (interactive
       (let ((default (thing-at-point 'symbol)))
         (list (read-shell-command "Run find (like this): "
                                   (cons (concat "git --no-pager grep -n "
                                                 default)
                                         (+ 24 (length default)))
                                   'grep-find-history))))
      (if command-args
          (let ((null-device nil))      ; see grep
            (grep command-args))))

    (bind-key "M-s p" 'find-grep-in-project))

  :config
  (progn
    (use-package grep-ed)

    (grep-apply-setting 'grep-command "egrep -nH -e ")
    (grep-apply-setting
     'grep-find-command
     '("find . -type f -print0 | xargs -P4 -0 egrep -nH -e " . 52))))

#+end_src

#+results:
: t

*** gtags
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , gtags

(use-package gtags
  :commands gtags-mode
  :diminish gtags-mode
  :config
  (progn
    (defun my-gtags-or-semantic-find-tag ()
      (interactive)
      (if (and (fboundp 'semantic-active-p)
               (funcall #'semantic-active-p))
          (call-interactively #'semantic-complete-jump)
        (call-interactively #'gtags-find-tag)))

    (bind-key "M-." 'my-gtags-or-semantic-find-tag gtags-mode-map)

    (bind-key "C-c t ." 'gtags-find-rtag)
    (bind-key "C-c t f" 'gtags-find-file)
    (bind-key "C-c t p" 'gtags-parse-file)
    (bind-key "C-c t g" 'gtags-find-with-grep)
    (bind-key "C-c t i" 'gtags-find-with-idutils)
    (bind-key "C-c t s" 'gtags-find-symbol)
    (bind-key "C-c t r" 'gtags-find-rtag)
    (bind-key "C-c t v" 'gtags-visit-rootdir)

    (bind-key "<mouse-2>" 'gtags-find-tag-from-here gtags-mode-map)

    (use-package helm-gtags
      :bind ("M-T" . helm-gtags-select)
      :config
      (bind-key "M-," 'helm-gtags-resume gtags-mode-map))))

#+end_src
*** gud
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , gud

(use-package gud
  :commands gud-gdb
  :init
  (progn
    (defun show-debugger ()
      (interactive)
      (let ((gud-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*gud-" (buffer-name buf))
                     (throw 'found buf))))))
        (if gud-buf
            (switch-to-buffer-other-window gud-buf)
          (call-interactively 'gud-gdb))))

    (bind-key "C-. g" 'show-debugger))

  :config
  (progn
    (bind-key "<f9>" 'gud-cont)
    (bind-key "<f10>" 'gud-next)
    (bind-key "<f11>" 'gud-step)
    (bind-key "S-<f11>" 'gud-finish)))

#+end_src
*** haskell-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , haskell-mode

(require 'haskell-config)

#+end_src
*** helm
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , helm

(use-package helm-config
  :if (not running-alternate-emacs)
  :init
  (progn
    (bind-key "C-c M-x" 'helm-M-x)
    (bind-key "C-h a" 'helm-c-apropos)
    (bind-key "M-s a" 'helm-do-grep)
    (bind-key "M-s b" 'helm-occur)
    (bind-key "M-s F" 'helm-for-files)

    (use-package helm-commands)

    (bind-key "C-h e a" 'my-helm-apropos)
    (bind-key "C-x M-!" 'helm-command-from-zsh)
    (bind-key "C-x f" 'helm-find-git-file)

    (use-package helm-descbinds
      :commands helm-descbinds
      :init
      (fset 'describe-bindings 'helm-descbinds))

    (bind-key "C-h b" 'helm-descbinds))

  :config
  (helm-match-plugin-mode t))

#+end_src
*** hi-lock
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , hi-lock

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))

#+end_src
*** hilit-chg
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , hilit-chg

(use-package hilit-chg
  :bind ("M-o C" . highlight-changes-mode))

#+end_src
*** hl-line
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , hl-line

(use-package hl-line
  :bind ("M-o h" . hl-line-mode)
  :config
  (use-package hl-line+))

#+end_src
*** my ido
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ido

(use-package ido
  :defines (ido-cur-item
            ido-require-match
            ido-selected
            ido-final-text
            ido-show-confirm-message)
  :init
  (ido-mode t)

  :config
  (progn
    (use-package ido-hacks
      :init
      (ido-hacks-mode 1))

    (use-package ido-springboard)

    (defun ido-smart-select-text ()
      "Select the current completed item.  Do NOT descend into directories."
      (interactive)
      (when (and (or (not ido-require-match)
                     (if (memq ido-require-match
                               '(confirm confirm-after-completion))
                         (if (or (eq ido-cur-item 'dir)
                                 (eq last-command this-command))
                             t
                           (setq ido-show-confirm-message t)
                           nil))
                     (ido-existing-item-p))
                 (not ido-incomplete-regexp))
        (when ido-current-directory
          (setq ido-exit 'takeprompt)
          (unless (and ido-text (= 0 (length ido-text)))
            (let ((match (ido-name (car ido-matches))))
              (throw 'ido
                     (setq ido-selected
                           (if match
                               (replace-regexp-in-string "/\\'" "" match)
                             ido-text)
                           ido-text ido-selected
                           ido-final-text ido-text)))))
        (exit-minibuffer)))

    (add-hook 'ido-minibuffer-setup-hook
              #'(lambda ()
                  (bind-key "<return>" 'ido-smart-select-text
                            ido-file-completion-map)))

    (defun ido-switch-buffer-tiny-frame (buffer)
      (interactive (list (ido-read-buffer "Buffer: " nil t)))
      (with-selected-frame
          (make-frame '((width                . 80)
                        (height               . 22)
                        (left-fringe          . 0)
                        (right-fringe         . 0)
                        (vertical-scroll-bars . nil)
                        (unsplittable         . t)
                        (has-modeline-p       . nil)
                        ;;(background-color     . "grey80")
                        (minibuffer           . nil)))
        (switch-to-buffer buffer)
        (set (make-local-variable 'mode-line-format) nil)))

    (bind-key "C-x 5 t" 'ido-switch-buffer-tiny-frame)))

#+end_src


*** ido

    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ido

(use-package ido
  :defines (ido-cur-item
            ido-require-match
            ido-selected
            ido-final-text
            ido-show-confirm-message)
  :init
  (ido-mode t)

  :config
  (progn
    (use-package ido-hacks
      :init
      (ido-hacks-mode 1))

    (use-package ido-springboard)

    (defun ido-smart-select-text ()
      "Select the current completed item.  Do NOT descend into directories."
      (interactive)
      (when (and (or (not ido-require-match)
                     (if (memq ido-require-match
                               '(confirm confirm-after-completion))
                         (if (or (eq ido-cur-item 'dir)
                                 (eq last-command this-command))
                             t
                           (setq ido-show-confirm-message t)
                           nil))
                     (ido-existing-item-p))
                 (not ido-incomplete-regexp))
        (when ido-current-directory
          (setq ido-exit 'takeprompt)
          (unless (and ido-text (= 0 (length ido-text)))
            (let ((match (ido-name (car ido-matches))))
              (throw 'ido
                     (setq ido-selected
                           (if match
                               (replace-regexp-in-string "/\\'" "" match)
                             ido-text)
                           ido-text ido-selected
                           ido-final-text ido-text)))))
        (exit-minibuffer)))

    (add-hook 'ido-minibuffer-setup-hook
              #'(lambda ()
                  (bind-key "<return>" 'ido-smart-select-text
                            ido-file-completion-map)))

    (defun ido-switch-buffer-tiny-frame (buffer)
      (interactive (list (ido-read-buffer "Buffer: " nil t)))
      (with-selected-frame
          (make-frame '((width                . 80)
                        (height               . 22)
                        (left-fringe          . 0)
                        (right-fringe         . 0)
                        (vertical-scroll-bars . nil)
                        (unsplittable         . t)
                        (has-modeline-p       . nil)
                        ;;(background-color     . "grey80")
                        (minibuffer           . nil)))
        (switch-to-buffer buffer)
        (set (make-local-variable 'mode-line-format) nil)))

    (bind-key "C-x 5 t" 'ido-switch-buffer-tiny-frame)))

#+end_src
*** ielm
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , ielm

(use-package ielm
  :bind ("C-c :" . ielm)
  :config
  (progn
    (defun my-ielm-return ()
      (interactive)
      (let ((end-of-sexp (save-excursion
                           (goto-char (point-max))
                           (skip-chars-backward " \t\n\r")
                           (point))))
        (if (>= (point) end-of-sexp)
            (progn
              (goto-char (point-max))
              (skip-chars-backward " \t\n\r")
              (delete-region (point) (point-max))
              (call-interactively #'ielm-return))
          (call-interactively #'paredit-newline))))

    (add-hook 'ielm-mode-hook
              (function
               (lambda ()
                 (bind-key "<return>" 'my-ielm-return ielm-map)))
              t)))

#+end_src
*** image-file
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , image-file

(use-package image-file
  :disabled t
  :init
  (auto-image-file-mode 1))

#+end_src
*** info
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , info

(use-package info
  :bind ("C-h C-i" . info-lookup-symbol)
  :init
  (remove-hook 'menu-bar-update-hook 'mac-setup-help-topics)

  :config
  (progn
    (defadvice info-setup (after load-info+ activate)
      (use-package info+))

    (defadvice Info-exit (after remove-info-window activate)
      "When info mode is quit, remove the window."
      (if (> (length (window-list)) 1)
          (delete-window)))))

(use-package info-look
  :commands info-lookup-add-help)
#+end_src

**** getting info directories right
#+TBLNAME: info-dirs
| /Users/tonyday/.emacs.d/info                   |
| /usr/share/info/                               |

  #+begin_src emacs-lisp :var table=info-dirs
     (setq clean-table
           (delete nil  
                   (loop for line in table
                         collect 
                         (delete "" (delete-dups line)))))
    (setq Info-default-directory-list (apply #'append clean-table))
    (setq Info-directory-list Info-default-directory-list)
  #+end_src

**** checks
#+begin_src emacs-lisp :tangle no
  (getenv "INFOPATH")
#+end_src

#+begin_src emacs-lisp :tangle no
  (print (loop for f in Info-default-directory-list
               collect
               (list f)))
#+end_src

#+begin_src emacs-lisp :tangle no
  (print (loop for f in Info-directory-list
               collect
               (car f)))
#+end_src

*** indirect
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , indirect

(use-package indirect
  :bind ("C-c C" . indirect-region))

#+end_src
*** initsplit
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , initsplit

(eval-after-load "cus-edit"
  '(use-package initsplit))

#+end_src
*** ipa
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , ipa

(use-package ipa
  :commands ipa-insert
  :init
  (progn
    (autoload 'ipa-load-annotations-into-buffer "ipa")
    (add-hook 'find-file-hook 'ipa-load-annotations-into-buffer)))

#+end_src
*** js2-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , js2-mode

(use-package js2-mode
  :mode ("\\.js\\'" . js2-mode))

#+end_src
*** ledger
#+begin_src emacs-lisp
;;;_ , ledger

(use-package "ldg-new"
  :commands ledger-mode
  :init
  (progn
    (defun my-ledger-start-entry (&optional arg)
      (interactive "p")
      (find-file-other-window "~/Documents/Accounts/ledger.dat")
      (goto-char (point-max))
      (skip-syntax-backward " ")
      (if (looking-at "\n\n")
          (goto-char (point-max))
        (delete-region (point) (point-max))
        (insert ?\n)
        (insert ?\n))
      (insert (format-time-string "%Y/%m/%d ")))

    (bind-key "C-c L" 'my-ledger-start-entry)

    (defun ledger-matchup ()
      (interactive)
      (while (re-search-forward "\\(\\S-+Unknown\\)\\s-+\\$\\([-,0-9.]+\\)"
                                nil t)
        (let ((account-beg (match-beginning 1))
              (account-end (match-end 1))
              (amount (match-string 2))
              account answer)
          (goto-char account-beg)
          (set-window-point (get-buffer-window) (point))
          (recenter)
          (redraw-display)
          (with-current-buffer (get-buffer "nrl-mastercard-old.dat")
            (goto-char (point-min))
            (when (re-search-forward (concat "\\(\\S-+\\)\\s-+\\$" amount)
                                     nil t)
              (setq account (match-string 1))
              (goto-char (match-beginning 1))
              (set-window-point (get-buffer-window) (point))
              (recenter)
              (redraw-display)
              (setq answer
                    (read-char (format "Is this a match for %s (y/n)? "
                                       account)))))
          (when (eq answer ?y)
            (goto-char account-beg)
            (delete-region account-beg account-end)
            (insert account))
          (forward-line))))))

#+end_src
*** lisp-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , lisp-mode

;; Utilities every Emacs Lisp coders should master:
;;
;;   paredit          Let's you manipulate sexps with ease
;;   redshank         Think: Lisp refactoring
;;   edebug           Knowing the traditional debugger is good too
;;   eldoc
;;   cldoc
;;   elint
;;   elp
;;   ert

(use-package lisp-mode
  ;; :load-path "site-lisp/slime/contrib/"
  :init
  (progn
    (defface esk-paren-face
      '((((class color) (background dark))
         (:foreground "grey50"))
        (((class color) (background light))
         (:foreground "grey55")))
      "Face used to dim parentheses."
      :group 'starter-kit-faces)

    ;; Change lambda to an actual lambda symbol
    (mapc (lambda (major-mode)
            (font-lock-add-keywords
             major-mode
             '(("(\\(lambda\\)\\>"
                (0 (ignore
                    (compose-region (match-beginning 1)
                                    (match-end 1) ?λ))))
               ("(\\|)" . 'esk-paren-face)
               ("(\\(ert-deftest\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+\\|\\sw+\\)?"
                (1 font-lock-keyword-face)
                (2 font-lock-function-name-face
                 nil t)))))
          lisp-modes)

    (defvar slime-mode nil)
    (defvar lisp-mode-initialized nil)

    (defun initialize-lisp-mode ()
      (unless lisp-mode-initialized
        (setq lisp-mode-initialized t)

        (use-package redshank
          :diminish redshank-mode)

        (use-package elisp-slime-nav
          :diminish elisp-slime-nav-mode)

        (use-package edebug)

        (use-package eldoc
          :diminish eldoc-mode
          :defer t
          :init
          (use-package eldoc-extension
            :disabled t
            :defer t
            :init
            (add-hook 'emacs-lisp-mode-hook
                      #'(lambda () (require 'eldoc-extension)) t))

          :config
          (eldoc-add-command 'paredit-backward-delete
                             'paredit-close-round))

        (use-package cldoc
          :diminish cldoc-mode)

        (use-package ert
          :commands ert-run-tests-interactively
          :bind ("C-c e t" . ert-run-tests-interactively))

        (use-package elint
          :commands 'elint-initialize
          :init
          (defun elint-current-buffer ()
            (interactive)
            (elint-initialize)
            (elint-current-buffer))

          :config
          (progn
            (add-to-list 'elint-standard-variables 'current-prefix-arg)
            (add-to-list 'elint-standard-variables 'command-line-args-left)
            (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
            (add-to-list 'elint-standard-variables 'emacs-major-version)
            (add-to-list 'elint-standard-variables 'window-system)))

        (use-package highlight-cl
          :init
          (mapc (function
                 (lambda (mode-hook)
                   (add-hook mode-hook
                             'highlight-cl-add-font-lock-keywords)))
                lisp-mode-hooks))

        (defun my-elisp-indent-or-complete (&optional arg)
          (interactive "p")
          (call-interactively 'lisp-indent-line)
          (unless (or (looking-back "^\\s-*")
                      (bolp)
                      (not (looking-back "[-A-Za-z0-9_*+/=<>!?]+")))
            (call-interactively 'lisp-complete-symbol)))

        (defun my-lisp-indent-or-complete (&optional arg)
          (interactive "p")
          (if (or (looking-back "^\\s-*") (bolp))
              (call-interactively 'lisp-indent-line)
            (call-interactively 'slime-indent-and-complete-symbol)))

        (defun my-byte-recompile-file ()
          (save-excursion
            (byte-recompile-file buffer-file-name)))

        ;; Register Info manuals related to Lisp
        (use-package info-lookmore
          :init
          (progn
            (info-lookmore-elisp-cl)
            (info-lookmore-elisp-userlast)
            (info-lookmore-elisp-gnus)
            (info-lookmore-apropos-elisp)))

        (mapc (lambda (mode)
                (info-lookup-add-help
                 :mode mode
                 :regexp "[^][()'\" \t\n]+"
                 :ignore-case t
                 :doc-spec '(("(ansicl)Symbol Index" nil nil nil))))
              lisp-modes)))

    (defun my-lisp-mode-hook ()
      (initialize-lisp-mode)

      (auto-fill-mode 1)
      (paredit-mode 1)
      (redshank-mode 1)
      (elisp-slime-nav-mode 1)

      (local-set-key (kbd "<return>") 'paredit-newline)

      (if (memq major-mode
                '(emacs-lisp-mode inferior-emacs-lisp-mode ielm-mode))
          (progn
            (bind-key "<M-return>" 'outline-insert-heading emacs-lisp-mode-map)
            (bind-key "<tab>" 'my-elisp-indent-or-complete emacs-lisp-mode-map))
        (turn-on-cldoc-mode)

        (bind-key "<tab>" 'my-lisp-indent-or-complete lisp-mode-map)
        (bind-key "M-q" 'slime-reindent-defun lisp-mode-map)
        (bind-key "M-l" 'slime-selector lisp-mode-map))

      (yas/minor-mode 1))

    (hook-into-modes #'my-lisp-mode-hook lisp-mode-hooks)))

#+end_src
*** llvm-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , llvm-mode

(use-package llvm-mode
  :mode ("\\.ll\\'" . llvm-mode))

#+end_src
*** log4j-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , log4j-mode

(use-package log4j-mode
  :disabled t
  :mode ("\\.log\\'" . log4j-mode))

#+end_src
*** lua-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , lua-mode

(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode)
  :interpreter ("lua" . lua-mode))

#+end_src
*** lusty-explorer
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , lusty-explorer

(use-package lusty-explorer
  :bind ("C-x C-f" . lusty-file-explorer)
  :config
  (progn
    (add-hook 'lusty-setup-hook
              (lambda ()
                (bind-key "SPC" 'lusty-select-match lusty-mode-map)
                (bind-key "C-d" 'exit-minibuffer lusty-mode-map)))

    (defun lusty-open-this ()
      "Open the given file/directory/buffer, creating it if not already present."
      (interactive)
      (when lusty--active-mode
        (ecase lusty--active-mode
          (:file-explorer
           (let* ((path (minibuffer-contents-no-properties))
                  (last-char (aref path (1- (length path)))))
             (lusty-select-match)
             (lusty-select-current-name)))
          (:buffer-explorer (lusty-select-match)))))

    (defvar lusty-only-directories nil)

    (defun lusty-file-explorer-matches (path)
      (let* ((dir (lusty-normalize-dir (file-name-directory path)))
             (file-portion (file-name-nondirectory path))
             (files
              (and dir
                   ;; NOTE: directory-files is quicker but
                   ;;       doesn't append slash for directories.
                   ;;(directory-files dir nil nil t)
                   (file-name-all-completions "" dir)))
             (filtered (lusty-filter-files
                        file-portion
                        (if lusty-only-directories
                            (loop for f in files
                                  when (= ?/ (aref f (1- (length f))))
                                  collect f)
                          files))))
        (if (or (string= file-portion "")
                (string= file-portion "."))
            (sort filtered 'string<)
          (lusty-sort-by-fuzzy-score filtered file-portion))))

    (defun lusty-read-directory ()
      "Launch the file/directory mode of LustyExplorer."
      (interactive)
      (let ((lusty--active-mode :file-explorer))
        (lusty--define-mode-map)
        (let* ((lusty--ignored-extensions-regex
                (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
               (minibuffer-local-filename-completion-map lusty-mode-map)
               (lusty-only-directories t))
          (lusty--run 'read-directory-name default-directory ""))))

    (defun lusty-read-file-name ()
      "Launch the file/directory mode of LustyExplorer."
      (interactive)
      (let ((lusty--active-mode :file-explorer))
        (lusty--define-mode-map)
        (let* ((lusty--ignored-extensions-regex
                (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
               (minibuffer-local-filename-completion-map lusty-mode-map)
               (lusty-only-directories nil))
          (lusty--run 'read-file-name default-directory ""))))

    (if (featurep 'icicles)
        (defadvice lusty-file-explorer (around lusty-file-explorer-without-icy
                                               activate)
          (cl-flet ((message (&rest ignore)))
            (let ((icy-was-on icicle-mode))
              (if icy-was-on (icy-mode 0))
              (unwind-protect
                  ad-do-it
                (if icy-was-on (icy-mode 1)))))))))

#+end_src
*** macrostep
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , macrostep

(use-package macrostep
  :bind ("C-c e m" . macrostep-expand))

#+end_src
*** magit
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , magit

(use-package magit
  :bind ("C-x g" . magit-status)
  :config
  (progn
    (setenv "GIT_PAGER" "")

    (add-hook 'magit-log-edit-mode-hook
              #'(lambda ()
                  (set-fill-column 72)
                  (flyspell-mode)))

    (require 'magit-topgit)
    (require 'rebase-mode)

    (defun start-git-monitor ()
      (interactive)
      (start-process "git-monitor" (current-buffer) "~/bin/git-monitor"))

    ;;(add-hook 'magit-status-mode-hook 'start-git-monitor)
    ))

#+end_src

#+name: git-repos
| ~/git/scarce |
| ~/stuff      |
| ~/.emacs.d   |
| ~/git/o-blog |
| ~/git/quaff |


#+begin_src emacs-lisp :var table=git-repos  
     (setq magit-repo-dirs
           (loop for file in table
                     collect (car file)))
#+end_src

#+results:
| ~/git/scarce | ~/stuff | ~/.emacs.d | ~/git/o-blog | ~/git/quaff |

*** markdown-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , markdown-mode

(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :init
  (progn
    (defun markdown-preview-file ()
      "run Marked on the current file and revert the buffer"
      (interactive)
      (shell-command
       (format "open -a /Applications/Marked.app %s"
               (shell-quote-argument (buffer-file-name)))))

    (bind-key "C-x M" 'markdown-preview-file)))

#+end_src

http://lucindo.com.br/lisp/milki/markdown.html

#+results:
: t

*** merlin
#+begin_src emacs-lisp
;;;_ , merlin

(defun merlin-record-times ()
  (interactive)
  (require 'rx)
  (let* ((text (buffer-substring-no-properties (line-beginning-position)
                                               (line-end-position)))
         (regex
          (rx (and string-start (0+ space)
                   (group (and (= 2 num) ?/ (= 2 num) ?/ (= 2 num)
                               space (= 2 num) ?: (= 2 num) space
                               (in "AP") ?M)) (1+ space)
                   (group (and (= 2 num) ?/ (= 2 num) ?/ (= 2 num)
                               space (= 2 num) ?: (= 2 num) space
                               (in "AP") ?M)) (1+ space)
                   (? (and (group ?*) (1+ space)))
                   (group (1+ (or digit (in ".hms"))))
                   (1+ space) (group (1+ nonl)) string-end))))
    (if (string-match regex text)
        (let ((start (match-string 1 text))
              (end (match-string 2 text))
              (cleared (match-string 3 text))
              (duration (match-string 4 text)) commodity
              (account (match-string 5 text)))
          (when (string-match "\\([0-9.]+\\)\\([mhs]\\)" duration)
            (setq commodity (match-string 2 duration)
                  duration (match-string 1 duration))
            (cond ((string= commodity "h")
                   (setq commodity "hours"))
                  ((string= commodity "m")
                   (setq commodity "minutes"))
                  ((string= commodity "s")
                   (setq commodity "seconds"))))
          (if (string-match "\\([0-9.][0-9.a-z]+\\)" account)
              (setq account (match-string 1 account)))
          (do-applescript
           (format
            "
          tell application \"Merlin\"
          activate

          set act to 0

          set listActivity to every activity of first document
          repeat with oneActivity in listActivity
          if subtitle of oneActivity is \"%s\" then
          set act to oneActivity
          exit repeat
          end if
          end repeat

          if act is 0 then
          set myselection to selected object of main window of first document as list

          if (count of myselection) is 0 then
          display dialog \"Please select activity to set time for\" buttons {\"OK\"}
          else
          set act to beginning of myselection
          end if
          end if

          if act is 0 or (class of act is project) or (is milestone of act is true) then
          display dialog \"Cannot locate activity for %s\" buttons {\"OK\"}
          else
          tell act
          if ((class is not project) and (is milestone is not true)) then
          set actual start date to (date \"%s\")
          if %s then
          set actual end date to (date \"%s\")
          delete last actuals reporting date

          set given remaining work to {amount:0, unit:hours, floating:false, ¬
          relative error:0}
          else
          delete actual end date
          set last actuals reporting date to (date \"%s\")
          end if
          set given actual work to {amount:%s, unit:%s, floating:false, ¬
          relative error:0}
          end if
          end tell
          end if
          end tell" account account start (if cleared "true" "false")
            end end  duration commodity))))))

#+end_src
*** mudel
#+begin_src emacs-lisp
;;;_ , mudel

(use-package mudel
  :commands mudel
  :bind ("C-c M" . mud)
  :init
  (defun mud ()
    (interactive)
    (mudel "4dimensions" "4dimensions.org" 6000)))

#+end_src
*** mule
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , mule

(use-package mule
  :init
  (progn
    (prefer-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))))

#+end_src
*** multi-term
#+begin_src emacs-lisp
;;;_ , multi-term

(use-package multi-term
  :bind (("C-. t" . multi-term-next)
         ("C-. T" . multi-term))
  :init
  (defun screen ()
    (interactive)
    (let (term-buffer)
      ;; Set buffer.
      (setq term-buffer
            (let ((multi-term-program (executable-find "screen"))
                  (multi-term-program-switches "-DR"))
              (multi-term-get-buffer)))
      (set-buffer term-buffer)
      ;; Internal handle for `multi-term' buffer.
      (multi-term-internal)
      ;; Switch buffer
      (switch-to-buffer term-buffer)))

  :config
  (progn
    (if t
        (defalias 'my-term-send-raw-at-prompt 'term-send-raw)
      (defun my-term-send-raw-at-prompt ()
        (interactive)
        (if (save-excursion
              (search-backward " $ " (line-beginning-position) t))
            (progn
              (if (memq 'meta (event-modifiers last-command-event))
                  (progn
                    (term-send-raw-string
                     (format "\e%c"
                             (logand last-command-event (lognot #x8000000)))))
                (call-interactively #'term-send-raw)))
          (call-interactively (lookup-key (current-global-map)
                                          (vector last-command-event))))))

    (defun my-term-end-of-buffer ()
      (interactive)
      (call-interactively #'end-of-buffer)
      (if (and (eobp) (bolp))
          (delete-char -1)))

    (require 'term)

    (defadvice term-process-pager (after term-process-rebind-keys activate)
      (define-key term-pager-break-map  "\177" 'term-pager-back-page))))

#+end_src
*** nf-procmail-mode
#+begin_src emacs-lisp
;;;_ , nf-procmail-mode

(use-package nf-procmail-mode
  :commands nf-procmail-mode)

#+end_src
*** nroff-mode
#+begin_src emacs-lisp
;;;_ , nroff-mode

(use-package nroff-mode
  :commands nroff-mode
  :config
  (progn
    (defun update-nroff-timestamp ()
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^\\.Dd ")
          (let ((stamp (format-time-string "%B %e, %Y")))
            (unless (looking-at stamp)
              (delete-region (point) (line-end-position))
              (insert stamp)
              (let (after-save-hook)
                (save-buffer)))))))

    (add-hook 'nroff-mode-hook
              #'(lambda ()
                  (add-hook 'after-save-hook 'update-nroff-timestamp nil t)))))

#+end_src
*** nxml-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , nxml-mode

(use-package nxml-mode
  :commands nxml-mode
  :init
  (defalias 'xml-mode 'nxml-mode)
  :config
  (progn
    (defun my-nxml-mode-hook ()
      (bind-key "<return>" 'newline-and-indent nxml-mode-map))

    (add-hook 'nxml-mode-hook 'my-nxml-mode-hook)

    (defun tidy-xml-buffer ()
      (interactive)
      (save-excursion
        (call-process-region (point-min) (point-max) "tidy" t t nil
                             "-xml" "-i" "-wrap" "0" "-omit" "-q")))

    (bind-key "C-H" 'tidy-xml-buffer nxml-mode-map)))

#+end_src
*** org-mode
#+begin_src emacs-lisp
;;;_ , org-mode

(use-package dot-org
  :commands org-agenda-list
  :bind (("M-C"   . jump-to-org-agenda)
         ("M-m"   . org-smart-capture)
         ("M-M"   . org-inline-note)
         ("C-c a" . org-agenda)
         ("C-c S" . org-store-link)
         ("C-c l" . org-insert-link))
  :init
  (progn
    (unless running-alternate-emacs
      (run-with-idle-timer 300 t 'jump-to-org-agenda))

    (if (string-match "\\.elc\\'" load-file-name)
        (add-hook 'after-init-hook
                  #'(lambda ()
                      (org-agenda-list)
                      (org-fit-agenda-window)
                      (org-resolve-clocks))) t)))

#+end_src

*** my org-mode
:PROPERTIES:
:tangle:   yes
:END:

Org-mode is specially treated for a few reasons:
- it has already been loaded in init.el so we could bootstrap everything else via an org-mode file.
- I prefer to go through Brent Hansen's org-mode.org setup and tweak that rather than reinvent my own config.
- [ ] insert use-package

There's a few settings needed for org-mode.org to work (I tweak it post mostly)

#+begin_src emacs-lisp
(setq org-mode-user-lisp-path 
      (expand-file-name org-dir user-emacs-directory))
(setq org-user-agenda-files (quote ()))
(setq org-mode-user-contrib-lisp-path 
      (expand-file-name "repos/jwiegley/override/org-mode/contrib/lisp" user-emacs-directory))
(org-babel-load-file (expand-file-name "~/.emacs.d/site-lisp/org-mode.org"))
#+end_src



**** org-capture

#+name: captures
| key | desc           | type       | target type   | target path                | target header | template                                             |
|-----+----------------+------------+---------------+----------------------------+---------------+------------------------------------------------------|
| ,   | ,,             | entry      | file          | ~/stuff/org/refile.org     |               | * %?\n                                               |
| t   | todo           |            |               |                            |               |                                                      |
| tu  | urgent todo    | entry      | file          | ~/stuff/org/refile.org     |               | * NEXT %? :urgent:\n:PROPERTIES:\n:OPEN: %U\n:END:\n |
| tl  | linked todo    | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n%a\n                                      |
| tn  | next todo      | entry      | file          | ~/stuff/org/refile.org     |               | * NEXT %?\n                                          |
| tt  | todo todo      | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n                                          |
| tb  | yank body      | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %?\n%c\n                                      |
| th  | yank header    | entry      | file          | ~/stuff/org/refile.org     |               | * TODO %c\n%?\n                                      |
| i   | idea           |            |               |                            |               |                                                      |
| ii  | idea           | entry      | file+headline | ~/stuff/content/ideas.org  | incoming      | * %? \n                                              |
| il  | idea link      | entry      | file+headline | ~/stuff/content/ideas.org  | links         | * %a \n %?                                           |
| iy  | idea yank      | entry      | file+headline | ~/stuff/content/ideas.org  | incoming      | * %?%c \n                                            |
| z   | bugz           | entry      | file+headline | ~/stuff/org/bugz.org       | incoming      | * TODO %?\n%a                                        |
| s   | snipz          |            |               |                            |               |                                                      |
| sr  | snipz request  | entry      | file+headline | ~/stuff/org/snipz.org      | incoming      | * TODO %?\n%a\n                                      |
| sn  | snipz note     | entry      | file+headline | ~/stuff/org/snipz.org      | incoming      | * %?\n%c\n                                           |
| b   | binding        | table-line | file+headline | ~/stuff/emacs/bindings.org | incoming      | %?                                                   |
| k   | kill ring      |            |               |                            |               |                                                      |
| kb  | kill ring body | entry      | file          | ~/stuff/org/refile.org     |               | * %?\n%c\n                                           |
| kh  | kill ring head | entry      | file          | ~/stuff/org/refile.org     |               | * %c\n%?\n                                           |


#+begin_src emacs-lisp :var data=captures  
  (setq org-capture-templates 
        (loop for row in (org-table-remove-header data)
              collect
              (eval (quote (car (read-from-string 
                                (replace-regexp-in-string "(  )" ""                                                     (replace-regexp-in-string "\"\"" "" 
                                (replace-regexp-in-string "\\\\n" "n" 
                                 (apply 'format "(%S %S %s (%s %S %S) %S)" row))))))))))
#+end_src

#+results:
| ,  | ,,             | entry      | (file ~/stuff/org/refile.org)                       | * %?\n                                               |
| t  | todo           |            |                                                     |                                                      |
| tu | urgent todo    | entry      | (file ~/stuff/org/refile.org)                       | * NEXT %? :urgent:\n:PROPERTIES:\n:OPEN: %U\n:END:\n |
| tl | linked todo    | entry      | (file ~/stuff/org/refile.org)                       | * TODO %?\n%a\n                                      |
| tn | next todo      | entry      | (file ~/stuff/org/refile.org)                       | * NEXT %?\n                                          |
| tt | todo todo      | entry      | (file ~/stuff/org/refile.org)                       | * TODO %?\n                                          |
| tb | yank body      | entry      | (file ~/stuff/org/refile.org)                       | * TODO %?\n%c\n                                      |
| th | yank header    | entry      | (file ~/stuff/org/refile.org)                       | * TODO %c\n%?\n                                      |
| i  | idea           |            |                                                     |                                                      |
| ii | idea           | entry      | (file+headline ~/stuff/content/ideas.org incoming)  | * %? \n                                              |
| il | idea link      | entry      | (file+headline ~/stuff/content/ideas.org links)     | * %a \n %?                                           |
| iy | idea yank      | entry      | (file+headline ~/stuff/content/ideas.org incoming)  | * %?%c \n                                            |
| z  | bugz           | entry      | (file+headline ~/stuff/org/bugz.org incoming)       | * TODO %?\n%a                                        |
| s  | snipz          |            |                                                     |                                                      |
| sr | snipz request  | entry      | (file+headline ~/stuff/org/snipz.org incoming)      | * TODO %?\n%a\n                                      |
| sn | snipz note     | entry      | (file+headline ~/stuff/org/snipz.org incoming)      | * %?\n%c\n                                           |
| b  | binding        | table-line | (file+headline ~/stuff/emacs/bindings.org incoming) | %?                                                   |
| k  | kill ring      |            |                                                     |                                                      |
| kb | kill ring body | entry      | (file ~/stuff/org/refile.org)                       | * %?\n%c\n                                           |
| kh | kill ring head | entry      | (file ~/stuff/org/refile.org)                       | * %c\n%?\n                                           |

**** agenda-files


#+TBLNAME: agenda-files
| git      | quaff   | quaff.org                  |
| git      | quaff   | data.org                   |
| git      | quaff   | moments.org                |
| git      | quaff   | edhec.org                  |
| git      | quaff   | jgb.org                    |
| stuff    |         | stuff.org                  |
| .emacs.d |         | README.org                 |
| .emacs.d |         | dotemacs.org               |
| stuff    | org     | refile.org                 |
| stuff    | org     | bugz.org                   |
| stuff    | org     | snipz.org                  |
| stuff    | org     | table-tests.org            |
| stuff    | org     | org.org                    |
| stuff    | emacs   | emacs.org                  |
| stuff    | emacs   | bindings.org               |
| stuff    | emacs   | regexp.org                 |
| stuff    | sys     | sys.org                    |
| stuff    | sys     | git.org                    |
| stuff    | biz     | scarce.org                 |
| stuff    | content | life.org                   |
| stuff    | content | writing.org                |
| stuff    | dev     | webdev.org                 |
| stuff    | dev     | sandpit.org                |
| stuff    | dev     | jsdev.org                  |
| stuff    | factor  | factor.org                 |
| stuff    | content | ideas.org                  |
| stuff    | factor  | parity.org                 |
| stuff    | quant   | rdev.org                   |
| stuff    | quant   | bunny.org                  |
| stuff    | quant   | volatility.org             |
| stuff    | quant   | strategy_run_annotated.org |
| stuff    | quant   | strategy_run_default.org   |
| stuff    | quant   | momentum.org               |
| stuff    | quant   | mom-report.org             |
| stuff    | quant   | xkcd.org                   |
| stuff    | quant   | tail.org                   |
| stuff    | quant   | da.org                     |
| stuff    | sys     | git.org                    |
| git      | scarce  | scarce.org                 |
| git      | scarce  | mindev.org                 |
| git      | scarce  | sitedev.org                |
| stuff    | quant   | earnings.org               |
| stuff    | dev     | alice.org                  |
| stuff    | quant   | acme.org                   |
| stuff    | quant   | dcf.org                    |
| stuff    | content | grob.org                   |
| git      | hft     | hft.org                    |
| stuff    | content | poker.org                  |

  #+begin_src emacs-lisp :var data=agenda-files
    (setq clean-table
          (delete nil  
                  (loop for line in data
                        collect 
                        (delete "" (delete-dups line)))))
    
    (setq org-agenda-files
          (mapcar
           (lambda (x) 
             (concat "~/"
                     (mapconcat
                      'eval x "/")))
           clean-table))
  #+end_src

  #+results:
  | ~/git/quaff/quaff.org | ~/git/quaff/data.org | ~/git/quaff/moments.org | ~/git/quaff/edhec.org | ~/git/quaff/jgb.org | ~/stuff/stuff.org | ~/.emacs.d/README.org | ~/.emacs.d/dotemacs.org | ~/stuff/org/refile.org | ~/stuff/org/bugz.org | ~/stuff/org/snipz.org | ~/stuff/org/table-tests.org | ~/stuff/org/org.org | ~/stuff/emacs/emacs.org | ~/stuff/emacs/bindings.org | ~/stuff/emacs/regexp.org | ~/stuff/sys/sys.org | ~/stuff/sys/git.org | ~/stuff/biz/scarce.org | ~/stuff/content/life.org | ~/stuff/content/writing.org | ~/stuff/dev/webdev.org | ~/stuff/dev/sandpit.org | ~/stuff/dev/jsdev.org | ~/stuff/factor/factor.org | ~/stuff/content/ideas.org | ~/stuff/factor/parity.org | ~/stuff/quant/rdev.org | ~/stuff/quant/bunny.org | ~/stuff/quant/volatility.org | ~/stuff/quant/strategy_run_annotated.org | ~/stuff/quant/strategy_run_default.org | ~/stuff/quant/momentum.org | ~/stuff/quant/mom-report.org | ~/stuff/quant/xkcd.org | ~/stuff/quant/tail.org | ~/stuff/quant/da.org | ~/stuff/sys/git.org | ~/git/scarce/scarce.org | ~/git/scarce/mindev.org | ~/git/scarce/sitedev.org | ~/stuff/quant/earnings.org | ~/stuff/dev/alice.org | ~/stuff/quant/acme.org | ~/stuff/quant/dcf.org | ~/stuff/content/grob.org | ~/stuff/content/poker.org |

**** other stuff
***** diminish
#+begin_src emacs-lisp
  ;;(diminish 'org-indent-mode)
#+end_src
***** tags
  #+begin_src emacs-lisp
  ; Tags with fast selection keys
(setq org-tag-alist (quote (("urgent" . ?u)
                            ("bill" . ?b)
                            ("scarce" . ?s)
                            ("crypt" . ?c)
                            ("emacs" . ?e))))
#+end_src 

  #+results:
  | (urgent . 117) | (bill . 98) | (scarce . 115) | (crypt . 99) | (emacs . 101) |
***** babel languages
   #+begin_src emacs-lisp 
    (org-babel-do-load-languages
       (quote org-babel-load-languages)
       (quote ((emacs-lisp . t)
               (sh . t)
               (gnuplot . t)
               (org . t)
               (octave . t)
               (js . t)
               (R . t))))
  #+end_src

   #+results:
   | (emacs-lisp . t) | (sh . t) | (gnuplot . t) | (org . t) | (octave . t) | (js . t) | (R . t) |
***** link abbreviations
  #+begin_src emacs-lisp
  (setq org-link-abbrev-alist
       '(("google"    . "http://www.google.com/search?q=")))
#+end_src

  #+results:
  | (google . http://www.google.com/search?q=) |
***** mobileorg settings
  #+begin_src emacs-lisp 
  (setq org-default-notes-file "~/stuff/org/refile.org")
  ;; Set to the name of the file where new notes will be stored
  (setq org-mobile-inbox-for-pull "~/stuff/org/refile.org")
  ;; Set to <your Dropbox root directory>/MobileOrg.
  (setq org-mobile-directory "~/Dropbox/MobileOrg")
#+end_src

  #+results:
  : ~/Dropbox/MobileOrg
***** override settings
    #+begin_src emacs-lisp
      (remove-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp)
    #+end_src

    #+results:

  Using priorities kills the ability to ever use S-down to select
  regions.  Can't bring myself to do it - instead I use an urgent tag.

  #+begin_src emacs-lisp 
  (setq org-enable-priority-commands nil)
  #+end_src
***** packages

  #+begin_src emacs-lisp
  (use-package org-magit)
  (use-package org-habit)
#+end_src

***** jumping
#+begin_src emacs-lisp
  (defun org-jump ()
    (interactive)
    (bookmark-set "org-jumped-from")
    (org-refile t nil nil "Jump")
    (bookmark-set "org-jumped-to"))
    
   
  (defun org-jump-back()
    (interactive)
    (if (equal (point) (bookmark-get-position "org-jumped-from"))
        (bookmark-jump "org-jumped-to")
      (if (bookmark-get-position "org-jumped-to")
          (bookmark-jump "org-jumped-from"))))
     
  
  (bind-key "C-. j" 'org-jump)
  (bind-key "C-. l" 'org-jump-back)
#+end_src

#+results:
: org-jump-back


**** org bind

shoving the binds in binds so I can see where everything is
#+name: org-bindings
| key       | binding                                           |
|-----------+---------------------------------------------------|
| C-c l     | org-store-link                                    |
| C-c a     | org-agenda                                        |
| C-c b     | org-iswitchb                                      |
| <f12>     | org-agenda                                        |
| <f5>      | bh/org-todo                                       |
| <S-f5>    | bh/widen                                          |
| <f7>      | bh/set-truncate-lines                             |
| <f8>      | org-cycle-agenda-files                            |
| <f9> <f9> | bh/show-org-agenda                                |
| <f9> b    | bbdb                                              |
| <f9> c    | calendar                                          |
| <f9> f    | boxquote-insert-file                              |
| <f9> g    | gnus                                              |
| <f9> h    | bh/hide-other                                     |
| <f9> n    | org-narrow-to-subtree                             |
| <f9> w    | widen                                             |
| <f9> u    | bh/narrow-up-one-level                            |
| <f9> I    | bh/punch-in                                       |
| <f9> O    | bh/punch-out                                      |
| <f9> o    | bh/make-org-scratch                               |
| <f9> r    | boxquote-region                                   |
| <f9> s    | bh/switch-to-scratch                              |
| <f9> t    | bh/insert-inactive-timestamp                      |
| <f9> T    | tabify                                            |
| <f9> U    | untabify                                          |
| <f9> v    | visible-mode                                      |
| <f9> SPC  | bh/clock-in-last-task                             |
| C-<f9>    | previous-buffer                                   |
| M-<f9>    | org-toggle-inline-images                          |
| C-x n r   | narrow-to-region                                  |
| C-<f10>   | next-buffer                                       |
| <f11>     | org-clock-goto                                    |
| C-<f11>   | org-clock-in                                      |
| C-s-<f12> | bh/save-then-publish                              |
| C-M-r     | org-capture                                       |
| C-c r     | org-capture                                       |
| C-M-r     | org-capture                                       |
| C-c r     | org-capture                                       |
| <f9> p    | bh/phone-call                                     |
| C-s-<f12> | bh/save-then-publish                              |
| <f5>      | bh/org-todo                                       |
| <S-f5>    | bh/widen                                          |
| <f9> t    | bh/insert-inactive-timestamp                      |
| M-x       | smex                                              |
| C-x x     | smex                                              |
| M-X       | smex-major-mode-commands                          |
| <C-f6>    | (lambda () (interactive) (bookmark-set "SAVED"))  |
| <f6>      | (lambda () (interactive) (bookmark-jump "SAVED")) |

#+begin_src emacs-lisp :var table=org-bindings
  (bind-keys-from-table (org-table-remove-header table))
#+end_src


*** paredit
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , paredit

(use-package paredit
  :commands paredit-mode
  :diminish paredit-mode
  :config
  (progn
    (use-package paredit-ext)

    (bind-key "C-M-l" 'paredit-recentre-on-sexp paredit-mode-map)

    (bind-key ")" 'paredit-close-round-and-newline paredit-mode-map)
    (bind-key "M-)" 'paredit-close-round paredit-mode-map)

    (bind-key "M-k" 'paredit-raise-sexp paredit-mode-map)
    (bind-key "M-h" 'mark-containing-sexp paredit-mode-map)
    (bind-key "M-I" 'paredit-splice-sexp paredit-mode-map)

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (bind-key "C-. d" 'paredit-forward-down paredit-mode-map)
    (bind-key "C-. B" 'paredit-splice-sexp-killing-backward paredit-mode-map)
    (bind-key "C-. C" 'paredit-convolute-sexp paredit-mode-map)
    (bind-key "C-. F" 'paredit-splice-sexp-killing-forward paredit-mode-map)
    (bind-key "C-. a" 'paredit-add-to-next-list paredit-mode-map)
    (bind-key "C-. A" 'paredit-add-to-previous-list paredit-mode-map)
    (bind-key "C-. j" 'paredit-join-with-next-list paredit-mode-map)
    (bind-key "C-. J" 'paredit-join-with-previous-list paredit-mode-map)

    (add-hook 'allout-mode-hook
              #'(lambda ()
                  (bind-key "M-k" 'paredit-raise-sexp allout-mode-map)
                  (bind-key "M-h" 'mark-containing-sexp allout-mode-map)))))

#+end_src
*** paren
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , paren

(unless
    (use-package mic-paren
          :init
          (paren-activate))

  (use-package paren
    :init
    (show-paren-mode 1)))

#+end_src
*** per-window-point
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , per-window-point

(use-package per-window-point
  :init
  (pwp-mode 1))

#+end_src
*** persistent-scratch
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , persistent-scratch

(use-package persistent-scratch
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive)))

#+end_src
*** popup-ruler
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , popup-ruler

(use-package popup-ruler
  :bind (("C-. r" . popup-ruler)
         ("C-. R" . popup-ruler-vertical)))

#+end_src
*** pp-c-l
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , pp-c-l

(use-package pp-c-l
  :init
  (hook-into-modes 'pretty-control-l-mode '(prog-mode-hook)))

#+end_src
*** ps-print
#+begin_src emacs-lisp
;;;_ , ps-print

(use-package ps-print
  :defer t
  :config
  (progn
    (defun ps-spool-to-pdf (beg end &rest ignore)
      (interactive "r")
      (let ((temp-file (concat (make-temp-name "ps2pdf") ".pdf")))
        (call-process-region beg end (executable-find "ps2pdf")
                             nil nil nil "-" temp-file)
        (call-process (executable-find "open") nil nil nil temp-file)))

    (setq ps-print-region-function 'ps-spool-to-pdf)))

#+end_src
*** puppet-mode
#+begin_src emacs-lisp
;;;_ , puppet-mode

(use-package puppet-mode
  :mode ("\\.pp\\'" . puppet-mode)
  :config
  (use-package puppet-ext))

#+end_src
*** python-mode
#+begin_src emacs-lisp
;;;_ , python-mode

(use-package python-mode
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)
  :config
  (progn
    (defvar python-mode-initialized nil)

    (defun my-python-mode-hook ()
      (unless python-mode-initialized
        (setq python-mode-initialized t)

        (info-lookup-add-help
         :mode 'python-mode
         :regexp "[a-zA-Z_0-9.]+"
         :doc-spec
         '(("(python)Python Module Index" )
           ("(python)Index"
            (lambda
              (item)
              (cond
               ((string-match
                 "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
                (format "%s.%s" (match-string 2 item)
                        (match-string 1 item)))))))))

      (setq indicate-empty-lines t)
      (set (make-local-variable 'parens-require-spaces) nil)
      (setq indent-tabs-mode nil)

      (bind-key "C-c C-z" 'python-shell python-mode-map)
      (unbind-key "C-c c" python-mode-map))

    (add-hook 'python-mode-hook 'my-python-mode-hook)))

#+end_src
*** quickrun
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , quickrun

(use-package quickrun
  :bind ("C-c C-r" . quickrun))

#+end_src
*** recentf
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , recentf

(use-package recentf
  :if (not noninteractive)
  :init
  (progn
    (recentf-mode 1)

    (defun recentf-add-dired-directory ()
      (if (and dired-directory
               (file-directory-p dired-directory)
               (not (string= "/" dired-directory)))
          (let ((last-idx (1- (length dired-directory))))
            (recentf-add-file
             (if (= ?/ (aref dired-directory last-idx))
                 (substring dired-directory 0 last-idx)
               dired-directory)))))

    (add-hook 'dired-mode-hook 'recentf-add-dired-directory)))

#+end_src
*** repeat-insert
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , repeat-insert

(use-package repeat-insert
  :disabled t
  :commands (insert-patterned
             insert-patterned-2
             insert-patterned-3
             insert-patterned-4))

#+end_src
*** ruby-mode
#+begin_src emacs-lisp
;;;_ , ruby-mode

(use-package ruby-mode
  :mode ("\\.rb\\'" . ruby-mode)
  :interpreter ("ruby" . ruby-mode)
  :config
  (progn
    (use-package yari
      :init
      (progn
        (defvar yari-helm-source-ri-pages
          '((name . "RI documentation")
            (candidates . (lambda () (yari-ruby-obarray)))
            (action  ("Show with Yari" . yari))
            (candidate-number-limit . 300)
            (requires-pattern . 2)
            "Source for completing RI documentation."))

        (defun helm-yari (&optional rehash)
          (interactive (list current-prefix-arg))
          (when current-prefix-arg (yari-ruby-obarray rehash))
          (helm 'yari-helm-source-ri-pages (yari-symbol-at-point)))))

    (defun my-ruby-smart-return ()
      (interactive)
      (when (memq (char-after) '(?\| ?\" ?\'))
        (forward-char))
      (call-interactively 'newline-and-indent))

    (defun my-ruby-mode-hook ()
      (require 'inf-ruby)
      (inf-ruby-keys)

      (bind-key "<return>" 'my-ruby-smart-return ruby-mode-map)
      (bind-key "C-h C-i" 'helm-yari ruby-mode-map)

      (set (make-local-variable 'yas/fallback-behavior)
           '(apply ruby-indent-command . nil))
      (bind-key "<tab>" 'yas/expand-from-trigger-key ruby-mode-map))

    (add-hook 'ruby-mode-hook 'my-ruby-mode-hook)))

#+end_src
*** selectkey
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , selectkey

(use-package selectkey
  :init
  (progn
    (bind-key "C-. b" 'selectkey-select-prefix-map)

    (selectkey-define-select-key compile "c" "\\*compilation")
    (selectkey-define-select-key shell-command "o" "Shell Command")
    (selectkey-define-select-key shell "s" "\\*shell" (shell))
    (selectkey-define-select-key multi-term "t" "\\*terminal" (multi-term-next))
    (selectkey-define-select-key eshell "z" "\\*eshell" (eshell))))

#+end_src
*** session
#+begin_src emacs-lisp
;;;_ , session

(use-package session
  :if (not noninteractive)
  :load-path "site-lisp/session/lisp/"
  :init
  (progn
    (session-initialize)

    (defun remove-session-use-package-from-settings ()
      (when (string= (buffer-file-name)
                     (expand-file-name "settings.el"
                                       user-emacs-directory))
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^ '(session-use-package " nil t)
            (delete-region (line-beginning-position)
                           (1+ (line-end-position)))))))

    (add-hook 'before-save-hook 'remove-session-use-package-from-settings)

    ;; expanded folded secitons as required
    (defun le::maybe-reveal ()
      (when (and (or (memq major-mode  '(org-mode outline-mode))
                     (and (boundp 'outline-minor-mode)
                          outline-minor-mode))
                 (outline-invisible-p))
        (if (eq major-mode 'org-mode)
            (org-reveal)
          (show-subtree))))

    (add-hook 'session-after-jump-to-last-change-hook
              'le::maybe-reveal)

    (defun save-information ()
      (with-temp-message "Saving Emacs information..."
        (recentf-cleanup)

        (loop for func in kill-emacs-hook
              unless (memq func '(exit-gnus-on-exit server-force-stop))
              do (funcall func))

        (unless (or noninteractive
                    running-alternate-emacs
                    (eq 'listen (process-status server-process)))
          (server-start))))

    (run-with-idle-timer 300 t 'save-information)

    (if window-system
        (add-hook 'after-init-hook 'session-initialize t))))

#+end_src
*** sh-script
#+begin_src emacs-lisp
;;;_ , sh-script

(use-package sh-script
  :defer t
  :config
  (progn
    (defvar sh-script-initialized nil)
    (defun initialize-sh-script ()
      (unless sh-script-initialized
        (setq sh-script-initialized t)
        (info-lookup-add-help :mode 'shell-script-mode
                              :regexp ".*"
                              :doc-spec
                              '(("(bash)Index")))))

    (add-hook 'shell-mode-hook 'initialize-sh-script)))

#+end_src
*** sh-toggle
#+begin_src emacs-lisp
;;;_ , sh-toggle

(use-package sh-toggle
  :bind ("C-. C-z" . shell-toggle))

#+end_src
*** slime
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , slime

(use-package slime
  :commands (sbcl slime)
  :init
  (add-hook
   'slime-load-hook
   #'(lambda ()
       (slime-setup
        '(slime-asdf
          slime-autodoc
          slime-banner
          slime-c-p-c
          slime-editing-commands
          slime-fancy-inspector
          slime-fancy
          slime-fuzzy
          slime-highlight-edits
          slime-parse
          slime-presentation-streams
          slime-presentations
          slime-references
          slime-repl
          slime-sbcl-exts
          slime-package-fu
          slime-fontifying-fu
          slime-mdot-fu
          slime-scratch
          slime-tramp
          ;; slime-enclosing-context
          ;; slime-typeout-frame
          slime-xref-browser))

       (define-key slime-repl-mode-map [(control return)] 'other-window)

       (define-key slime-mode-map [return] 'paredit-newline)
       (define-key slime-mode-map [(control ?h) ?F] 'info-lookup-symbol)))

  :config
  (progn
    (eval-when-compile
      (defvar slime-repl-mode-map))



    (setq slime-net-coding-system 'utf-8-unix)

    (setq slime-lisp-implementations
          '((sbcl
             ("sbcl" "--core"
              "/Users/johnw/Library/Lisp/sbcl.core-with-slime-X86-64")
             :init
             (lambda (port-file _)
               (format "(swank:start-server %S)\n" port-file)))
            (ecl ("ecl" "-load" "/Users/johnw/Library/Lisp/init.lisp"))
            (clisp ("clisp" "-i" "/Users/johnw/Library/Lisp/lwinit.lisp"))))

    (setq slime-default-lisp 'sbcl)
    (setq slime-complete-symbol*-fancy t)
    (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)

    (defun sbcl (&optional arg)
      (interactive "P")
      (let ((slime-default-lisp (if arg 'sbcl64 'sbcl))
            (current-prefix-arg nil))
        (slime)))
    (defun clisp () (interactive) (let ((slime-default-lisp 'clisp)) (slime)))
    (defun ecl () (interactive) (let ((slime-default-lisp 'ecl)) (slime)))

    (defun start-slime ()
      (interactive)
      (unless (slime-connected-p)
        (save-excursion (slime))))

    (add-hook 'slime-mode-hook 'start-slime)
    (add-hook 'slime-load-hook #'(lambda () (require 'slime-fancy)))
    (add-hook 'inferior-lisp-mode-hook #'(lambda () (inferior-slime-mode t)))

    (use-package hyperspec
      :init
      (setq common-lisp-hyperspec-root
            "/opt/local/share/doc/lisp/HyperSpec-7-0/HyperSpec/"))))

#+end_src
*** smart-compile
#+begin_src emacs-lisp
;;;_ , smart-compile

(use-package smart-compile
  :commands smart-compile
  :bind (("C-c c" . smart-compile)
         ("A-n"   . next-error)
         ("A-p"   . previous-error))
  :init
  (progn
    (defun show-compilation ()
      (interactive)
      (let ((compile-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*compilation\\*" (buffer-name buf))
                     (throw 'found buf))))))
        (if compile-buf
            (switch-to-buffer-other-window compile-buf)
          (call-interactively 'compile))))

  (bind-key "M-O" 'show-compilation)))

#+end_src
*** smerge-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , smerge-mode

(use-package smerge-mode
  :commands (smerge-mode smerge-command-prefix)
  :init
  (setq smerge-command-prefix (kbd "C-. C-.")))

#+end_src
*** stopwatch
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , stopwatch

(use-package stopwatch
  :bind ("<f8>" . stopwatch))

#+end_src
*** sunrise-commander
#+begin_src emacs-lisp
;;;_ , sunrise-commander

(use-package sunrise-commander
  :disabled t
  :commands (sunrise sunrise-cd)
  :init
  (progn
    (defun my-activate-sunrise ()
      (interactive)
      (let ((sunrise-exists
             (loop for buf in (buffer-list)
                   when (string-match " (Sunrise)$" (buffer-name buf))
                   return buf)))
        (if sunrise-exists
            (call-interactively 'sunrise)
          (sunrise "~/dl/" "~/Archives/"))))

    (bind-key "C-c j" 'my-activate-sunrise)
    (bind-key "C-c C-j" 'sunrise-cd))

  :config
  (progn
    (require 'sunrise-x-modeline)
    (require 'sunrise-x-tree)
    (require 'sunrise-x-tabs)

    (bind-key "/" 'sr-sticky-isearch-forward sr-mode-map)
    (bind-key "<backspace>" 'sr-scroll-quick-view-down sr-mode-map)
    (bind-key "C-x t" 'sr-toggle-truncate-lines sr-mode-map)

    (bind-key "q" 'sr-history-prev sr-mode-map)
    (bind-key "z" 'sr-quit sr-mode-map)

    (unbind-key "C-e" sr-mode-map)
    (unbind-key "C-p" sr-tabs-mode-map)
    (unbind-key "C-n" sr-tabs-mode-map)
    (unbind-key "M-<backspace>" sr-term-line-minor-mode-map)

    (bind-key "M-[" 'sr-tabs-prev sr-tabs-mode-map)
    (bind-key "M-]" 'sr-tabs-next sr-tabs-mode-map)

    (defun sr-browse-file (&optional file)
      "Display the selected file with the default appication."
      (interactive)
      (setq file (or file (dired-get-filename)))
      (save-selected-window
        (sr-select-viewer-window)
        (let ((buff (current-buffer))
              (fname (if (file-directory-p file)
                         file
                       (file-name-nondirectory file)))
              (app (cond
                    ((eq system-type 'darwin)       "open %s")
                    ((eq system-type 'windows-nt)   "open %s")
                    (t                              "xdg-open %s"))))
          (start-process-shell-command "open" nil (format app file))
          (unless (eq buff (current-buffer))
            (sr-scrollable-viewer (current-buffer)))
          (message "Opening \"%s\" ..." fname))))

    (defun sr-goto-dir (dir)
      "Change the current directory in the active pane to the given one."
      (interactive (list (progn
                           (require 'lusty-explorer)
                           (lusty-read-directory))))
      (if sr-goto-dir-function
          (funcall sr-goto-dir-function dir)
        (unless (and (eq major-mode 'sr-mode)
                     (sr-equal-dirs dir default-directory))
          (if (and sr-avfs-root
                   (null (posix-string-match "#" dir)))
              (setq dir (replace-regexp-in-string
                         (expand-file-name sr-avfs-root) "" dir)))
          (sr-save-aspect
           (sr-within dir (sr-alternate-buffer (dired dir))))
          (sr-history-push default-directory)
          (sr-beginning-of-buffer))))))

#+end_src
*** tablegen-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , tablegen-mode

(use-package tablegen-mode
  :description "\
  This mode is used for editing .td files in the LLVM/Clang source code."
  :mode ("\\.td\\'" . tablegen-mode))

#+end_src
*** texinfo
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , texinfo

(use-package texinfo
  :defines texinfo-section-list
  :mode ("\\.texi\\'" . texinfo-mode)
  :config
  (progn
    (defun my-texinfo-mode-hook ()
      (dolist (mapping '((?b . "emph")
                         (?c . "code")
                         (?s . "samp")
                         (?d . "dfn")
                         (?o . "option")
                         (?x . "pxref")))
        (local-set-key (vector (list 'alt (car mapping)))
                       `(lambda () (interactive)
                          (TeX-insert-macro ,(cdr mapping))))))

    (add-hook 'texinfo-mode-hook 'my-texinfo-mode-hook)

    (defun texinfo-outline-level ()
      ;; Calculate level of current texinfo outline heading.
      (require 'texinfo)
      (save-excursion
        (if (bobp)
            0
          (forward-char 1)
          (let* ((word (buffer-substring-no-properties
                        (point) (progn (forward-word 1) (point))))
                 (entry (assoc word texinfo-section-list)))
            (if entry
                (nth 1 entry)
              5)))))))

#+end_src
*** vkill
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , vkill

(use-package vkill
  :commands vkill
  :init
  (progn
    (defun vkill-and-helm-occur ()
      (interactive)
      (vkill)
      (call-interactively #'helm-occur))

    (bind-key "C-x L" 'vkill-and-helm-occur))

  :config
  (setq vkill-show-all-processes t))

#+end_src
*** w3m
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , w3m

(use-package w3m
  :commands (w3m-search w3m-find-file)
  :bind (("C-. u"   . w3m-browse-url)
         ("C-. U"   . w3m-browse-url-new-session)
         ("C-. A-u" . w3m-browse-chrome-url-new-session))
  :init
  (progn
    (setq w3m-command "/usr/local/bin/w3m")

    (setq w3m-coding-system 'utf-8
          w3m-file-coding-system 'utf-8
          w3m-file-name-coding-system 'utf-8
          w3m-input-coding-system 'utf-8
          w3m-output-coding-system 'utf-8
          w3m-terminal-coding-system 'utf-8)

    (add-hook 'w3m-mode-hook 'w3m-link-numbering-mode)

    (autoload 'w3m-session-crash-recovery-remove "w3m-session")

    (defun show-browser ()
      (interactive)
      (let ((w3m-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*w3m" (buffer-name buf))
                     (throw 'found buf))))))
        (if w3m-buf
            (switch-to-buffer-other-window w3m-buf)
          (call-interactively 'w3m-find-file))))

    (bind-key "C-. w" 'show-browser)

    (defun wikipedia-query (term)
      (interactive (list (read-string "Wikipedia search: " (word-at-point))))
      (require 'w3m-search)
      (w3m-search "en.wikipedia" term))

    (eval-when-compile
      (autoload 'w3m-search-escape-query-string "w3m-search"))

    (defun wolfram-alpha-query (term)
      (interactive (list (read-string "Ask Wolfram Alpha: " (word-at-point))))
      (require 'w3m-search)
      (w3m-browse-url (concat "http://m.wolframalpha.com/input/?i="
                              (w3m-search-escape-query-string term))))

    (defun goto-emacswiki ()
      (interactive)
      (w3m-browse-url "http://www.emacswiki.org"))

    (defun w3m-browse-url-new-session (url)
      (interactive (progn
                     (require 'browse-url)
                     (browse-url-interactive-arg "Emacs-w3m URL: ")))
      (w3m-browse-url url t))

    (defun w3m-browse-chrome-url-new-session ()
      (interactive)
      (let ((url (do-applescript
                  (string-to-multibyte "tell application \"Google Chrome\"
  URL of active tab of front window
  end tell"))))
        (w3m-browse-url (substring url 1 (1- (length url))) t)))

    (bind-key "A-M-e" 'goto-emacswiki)
    (bind-key "A-M-g" 'w3m-search)
    (bind-key "A-M-w" 'wikipedia-query))

  :config
  (let (proxy-host proxy-port)
    (with-temp-buffer
      (shell-command "scutil --proxy" (current-buffer))

      (when (re-search-forward "HTTPPort : \\([0-9]+\\)" nil t)
        (setq proxy-port (match-string 1)))
      (when (re-search-forward "HTTPProxy : \\(\\S-+\\)" nil t)
        (setq proxy-host (match-string 1))))

    (if (and proxy-host proxy-port)
        (setq w3m-command-arguments
              (nconc w3m-command-arguments
                     (list "-o" (format "http_proxy=http://%s:%s/"
                                        proxy-host proxy-port)))))

    (use-package w3m-type-ahead
      :requires w3m
      :init
      (add-hook 'w3m-mode-hook 'w3m-type-ahead-mode))

    (add-hook 'w3m-display-hook
              (lambda (url)
                (let ((buffer-read-only nil))
                  (delete-trailing-whitespace))))

    (defun my-w3m-linknum-follow ()
      (interactive)
      (w3m-linknum-follow))

    (bind-key "k" 'w3m-delete-buffer w3m-mode-map)
    (bind-key "i" 'w3m-view-previous-page w3m-mode-map)
    (bind-key "p" 'w3m-previous-anchor w3m-mode-map)
    (bind-key "n" 'w3m-next-anchor w3m-mode-map)

    (defun dka-w3m-textarea-hook()
      (save-excursion
        (while (re-search-forward "\r\n" nil t)
          (replace-match "\n" nil nil))
        (delete-other-windows)))

    (add-hook 'w3m-form-input-textarea-mode-hook 'dka-w3m-textarea-hook)

    (bind-key "<return>" 'w3m-view-url-with-external-browser
              w3m-minor-mode-map)
    (bind-key "S-<return>" 'w3m-safe-view-this-url w3m-minor-mode-map)))

#+end_src

#+results:
: t

*** wcount-mode
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , wcount-mode

(use-package wcount-mode
  :commands wcount)

#+end_src
*** whitespace
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , whitespace

(use-package whitespace
  :diminish (global-whitespace-mode
             whitespace-mode
             whitespace-newline-mode)
  :commands (whitespace-buffer
             whitespace-cleanup
             whitespace-mode)
  :init
  (progn
    (hook-into-modes 'whitespace-mode
                     '(prog-mode-hook
                       c-mode-common-hook))

    (defun normalize-file ()
      (interactive)
      (save-excursion
      (goto-char (point-min))
        (whitespace-cleanup)
        (delete-trailing-whitespace)
        (goto-char (point-max))
        (delete-blank-lines)
        (set-buffer-file-coding-system 'unix)
        (goto-char (point-min))
        (while (re-search-forward "\r$" nil t)
          (replace-match ""))
        (set-buffer-file-coding-system 'utf-8)
        (let ((require-final-newline t))
          (save-buffer))))

    (defun maybe-turn-on-whitespace ()
      "Depending on the file, maybe clean up whitespace."
      (let ((file (expand-file-name ".clean"))
            parent-dir)
        (while (and (not (file-exists-p file))
                    (progn
                      (setq parent-dir
                            (file-name-directory
                             (directory-file-name
                              (file-name-directory file))))
                      ;; Give up if we are already at the root dir.
                      (not (string= (file-name-directory file)
                                    parent-dir))))
          ;; Move up to the parent dir and try again.
          (setq file (expand-file-name ".clean" parent-dir)))
        ;; If we found a change log in a parent, use that.
        (when (and (file-exists-p file)
                   (not (file-exists-p ".noclean"))
                   (not (and buffer-file-name
                             (string-match "\\.texi\\'" buffer-file-name))))
          (add-hook 'write-contents-hooks
                    #'(lambda ()
                        (ignore (whitespace-cleanup))) nil t)
          (whitespace-cleanup))))

    (add-hook 'find-file-hooks 'maybe-turn-on-whitespace t))

  :config
  (progn
    (remove-hook 'find-file-hooks 'whitespace-buffer)
    (remove-hook 'kill-buffer-hook 'whitespace-buffer)))

#+end_src
*** winner
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , winner

(use-package winner
  :diminish winner-mode
  :if (not noninteractive)
  :init
  (progn
    (winner-mode 1)

    (bind-key "M-N" 'winner-redo)
    (bind-key "M-P" 'winner-undo)))

#+end_src
*** workgroups
#+begin_src emacs-lisp
;;;_ , workgroups

(use-package workgroups
  :diminish workgroups-mode
  :if (not noninteractive)
  :init
  (progn
    (workgroups-mode 1)

    (let ((workgroups-file (expand-file-name "workgroups" user-data-directory)))
      (if (file-readable-p workgroups-file)
          (wg-load workgroups-file)))

    (bind-key "C-\\" 'wg-switch-to-previous-workgroup wg-map)
    (bind-key "\\" 'toggle-input-method wg-map)))

#+end_src
*** wrap-region
:PROPERTIES:
:tangle:   yes
:END:
#+begin_src emacs-lisp
;;;_ , wrap-region

(use-package wrap-region
  :commands wrap-region-mode
  :diminish wrap-region-mode
  :config
  (wrap-region-add-wrappers
   '(("$" "$")
     ("/" "/" nil ruby-mode)
     ("/* " " */" "#" (java-mode javascript-mode css-mode c-mode c++-mode))
     ("`" "`" nil (markdown-mode ruby-mode shell-script-mode)))))

#+end_src
*** write-room
:PROPERTIES:
:tangle:   yes
:END:


#+begin_src emacs-lisp
;;;_ , write-room
(defvar in-write-room nil)

(defun write-room ()
  "Make a frame without any bling."
  (interactive)
  ;; to restore:
  ;; (setq mode-line-format (default-value 'mode-line-format))
  (let ((frame (make-frame
                '((minibuffer . nil)
                  (vertical-scroll-bars . nil)
                  (left-fringe . 0); no fringe
                  (right-fringe . 0)
                  ;;(background-mode . dark)
                  ;;(background-color . "cornsilk")
                  ;;(foreground-color . "black")
                  (cursor-color . "green")
                  (border-width . 0)
                  (border-color . "black"); should be unnecessary
                  (internal-border-width . 64); whitespace!
                  (cursor-type . box)
                  (menu-bar-lines . 0)
                  (tool-bar-lines . 0)
                  (fullscreen . fullboth)  ; this should work
                  (unsplittable . t)))))
    (select-frame frame)
    (find-file "~/Documents/Notes.txt")
    (setq mode-line-format nil
          fill-column 65)
    (set-window-margins (selected-window) 50 50)))

(defun toggle-write-room ()
  (interactive)
  (if in-write-room
      (progn
        (select-frame (make-frame))
        (setq mode-line-format (default-value 'mode-line-format))
        (setq in-write-room nil))
    (progn
      (setq in-write-room t)
      (write-room))))

(bind-key "C-c w" 'toggle-write-room)
#+end_src

#+RESULTS:
: toggle-write-room

*** yasnippet
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
;;;_ , yasnippet

(use-package yasnippet
  :if (not noninteractive)
  :commands (yas/minor-mode yas/expand)
  :diminish yas/minor-mode
  :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
  :init
  (hook-into-modes #'(lambda () (yas/minor-mode 1))
                   '(prog-mode-hook
                     org-mode-hook
                     ruby-mode-hook
                     message-mode-hook
                     gud-mode-hook
                     erc-mode-hook))
  :config
  (progn
    (yas/initialize)
    (yas/load-directory (expand-file-name "snippets/" user-emacs-directory))

    (bind-key "<tab>" 'yas/next-field-or-maybe-expand yas/keymap)

    (defun yas/new-snippet (&optional choose-instead-of-guess)
      (interactive "P")
      (let ((guessed-directories (yas/guess-snippet-directories)))
        (switch-to-buffer "*new snippet*")
        (erase-buffer)
        (kill-all-local-variables)
        (snippet-mode)
        (set (make-local-variable 'yas/guessed-modes)
             (mapcar #'(lambda (d)
                         (intern (yas/table-name (car d))))
                     guessed-directories))
        (unless (and choose-instead-of-guess
                     (not (y-or-n-p "Insert a snippet with useful headers? ")))
          (yas/expand-snippet "\
  # -*- mode: snippet -*-
  # name: $1
  # --
  $0"))))
    (defvar ctl-c-y-map)
    (define-prefix-command 'ctl-c-y-map)
    (bind-key "C-c y" 'ctl-c-y-map)
    (bind-key "C-c y TAB" 'yas/expand)
    (bind-key "C-c y n" 'yas/new-snippet)
    (bind-key "C-c y f" 'yas/find-snippets)
    (bind-key "C-c y r" 'yas/reload-all)
    (bind-key "C-c y v" 'yas/visit-snippet-file)))

#+end_src

#+begin_src emacs-lisp
  (eval-when-compile
  (defvar yas/trigger-key)
  (defvar yas/keymap)

  (autoload 'yas/expand "yasnippet"))

(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
          (lambda ()
            (require 'yasnippet)
            (set (make-local-variable 'yas/trigger-key) [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
#+end_src





#+results:

*** yaoddmuse
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , yaoddmuse

(use-package yaoddmuse
  :bind (("C-c w f" . yaoddmuse-browse-page-default)
         ("C-c w e" . yaoddmuse-edit-default)
         ("C-c w p" . yaoddmuse-post-library-default)))

#+end_src
*** zencoding-mode
    :PROPERTIES:
    :tangle:   yes
    :END:
#+begin_src emacs-lisp
  ;;;_ , zencoding-mode
  
  (use-package zencoding-mode
    :commands zencoding-mode
    :init
    (progn
      (add-hook 'nxml-mode-hook 'zencoding-mode)
      (add-hook 'html-mode-hook 'zencoding-mode)
      (add-hook 'html-mode-hook
                #'(lambda ()
                  (bind-key "<return>" 'newline-and-indent html-mode-map))))
  
    :config
    (progn
      (defvar zencoding-mode-keymap (make-sparse-keymap))
      (bind-key "C-c C-c" 'zencoding-expand-line zencoding-mode-keymap)))
  
#+end_src

* files
  :PROPERTIES:
  :tangle:   no
  :END:

#+name: init-file-loads
| file                 | toggle |
|----------------------+--------|
| org-mode-prequel.org |        |
| org-mode.org         |        |
| org-mode-mods.org    |        |
| my-old-org.org       |        |

#+begin_src emacs-lisp :var init-file-loads=init-file-loads
  (defvar other-init-files
        (list ())
        "Files that are loaded in addition to dotemacs.org.")
  (setq file-loads (org-table-list-and-toggle init-file-loads))
  (dolist (file file-loads)
    (org-babel-load-file (expand-file-name file user-emacs-directory)))
#+end_src

#+results:

* endboot
:PROPERTIES:
:tangle:   yes
:END:
** Load customization settings
:PROPERTIES:
:tangle:   no
:END:
#+begin_src emacs-lisp
;;;_ , Load customization settings

(defvar running-alternate-emacs nil)

(if (string-match (concat "/Applications/\\(Misc/\\)?"
                          "Emacs\\([A-Za-z]+\\).app/Contents/MacOS/")
                  invocation-directory)

    (let ((settings (with-temp-buffer
                      (insert-file-contents
                       (expand-file-name "settings.el" user-emacs-directory))
                      (goto-char (point-min))
                      (read (current-buffer))))
          (suffix (downcase (match-string 2 invocation-directory))))

      (setq running-alternate-emacs t
            user-data-directory
            (replace-regexp-in-string "/data/" (format "/data-%s/" suffix)
                                      user-data-directory))

      (let* ((regexp "/\\.emacs\\.d/data/")
             (replace (format "/.emacs.d/data-%s/" suffix)))
        (dolist (setting settings)
          (let ((value (and (listp setting)
                            (nth 1 (nth 1 setting)))))
            (if (and (stringp value)
                     (string-match regexp value))
                (setcar (nthcdr 1 (nth 1 setting))
                        (replace-regexp-in-string regexp replace value)))))

        (eval settings)))

  (load (expand-file-name "settings" user-emacs-directory)))

#+end_src

** simple custom
   Custom file load needs to go at the end, to override org-mode.org
   settings.
 
   #+begin_src emacs-lisp
(setq custom-file (expand-file-name "settings.el" user-emacs-directory))
(load custom-file)
   #+end_src

** Post initialization
#+begin_src emacs-lisp
;;;_. Post initialization

(when window-system
  (let ((elapsed (float-time (time-subtract (current-time)
                                            emacs-start-time))))
    (message "Loading %s...done (%.3fs)" load-file-name elapsed))

  (add-hook 'after-init-hook
            `(lambda ()
               (let ((elapsed (float-time (time-subtract (current-time)
                                                         emacs-start-time))))
                 (message "Loading %s...done (%.3fs) [after-init]"
                          ,load-file-name elapsed)))
            t))

#+end_src
  
* clipboard
:PROPERTIES:
:tangle:   no
:END:
** ideaz
Mostly from Sacha
*** Quantified Emacs!
:PROPERTIES:
:tangle:   yes
:END:

#+begin_src emacs-lisp
  (use-package keyfreq
    :init
    (progn
      (keyfreq-mode 1)
      (keyfreq-autosave-mode 1)))
#+end_src


*** Kill-ring management

#+begin_src emacs-lisp
  (sacha/package-install 'browse-kill-ring)
  (use-package browse-kill-ring
    :init 
    (progn 
      (browse-kill-ring-default-keybindings)
      (setq browse-kill-ring-quit-action 'save-and-restore)))      
#+end_src



*** Better undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :init (global-undo-tree-mode))
#+end_src
*** Frequently-accessed files
Registers allow you to jump to a file or other location quickly. To
jump to a register, use =C-x r j= followed by the letter of the
register.

#+begin_src emacs-lisp :results silent
  (dolist
      (r `((?i (file . ,(expand-file-name (concat user-login-name ".org") starter-kit-dir)))
           (?o (file . "~/personal/organizer.org"))
           (?b (file . "~/personal/business.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src



*** Searching based on the current word
This lets me search up and down.

#+begin_src emacs-lisp
(defun sacha/search-word-backward ()
  "Find the previous occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-backward "w_")
    (goto-char
     (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
	 (match-beginning 0)
       cur))))

(defun sacha/search-word-forward ()
  "Find the next occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-forward "w_")
    (goto-char
     (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
	 (match-beginning 0)
       cur))))
(global-set-key '[M-up] 'sacha/search-word-backward)
(global-set-key '[M-down] 'sacha/search-word-forward)
(defadvice search-for-keyword (around sacha activate)
  "Match in a case-insensitive way."
  (let ((case-fold-search t))
    ad-do-it))
#+end_src





*** Ido-mode: Show recent files
Ido-mode is awesome. Let's make it awesomer. I usually want to go to
recently-opened files first.

#+begin_src emacs-lisp
  (ido-mode 1)
  (setq ido-default-buffer-method 'selected-window)
  (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
  (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
  (defun ido-sort-mtime ()
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                        (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (ido-to-end  ;; move . files to end (again)
     (delq nil (mapcar
                (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                ido-temp-list))))

#+end_src



*** Minibuffer editing
    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. This binds =C-M-e= in a
    minibuffer) so that you can edit the contents of the minibuffer
    before submitting it.

#+begin_src emacs-lisp
  (use-package miniedit
    :commands minibuffer-edit
    :init
    (progn
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-ns-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-completion-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-must-match-map)))
#+end_src



*** Finding files
*** Don't show whitespace in diff, but show context
    #+begin_src emacs-lisp
    (setq vc-diff-switches '("-b" "-B" "-u"))
#+end_src
*** Expand region
#+begin_src emacs-lisp
  (sacha/package-install 'expand-region)
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

    I don't want to think about directory structures, I just want to
    open files. 

    #+begin_src emacs-lisp
      (require 'filecache)
      (require 'ido)
      (defun file-cache-ido-find-file (file)
        "Using ido, interactively open file from file cache'.
      First select a file, matched using ido-switch-buffer against the contents
      in `file-cache-alist'. If the file exist in more than one
      directory, select directory. Lastly the file is opened."
        (interactive (list (file-cache-ido-read "File: "
                                                (mapcar
                                                 (lambda (x)
                                                   (car x))
                                                 file-cache-alist))))
        (let* ((record (assoc file file-cache-alist)))
          (find-file
           (expand-file-name
            file
            (if (= (length record) 2)
                (car (cdr record))
              (file-cache-ido-read
               (format "Find %s in dir: " file) (cdr record)))))))
      
      (defun file-cache-ido-read (prompt choices)
        (let ((ido-make-buffer-list-hook
               (lambda ()
                 (setq ido-temp-list choices))))
          (ido-read-buffer prompt)))
      (add-to-list 'file-cache-filter-regexps "docs/html")
      (add-to-list 'file-cache-filter-regexps "\\.svn-base$")
      (add-to-list 'file-cache-filter-regexps "\\.dump$")
    #+end_src     

    To use this code, I add something like
    
    #+begin_src emacs-lisp :tangle no
      (sacha/file-cache-setup-tree "sacha/proj1" "C-c d"
                                   '("/dir1"
                                     "/dir2"))
    #+end_src
    to my config. Then =C-c d= (or whatever keyboard shortcut I use)
    searches for files within the specified directories.
    

*** Internet Relay Chat

    IRC is a great way to hang out with other Emacs geeks.
    #+begin_src emacs-lisp
      (use-package erc
        :config
        (setq erc-autojoin-channels-alist '(("freenode.net"
                                             "#org-mode"
                                             "#emacs"))
              erc-server "irc.freenode.net"
              erc-nick "sachac"))
    #+end_src





*** Avoiding weasel words
    #+begin_src emacs-lisp
      (use-package artbollocks-mode
        :init
        (progn
          (setq artbollocks-weasel-words-regex
                (concat "\\b" (regexp-opt
                               '("one of the"
                                 "should"
                                 "just"
                                 "sort of"
                                 "a lot"
                                 "probably"
                                 "maybe"
                                 "perhaps"
                                 "I think"
                                 "really"
                                 "pretty"
                                 "maybe"
                                 "nice"
                                 "action"
                                 "utilize"
                                 "leverage") t) "\\b"))
          ;; Don't show the art critic words, or at least until I figure
          ;; out my own jargon
          (setq artbollocks-jargon nil)))
#+end_src

*** Non-obtrusive parenthesis faces
   :PROPERTIES:
   :CUSTOM_ID: parenthesis-faces
   :END:
#+begin_src emacs-lisp
(defface starter-kit-paren-face
   '((((class color) (background dark))
      (:foreground "grey50"))
     (((class color) (background light))
      (:foreground "grey55")))
   "Face used to dim parentheses."
   :group 'starter-kit-faces)


(font-lock-add-keywords 'emacs-lisp-mode
			'(("(\\|)" . 'starter-kit-paren-face)))


#+end_src

*** remove-elc-on-save
#+begin_src emacs-lisp
  (defun starter-kit-remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (make-local-variable 'after-save-hook)
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))))
#+end_src

** other dots

| directory name      | http                                             |
|---------------------+--------------------------------------------------|
| emacs24-starter-kit | https://github.com/eschulte/emacs24-starter-kit  |
| jwiegley            | https://github.com/jwiegley/dot-emacs            |
| prelude             | https://github.com/bbatsov/prelude               |
| emacs-live          | https://github.com/overtone/emacs-live           |
| defunkt             | https://github.com/defunkt/emacs                 |
| cabbage             | https://github.com/senny/cabbage                 |
| purcell             | https://github.com/purcell/emacs.d               |
| magnars             | https://github.com/magnars/.emacs.d              |
| ghoseb              | https://github.com/ghoseb/dotemacs               |
| rmm5t               | https://github.com/rmm5t/dotfiles                |
| alexott             | https://github.com/alexott/emacs-configs         |
| starter-kit         | https://github.com/technomancy/emacs-starter-kit |


Other sites
- [[info:emacs#Init%20File][info:emacs#Init File]]
- http://www.emacswiki.org/emacs/RobertAdesamConfig
- http://www.emacswiki.org/emacs/EmacsInitFileOfSylecn
- http://www.emacswiki.org/emacs/CategoryDotEmacs
- sacha

** debugs and tools
:PROPERTIES:
:tangle:   no
:END:
*** hacking jw init.el
- regexp-search-replace
  
  #+begin_example
  ^;;;_[,. ]+\(.*\)$  
  #+end_example

  #+begin_example
  '#+end_src
  '** \1
  '#+begin_src emacs-lisp
  '\&  
  #+end_example
- clean-up extra end_src and insert last one
- adjust sections manually (allout format = programmatically possible too)
- add column properties thingy to add tangle option
- turn tangle on

*** alternative load-path method

#+begin_src emacs-lisp
  (defun test-funk ()
    (setq src-dir (expand-file-name "src" user-emacs-directory))
    ;; add the src directory to the load path
    (add-to-list 'load-path src-dir user-emacs-directory)
    ;; load all subdirectories
      (when (file-exists-p src-dir)
        (let ((default-directory src-dir))
          (normal-top-level-add-subdirs-to-load-path))))
#+end_src

#+begin_src emacs-lisp
  (defun test-funk ()
    (setq src-dir (expand-file-name "src" user-emacs-directory))
     (when (file-exists-p src-dir)
        (add-to-list 'load-path src-dir)
        (mapc #'sk-load
              (remove-duplicates
               (mapcar #'remove-extension
                       (directory-files user-dir t ".*\.\\(org\\|el\\)\\(\\.gpg\\)?$"))
               :test #'string=))))))
#+end_src

*** current startup bugz
**** flet
`flet' is an obsolete macro (as of 24.3); use either `cl-flet' or `cl-letf'. [3 times]
**** yas
Configuring package yasnippet...
File mode specification error: (void-function yas/initialize)
(No changes need to be saved)
ad-handle-definition: `yas-global-mode' got redefined
Configuring package yasnippet...
Wrote /Users/tonyday/.emacs.d/org-mode-prequel.el

**** helm-config
Could not load package helm-config
**** Could not load package ido-hacks
**** Could not load package ido-springboard
**** diary
No event to add
Appointment reminders enabled (no diary file found)
**** Could not load package keyfreq
**** ls does not support --dired; see `dired-use-ls-dired' for more details.
**** babel insisting on messaging tangled 

*** zeroed package bugz
 1. `flet' is an obsolete macro (as of 24.3); use either `cl-flet' or `cl-letf'.
 2.  org-fixup.el: redefined Org version



** remove results
:PROPERTIES:
:OPEN: [2012-10-20 Sat 20:00]
:LAST: [2012-10-20 Sat 20:00]
:END:

#+begin_src emacs-lisp
  (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward "^#\\+results:.*\n\\(^\|.+\n\\)*\n" nil t)
      (replace-match ""))
    )
#+end_src
